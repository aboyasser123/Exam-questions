<script>
    // ===================== البيانات =====================
    const subjects = {
        algo2: {
            name: "خوارزميات 2",
            lectures: {
                lec1: [
                 ],
                lec2: [
{
    "question": "ما هو الهيكل الرئيسي الذي تعتمد عليه خوارزمية Heap Sort لتحقيق كفاءتها العالية؟",
    "options": [
      "قائمة مرتبطة",
      "كومة ثنائية (Binary Heap)",
      "شجرة بحث ثنائية",
      "مصفوفة مرتبة"
    ],
    "correct": 1,
    "explanation": "تعتمد Heap Sort على هيكل 'الكومة الثنائية' (Binary Heap) - وهي شجرة ثنائية كاملة تحقق خاصية الكومة (الأب أكبر من الأبناء في Max Heap). هذا الهيكل يسمح بالوصول للعنصر الأكبر في O(1) وتحديث الهيكل في O(log n)."
  },
  {
    "question": "في أي مرحلة من Heap Sort يتم ضمان أن أكبر عنصر يصبح في أول المصفوفة؟",
    "options": [
      "مرحلة بناء الكومة",
      "مرحلة الترتيب النهائي",
      "قبل البدء بالخوارزمية",
      "في كل تكرار من المرحلة الثانية"
    ],
    "correct": 0,
    "explanation": "في نهاية مرحلة بناء الكومة (المرحلة الأولى)، تكون المصفوفة ممثلة كـ Max Heap، وبالتالي يكون العنصر الأكبر في الجذر، وهو أول عنصر في المصفوفة (إذا اعتبرنا الفهرس يبدأ من 1)."
  },
  {
    "question": "إذا كانت المصفوفة تحتوي على 100 عنصر، فكم مرة تقريباً ستهبط العقدة من الجذر إلى مستوى الورقة في أسوأ حالة أثناء عملية heapify-down؟",
    "options": [
      "حوالي 7 مرات",
      "حوالي 100 مرة",
      "حوالي 50 مرة",
      "مرة واحدة فقط"
    ],
    "correct": 0,
    "explanation": "ارتفاع شجرة ثنائية كاملة تحتوي على 100 عقدة هو ⌊log₂(100)⌋ ≈ 7 مستويات. في أسوأ حالة، قد تهبط العقدة من الجذر (المستوى 1) إلى مستوى الورقة (المستوى 7)، أي حوالي 7 عمليات هبوط أو مقارنات."
  },
  {
    "question": "لماذا نقوم بتبديل العنصر الأخير مع الجذر في بداية كل تكرار من المرحلة الثانية (الترتيب)؟",
    "options": [
      "لجعل الكومة عشوائية",
      "لنتمكن من تقليص حجم الكومة الفعال",
      "لأن العنصر الأخير هو الأصغر دائماً",
      "لأن هذا شرط لإنهاء الخوارزمية"
    ],
    "correct": 1,
    "explanation": "نبدل الجذر (الأكبر) مع آخر عنصر في الكومة الحالية لنضع العنصر الأكبر في مكانه النهائي الصحيح (في نهاية المصفوفة المرتبة). ثم نقلص حجم الكومة الفعال بمقدار 1، ونعيد بناء الكومة على العناصر المتبقية."
  },
  {
    "question": "إذا بدأنا فهرسة المصفوفة من 1، وكانت العقدة الحالية في الفهرس i=10، فما هو الفهرس الذي يمثل أبويها؟",
    "options": ["5", "10", "20", "3"],
    "correct": 0,
    "explanation": "للعقدة i، أبويها يكون في الفهرس ⌊i/2⌋. ⌊10/2⌋ = 5."
  },
  {
    "question": "في كود بناء الكومة، ما هو الغرض من الحلقة التي تبدأ من i=2 حتى n؟",
    "options": [
      "لترتيب المصفوفة نهائياً",
      "لإدخال كل عنصر جديد في الكومة والحفاظ على خاصية الكومة",
      "لحذف العناصر المكررة",
      "لحساب حجم الكومة"
    ],
    "correct": 1,
    "explanation": "هذه الحلقة تقوم ببناء الكومة بشكل تصاعدي. تبدأ من العنصر الثاني (i=2) وتدخل كل عنصر جديد في الكومة الحالية، ثم ترفعه لأعلى (heapify-up) إذا لزم الأمر للحفاظ على خاصية الكومة (الأب أكبر من الأبناء)."
  },
  {
    "question": "ما هو الشرط الذي يحدد ما إذا كانت العقدة i تمثل ورقة في الشجرة الثنائية الكاملة؟",
    "options": [
      "إذا كان 2*i > n",
      "إذا كان i == 1",
      "إذا كان i/2 == 0",
      "إذا كان i < n"
    ],
    "correct": 0,
    "explanation": "العقدة i تكون ورقة إذا لم يكن لها أبناء، أي إذا كان الفهرس المحسوب لابنها الأيسر (2*i) أكبر من العدد الكلي للعقد n (يتجاوز حدود المصفوفة)."
  },
  {
    "question": "ما هو دور المتحول `elt` في كود بناء الكومة؟",
    "options": [
      "يخزن قيمة العقدة التي نريد إدراجها في الكومة مؤقتاً قبل أن نجد مكانها المناسب",
      "يخزن قيمة الجذر",
      "يخزن حجم المصفوفة",
      "يستخدم كفهرس مؤقت"
    ],
    "correct": 0,
    "explanation": "يستخدم `elt` لحفظ قيمة العنصر الجديد (الموجود في الموقع i) قبل أن نبدأ في رفعه لأعلى. هذا مهم لأنه أثناء رفعه، قد ننقل قيم الأباء للأسفل، وعندما نجد المكان المناسب، نضع قيمة `elt` فيه."
  },
  {
    "question": "ماذا يحدث إذا كانت خاصية الكومة (الأب أكبر من الأبناء) محققة بالفعل عند إدخال عنصر جديد أثناء البناء؟",
    "options": [
      "تدخل حلقة while وتقوم بالعديد من التبديلات",
      "لا تدخل حلقة while أبداً، ويتم وضع العنصر في مكانه الحالي مباشرة",
      "تتوقف الخوارزمية",
      "تحذف العنصر الجديد"
    ],
    "correct": 1,
    "explanation": "شرط حلقة while هو أن يكون الأب أصغر من العنصر الجديد (`x[f] < elt`). إذا كان الأب بالفعل أكبر أو مساوٍ، فإن الشرط يكون خطأ، ولا ندخل الحلقة، ونضع `elt` في موقعه الحالي (`x[s] = elt`)."
  },
  {
    "question": "في مرحلة الترتيب، لماذا نستخدم حلقة تنازلية من i=n إلى 2؟",
    "options": [
      "لأننا نريد وضع أكبر عناصر متبقية في نهاية المصفوفة واحدة تلو الأخرى",
      "لأن الفهرس 1 محجوز للجذر",
      "لجعل الكومة أصغر تدريجياً",
      "السببان 1 و 3 معاً"
    ],
    "correct": 3,
    "explanation": "نبدأ من i=n لأننا نريد وضع أكبر عنصر (الجذر) في آخر موقع (i). بعد وضعه، نقلص حجم الكومة الفعال بمقدار 1 (i--). ننتهي عند i=2 لأنه عندما يتبقى عنصر واحد فقط، فهو تلقائياً في مكانه الصحيح."
  },
  {
    "question": "في كود المرحلة الثانية، ما هو معنى `lValue = x[i]`؟",
    "options": [
      "أخذ قيمة آخر عنصر في الكومة الحالية لتخزينها مؤقتاً",
      "تعيين قيمة الجذر",
      "نسخ قيمة أصغر عنصر",
      "حذف العنصر الأخير"
    ],
    "correct": 0,
    "explanation": "هذه الخطوة تحفظ قيمة العنصر الموجود في آخر موضع في الكومة الحالية (الموقف i). لاحقاً سنضع الجذر (الأكبر) في هذا الموضع، ونحاول إدراج `lValue` في مكان مناسب داخل الكومة المتبقية."
  },
  {
    "question": "ما هو الهدف من حلقة while الداخلية في مرحلة الترتيب؟",
    "options": [
      "لرفع قيمة صغيرة لأعلى في الكومة",
      "لهبوط بقيمة `lValue` لأعماق الكومة حتى تجد مكانها المناسب",
      "لترتيب المصفوفة بسرعة",
      "لحساب عدد العناصر"
    ],
    "correct": 1,
    "explanation": "هدفها هو استعادة خاصية الكومة بعد وضع `lValue` (الذي كان في آخر موضع) في الجذر. نقارن `lValue` مع أكبر أبناء العقدة الحالية (`value`). إذا كان `lValue` أصغر، ندفع الابن الكبير لأعلى، ونهبط بـ `lValue` للأسفل. نستمر حتى يصبح `lValue` أكبر من أبنائه، أو نصبح في منطقة مرتبة."
  },
  {
    "question": "لماذا نتحقق من الشرط `if (s+1 <= i-1)` داخل حلقة while في مرحلة الترتيب؟",
    "options": [
      "للتأكد من وجود أخ أيمن للعقدة الحالية ضمن نطاق الكومة غير المرتبة",
      "للتأكد من أن الفهرس لا يتجاوز n",
      "لمعرفة إذا كانت العقدة ورقة",
      "لحساب عدد الإخوة"
    ],
    "correct": 0,
    "explanation": "العقدة الحالية لها ابن أيسر في `s = 2*f`. هذا الشرط يتحقق مما إذا كان لها أيضاً ابن أيمن، وذلك عن طريق التحقق من أن `s+1` (فهرس الابن الأيمن) أقل من أو يساوي `i-1` (آخر فهرس في الكومة غير المرتبة). إذا وجد، نقارن بين الابن الأيسر والأيمن لاختيار الأكبر."
  },
  {
    "question": "ماذا يعني تعيين `s = 0` داخل شروط if في مرحلة الترتيب؟",
    "options": [
      "لتهيئة الفهرس لبداية جديدة",
      "كعلامة (flag) لكسر حلقة while الداخلية لاحقاً",
      "لحذف العنصر الحالي",
      "للدلالة على أننا وصلنا للجذر"
    ],
    "correct": 1,
    "explanation": "عندما نكون في حالة يجب فيها الخروج من حلقة while (مثل دخول منطقة مرتبة أو عدم وجود أبناء للمقارنة)، نعين `s = 0`. شرط استمرار حلقة while غالباً ما يكون `(s > 0) && ...`، لذا فإن `s = 0` سيكسر الحلقة."
  },
  {
    "question": "إذا كانت المصفوفة [3, 5, 1, 4, 2]، فما هي حالتها بعد مرحلة بناء الكومة (Max Heap)؟",
    "options": [
      "[5, 4, 1, 3, 2]",
      "[1, 2, 3, 4, 5]",
      "[2, 3, 1, 5, 4]",
      "[5, 3, 4, 1, 2]"
    ],
    "correct": 0,
    "explanation": "بعد بناء Max Heap، يجب أن يكون الجذر (الموقع 1) هو الأكبر (5). وكل أب أكبر من أبنائه. الشجرة: الجذر 5، أبناؤه 4 و1، ابن 4 هو 3 و2. المصفوفة: [5, 4, 1, 3, 2] (بافتراض الفهرس 1)."
  },
  {
    "question": "ما هو التعقيد الزمني الإجمالي لـ Heap Sort؟ ولماذا؟",
    "options": [
      "O(n) لأنها تمر على العناصر مرة واحدة",
      "O(n log n) لأن بناء الكومة O(n) وكل من عمليات n-1 استخراج تحتاج O(log n)",
      "O(n²) لأنها تحتوي على حلقتين متداخلتين",
      "O(log n) لأنها تعمل على شجرة"
    ],
    "correct": 1,
    "explanation": "البناء: O(n). ثم ننفذ عملية استخراج وإعادة بناء (heapify-down) لـ n-1 عنصر. كل عملية heapify-down في أسوأ الحالات هي O(log n). الإجمالي: O(n) + (n-1)*O(log n) = O(n log n)."
  },
  {
    "question": "هل يمكن استخدام بنية الكومة (Heap) لأغراض أخرى غير الفرز؟",
    "options": [
      "لا، صممت للفرز فقط",
      "نعم، مثل تنفيذ قائمة انتظار ذات أولوية (Priority Queue)",
      "نعم، لحل مسائل البحث فقط",
      "نعم، لضغط البيانات"
    ],
    "correct": 1,
    "explanation": "بنية الكومة هي أساس هيكل بيانات 'قائمة الانتظار ذات الأولوية' (Priority Queue)، حيث يمكن إدراج عناصر بأولويات واستخراج العنصر ذي الأولوية القصوى (أو الدنيا) بكفاءة."
  },
  {
    "question": "إذا كان لديك كومة عظمى (Max Heap) تحتوي على العناصر [50, 30, 20, 15, 10, 8, 16]، وقمت باستخراج العنصر الأكبر (50) وأعدت بناء الكومة، ما هي العناصر الجديدة في الكومة؟",
    "options": [
      "[30, 20, 16, 15, 10, 8]",
      "[30, 16, 20, 15, 10, 8]",
      "[30, 15, 20, 8, 10, 16]",
      "[16, 30, 20, 15, 10, 8]"
    ],
    "correct": 1,
    "explanation": "بعد استخراج 50، نضع آخر عنصر (16) في الجذر. ثم ننفذ heapify-down: 16 < max(30,20) → نبدل 16 مع 30 (الأكبر). 16 < max(15,10) → نبدل 16 مع 15 (توقف لأن 15 و10 أصغر من 16). النتيجة: [30, 16, 20, 15, 10, 8]."
  },
  {
    "question": "ما هو الشرط الذي يجعل حلقة while في مرحلة الترتيب تتوقف بسبب 'دخول مرحلة الترتيب'؟",
    "options": [
      "عندما يكون `lValue` أكبر من جميع الأبناء",
      "عندما لا يكون للعقدة الحالية أبناء ضمن نطاق الكومة غير المرتبة (s >= i)",
      "عندما نصل إلى الجذر",
      "عندما تكون المصفوفة مرتبة"
    ],
    "correct": 1,
    "explanation": "عندما نصل إلى عقدة يكون أبناؤها (s = 2*f) خارج نطاق الكومة التي لم نرتبها بعد (أي s >= i)، فهذا يعني أننا في المنطقة التي تم ترتيبها بالفعل (العناصر الكبيرة في النهاية). عندها نكسر الحلقة ونضع `lValue` في العقدة الفارغة الحالية."
  },
  {
    "question": "لماذا تعتبر Heap Sort خوارزمية 'غير مستقرة' (Unstable)؟",
    "options": [
      "لأنها قد تغير الترتيب النسبي للعناصر المتساوية في القيمة",
      "لأنها تستخدم ذاكرة إضافية",
      "لأن تعقيدها الزمني غير ثابت",
      "لأنها لا تعمل على المصفوفات"
    ],
    "correct": 0,
    "explanation": "خلال عمليات التبديل التي تحدث أثناء بناء الكومة أو heapify-down، قد ينتهي بأحد العناصر المتساوية في القيمة قبل الآخر في المصفوفة النهائية، على الرغم من أنه كان بعده في المصفوفة الأصلية. لذا لا تحافظ على الاستقرار."
  },
                     {
    "question": "ما هو الاختلاف الرئيسي بين طريقة بناء الكومة من أسفل إلى أعلى (Bottom-up) مقابل الطريقة المستخدمة في المحاضرة (من أعلى إلى أسفل بالإدراج المتتالي)؟",
    "options": [
      "الطريقة Bottom-up أسرع وتعقيدها O(n)، بينما الطريقة في المحاضرة O(n log n)",
      "لا يوجد اختلاف، كلتاهما O(n log n)",
      "الطريقة في المحاضرة أسرع لأنها أبسط",
      "الطريقة Bottom-up لا تعمل مع Max Heap"
    ],
    "correct": 0,
    "explanation": "الطريقة Bottom-up (تبدأ من العقد غير الورقية وتنفذ heapify-down عليها) لها تعقيد خطي O(n) أثباتاً رياضياً. الطريقة في المحاضرة (إدراج عناصر واحدا تلو الآخر ورفعها heapify-up) لها تعقيد O(n log n) ولكنها أبسط في الفهم والتنفيذ."
  },
  {
    "question": "في سياق خوارزمية Heap Sort، ماذا يعني أن الكومة تكون 'مشروطة جزئياً' (Partial Order)؟",
    "options": [
      "أن العناصر مرتبة ترتيباً كاملاً تصاعدياً",
      "أن العلاقة بين الأب وأبنائه محفوظة، ولكن ليس بالضرورة بين الإخوة أو بين عمودين مختلفين",
      "أن الكومة فارغة جزئياً",
      "أن بعض العنوانات مفقودة"
    ],
    "correct": 1,
    "explanation": "خاصية الكومة تضعل فقط أن كل أب أكبر من (أو يساوي) أبنائه المباشرين. لا تضعل شيئاً عن العلاقة بين الأخوة (اليسار واليمين) أو بين ابن وعمه. هذا يخلق ترتيباً جزئياً وليس كاملاً، لكنه كافٍ لضمان أن الجذر هو الأكبر."
  },
  {
    "question": "إذا كان لدينا مصفوفة حجمها n=16، ما هو عدد العقد غير الورقية فيها؟",
    "options": ["8", "7", "15", "9"],
    "correct": 0,
    "explanation": "في شجرة ثنائية كاملة، عدد العقد غير الورقية = ⌊n/2⌋. ⌊16/2⌋ = 8. هذه العقد تبدأ من الفهرس 1 إلى 8."
  },
  {
    "question": "خلال عملية heapify-down، كيف نختار الابن الذي نبدل معه الأب إذا كان الأب أصغر من كلا الابنين؟",
    "options": [
      "نبدل مع الابن الأيسر دائماً",
      "نبدل مع الابن الأيمن دائماً",
      "نبدل مع الابن الأكبر منهما",
      "نبدل مع أي ابن عشوائياً"
    ],
    "correct": 2,
    "explanation": "نقارن بين الابن الأيسر والأيمن (إذا كانا موجودين) ونختار الأكبر. ثم نقارن هذا الابن الأكبر مع الأب. إذا كان الابن أكبر، نبدل. هذا يحافظ على خاصية الكومة (الأب أكبر من كلا الابنين بعد التبديل)."
  },
  {
    "question": "ما هو الخطأ المنطقي الذي سيحدث إذا استخدمنا شرط `while (s > 1 && x[f] <= elt)` بدلاً من `<` في كود البناء؟",
    "options": [
      "سيؤدي إلى دخول لا نهائي إذا كان الأب مساوياً للابن",
      "سيتوقف مبكراً جداً",
      "سيجعل الخوارزمية أسرع",
      "لن يؤثر لأن المساواة مقبولة"
    ],
    "correct": 0,
    "explanation": "إذا كان الأب مساوياً للابن (`x[f] == elt`)، فباستخدام `<=` سيكون الشرط صحيحاً، وسنستمر في رفع الابن حتى الجذر مع أنهما متساويان، مما قد يؤدي إلى تكرار لا نهائي إذا لم نحدّث المؤشرات بشكل صحيح. الأصح هو `<` فقط، لأن المساواة تحقق خاصية الكومة (الأب >= الأبناء)."
  },
  {
    "question": "لماذا في مرحلة الترتيب نحتاج إلى متحولين `lValue` و `value`؟ لماذا لا نستخدم `elt` فقط؟",
    "options": [
      "لأن `elt` مستخدم في المرحلة الأولى فقط",
      "لأن `lValue` هو العنصر المنقول من النهاية، و`value` هو أكبر أبناء العقدة الفارغة أثناء الهبوط",
      "لجعل الكود أطول",
      "لا يوجد سبب، يمكن استخدام `elt`"
    ],
    "correct": 1,
    "explanation": "`lValue` يحفظ قيمة العنصر الذي أخذناه من آخر موضع (x[i]) والذي نريد إيجاد مكان له. `value` يحفظ قيمة أكبر ابن للعقدة الفارغة الحالية (f) أثناء هبوطنا لأسفل. هذان دوران مختلفان. استخدام متحول واحد قد يسبب كتابة فوق القيم قبل الأوان."
  },
  {
    "question": "إذا أردنا فرز المصفوفة تنازلياً (من الأكبر إلى الأصغر) باستخدام Heap Sort، ما هو التغيير البسيط الذي يمكن إجراؤه؟",
    "options": [
      "استخدام Min Heap بدلاً من Max Heap",
      "عكس اتجاه الحلقة النهائية",
      "تغيير جميع علامات المقارنة",
      "الإجابة 1 و 2 معاً"
    ],
    "correct": 0,
    "explanation": "للفرز تنازلياً، نبني Min Heap (حيث الأب أصغر من الأبناء). عندها سيكون العنصر الأصغر في الجذر. في مرحلة الترتيب، نستخرج الأصغر ونضعه في البداية (أو في النهاية ثم نعكس). العمليات المتبقية تبقى كما هي."
  },
  {
    "question": "ما هو الوضع الأمثل (Best Case) لمدخلات Heap Sort؟ وما هو تعقيده الزمني في هذه الحالة؟",
    "options": [
      "مصفوفة مرتبة تصاعدياً، O(n)",
      "مصفوفة مرتبة تنازلياً، O(n log n)",
      "مصفوفة عشوائية، O(n log n)",
      "لا يوجد وضع أمثل، التعقيد دائماً O(n log n)"
    ],
    "correct": 3,
    "explanation": "Heap Sort ليس لديها حالة أفضل مختلفة بشكل كبير. حتى لو كانت المصفوفة مرتبة بالفعل، فإن بناء الكومة لا يزال يتطلب O(n) في أفضل التقنيات، وكل عملية heapify-down في مرحلة الترتيب قد تستغرق O(log n). التعقيد يبقى Θ(n log n) في جميع الحالات."
  },
  {
    "question": "ماذا سيكون تأثير خطأ برمجي جعلنا نبدأ الحلقة التنازلية من i=n إلى 1 (بدلاً من إلى 2)؟",
    "options": [
      "سيفرز العنصر الأخير مرتين",
      "عند i=1، سنحاول وضع الجذر في مكانه وهو مكانه بالفعل، وقد يسبب خطأ أو تبديل غير ضروري",
      "سيجعل الخوارزمية أسرع",
      "لن يتغير شيء"
    ],
    "correct": 1,
    "explanation": "عندما i=1، سيكون حجم الكومة المتبقية عنصراً واحداً. عملية أخذ الجذر ووضعه في المكان i=1 هي نفس المكان. الكود قد يحاول عمل مقارنات وتبديلات غير ضرورية مع عناصر خارج الحدود أو يدخل في حلقة لا نهائية إذا لم يكن محمياً بشروط مناسبة."
  },
  {
    "question": "كيف يمكنك تعديل خوارزمية Heap Sort لترتيب مصفوفة من السجلات (Records) بناءً على حقل معين (مثل العمر)؟",
    "options": [
      "لا يمكن، تعمل فقط على الأرقام",
      "نقوم بمقارنة القيمة الموجودة في الحقل المطلوب أثناء جميع عمليات المقارنة في الخوارزمية",
      "نحول كل سجل إلى رقم",
      "نستخدم مصفوفة منفصلة للفهارس"
    ],
    "correct": 1,
    "explanation": "نغير دوال المقارنة فقط. بدلاً من مقارنة `x[f] < elt`، نقارن `x[f].age < elt.age` (إذا كان الحقل اسمه age). باقي الخوارزمية يبقى كما هو (تبديل السجلات كاملة، إلخ). هذا يجعلها خوارزمية فرز عامة قابلة للتخصيص."
  },
  {
    "question": "ما هو الغرض من التعديل `f = s/2` داخل حلقة while في مرحلة البناء؟",
    "options": [
      "لتحريك المؤشر f (الأب) إلى مستوى أعلى (أقرب إلى الجذر) في التكرار التالي",
      "لتحريك المؤشر للأسفل",
      "لحساب الابن الجديد",
      "لتهيئة f بقيمة جديدة"
    ],
    "correct": 0,
    "explanation": "بعد أن ننقل قيمة الأب للأسفل (`x[s] = x[f]`)، نريد في التكرار التالي مقارنة `elt` مع الأب الجديد (أب الأب السابق). لذلك نحرك المؤشر s إلى مكان الأب القديم (`s = f`)، ثم نحسب أبه الجديد: `f = s/2`. وهكذا نصعد في الشجرة."
  },
  {
    "question": "لماذا في بعض تطبيقات Heap Sort، تتم تهيئة الحلقة الأولى من i = n/2 إلى 1 (تنازلياً)؟",
    "options": [
      "لأن هذا هو بناء الكومة بطريقة Bottom-up الأكثر كفاءة",
      "لأنه يبدأ من الأوراق",
      "لأنه أسهل في الكتابة",
      "لا يوجد سبب، هو نفس الشيء"
    ],
    "correct": 0,
    "explanation": "هذه هي الطريقة الأمثل لبناء الكومة (تعقيد O(n)). نبدأ من آخر عقدة غير ورقية (n/2) وننفذ heapify-down عليها، ثم ننتقل للعقدة التي قبلها، وهكذا حتى الجذر. هذا يستفيد من حقيقة أن الأشجار الفرعية الصغيرة هي بالفعل كومات."
  },
  {
    "question": "إذا قمت بتشغيل Heap Sort على مصفوفة [1,2,3,4,5,6,7]، فكم عدد التبديلات الإضافية التي ستحدث مقارنة لو كانت المصفوفة مرتبة تنازلياً [7,6,5,4,3,2,1]؟",
    "options": [
      "سيكون هناك تبديلات أكثر في الحالة الأولى",
      "سيكون هناك تبديلات أقل في الحالة الأولى",
      "سيكون العدد متساوياً تقريباً",
      "لا يمكن معرفة"
    ],
    "correct": 1,
    "explanation": "عندما تكون المصفوفة مرتبة تصاعدياً (وأردنا ترتيبها تصاعدياً أيضاً)، فإن بناء Max Heap سيتطلب رفع كل عنصر صغير من أسفل الشجرة إلى مكانه الصحيح أعلى، مما يتطلب الكثير من التبديلات. بينما إذا كانت المصفوفة مرتبة تنازلياً، فهي قريبة من Max Heap بالفعل (الجذر هو الأكبر)، وسيتطلب بناء الكومة تبديلات أقل. بشكل عام، حالة الترتيب التصاعدي هي من أسوأ الحالات لبناء الكومة."
  },
  {
    "question": "ما هو التحدي الرئيسي في تنفيذ Heap Sort باستخدام فهرسة تبدأ من 0؟",
    "options": [
      "معادلات حساب الأب والأبناء تتغير",
      "لا يمكن تنفيذها",
      "الخوارزمية تصبح أبطأ",
      "يجب إضافة عنصر وهمي في البداية"
    ],
    "correct": 0,
    "explanation": "المعادلات تتغير: الأب لـ i يصبح (i-1)/2، الابن الأيسر يصبح 2*i+1، الابن الأيمن 2*i+2. يجب تعديل كل الشروط التي تستخدم هذه الحسابات في الكود، وأيضاً شروط التوقف مثل `s > 1` تصبح `s > 0` أو ما شابه."
  },
  {
    "question": "في نهاية مرحلة الترتيب، عندما i=2، لماذا نعتبر أن الفرز اكتمل؟",
    "options": [
      "لأن العنصرين المتبقيين (في الفهرس 1 و 2) سيتم ترتيبهم تلقائياً بتبديل بسيط",
      "لأنه لم يتبق سوى عنصر واحد",
      "لأن الحلقة تنتهي عند i=2",
      "لأن الكومة تختفي"
    ],
    "correct": 0,
    "explanation": "عندما i=2، حجم الكومة غير المرتبة هو عنصرين (في الفهرس 1 و 2). في Max Heap، العنصر في الفهرس 1 (الجذر) هو الأكبر بينهما. عملية التبديل (`x[2] = x[1]`) ثم إدراج `lValue` في الجذر ستؤدي إلى أن يصبح العنصر الأكبر في الفهرس 2، والأصغر في الفهرس 1. وهكذا اكتمل الترتيب."
  },
  {
    "question": "ما هو دور الشرط `if (s > 1)` داخل حلقة while في كود البناء (السطور 20-25 في الكود المعطى)؟",
    "options": [
      "للتأكد من أننا لم نصل إلى الجذر بعد قبل حساب أب جديد",
      "لحساب الأب بطريقة مختلفة إذا وصلنا للجذر",
      "لمنع القسمة على صفر",
      "الإجابتان 1 و 2"
    ],
    "correct": 3,
    "explanation": "عندما نصعد ونجد أن `s` أصبحت 1 (أي وصلنا للجذر)، فإن حساب `f = s/2` سيكون 0 (إذا كانت القسمة صحيحة). الفهرس 0 غير صالح (إذا بدأنا من 1). لذلك، نتحقق: إذا `s > 1` نحسب الأب، وإلا (s=1) نضع `f = 1` أو نخرج من الحلقة. في الكود المعطى، يضع `f = 1`، لكن هذا قد يسبب مشكلة لأن حلقة while ستحاول المقارنة مع `x[1]` مجدداً وقد تدور لا نهائياً إذا لم ينكسر شرط آخر (`x[f] < elt`)."
  },
  {
    "question": "إذا كان لدينا كومة عظمى تحتوي على أعداد مكررة، فهل يمكن أن يكون هناك أكثر من كومة عظمى صحيحة تمثل نفس المصفوفة؟",
    "options": [
      "لا، الكومة العظمى فريدة لمصفوفة معينة",
      "نعم، لأن الإخوة يمكن تبديلهم مع الحفاظ على خاصية الكومة",
      "فقط إذا كانت المصفوفة مرتبة",
      "فقط إذا كانت الأعداد كلها متساوية"
    ],
    "correct": 1,
    "explanation": "خاصية الكومة لا تحدد ترتيب الإخوة (الابن الأيسر واليمين). إذا كان لديك أب بقيم أبناء متساوية، يمكن تبديل مواقع الأبناء ولا تزال الخاصية محققة. لذا قد يكون هناك تمثيلات شجرية مختلفة لنفس المصفوفة كـ Max Heap."
  },
  {
    "question": "كيف تؤثر خاصية 'الشجرة الثنائية الكاملة' على كفاءة خوارزمية Heap Sort؟",
    "options": [
      "تضمن أن ارتفاع الشجرة هو ⌊log n⌋، مما يحافظ على تعقيد O(log n) لعمليات الرفع والهبوط",
      "تزيد من التعقيد لأنها تفرض هيكلاً صارماً",
      "تسمح باستخدام مصفوفة بدلاً من مؤشرات، مما يوفر ذاكرة",
      "الإجابتان 1 و 3"
    ],
    "correct": 3,
    "explanation": "1) الشكل الكامل يضمن أن الشجرة مضغوطة وارتفاعها لوغاريتمي، وهذا أساس لضمان أن heapify-up و heapify-down هما O(log n). 2) لأنه شكل كامل، يمكن تمثيله بمصفوفة بسيطة دون الحاجة لمؤشرات (left/right)، باستخدام معادلات حسابية للعلاقات، مما يوفر الذاكرة ويبسط التنفيذ."
  },
  {
    "question": "ما هو الموقف الذي قد تختار فيه Quick Sort على Heap Sort رغم أن تعقيد أسوأ حالة لـ Quick Sort هو O(n²)؟",
    "options": [
      "عندما تكون البيانات كبيرة جداً وتريد أسوأ حالة مضمونة",
      "عندما يكون الذاكرة محدودة للغاية",
      "عندما تكون بياناتك عشوائية وتريد أسرع أداء عملي في المتوسط",
      "عندما تحتاج فرز مستقر (Stable Sort)"
    ],
    "correct": 2,
    "explanation": "في الممارسة العملية، على بيانات عشوائية، Quick Sort أسرع من Heap Sort بسبب ثوابت التنفيذ الأصغر وتوافقها مع ذاكرة التخزين المؤقت. ومع أن أسوأ حالة Quick Sort هي O(n²)، إلا أن هذا نادر مع اختيار محور (pivot) جيد. لذا للبيانات العامة، يفضل Quick Sort للسرعة."
  },
  {
    "question": "خلال عملية heapify-down في مرحلة الترتيب، ماذا يحدث إذا كان للعقدة الحالية ابن واحد فقط (يساري)؟",
    "options": [
      "نقارن معه مباشرة لأنه الابن الوحيد",
      "نبحث عن ابن أيمن ونجد أنه غير موجود، فنخرج",
      "نعتبر أن العقدة ورقة",
      "نستخدم قيمة افتراضية للابن الأيمن"
    ],
    "correct": 0,
    "explanation": "نحسب `s = 2*f` (الابن الأيسر). ثم نتحقق مما إذا كان له ابن أيمن (`s+1 <= i-1`). إذا لم يكن له (أي s+1 > i-1)، فإن `s` يمثل الابن الوحيد (الأيسر). نقارن `lValue` مع `x[s]` مباشرة. لا داعي لمقارنة الإخوة."
  },
  {
    "question": "ما هو معنى القيمة التي نخرج بها من حلقة while في مرحلة الترتيب (القيمة التي نضعها في `s` لنكسر الحلقة)؟",
    "options": [
      "فهرس العقدة الفارغة النهائية التي يجب وضع `lValue` فيها",
      "فهرس أكبر ابن",
      "القيمة صفر فقط للإشارة",
      "فهرس الجذر الجديد"
    ],
    "correct": 0,
    "explanation": "نحن نهبط بـ `lValue` للأسفل. في كل خطوة، ننقل أكبر ابن (`value`) لأعلى إلى العقدة الفارغة (`f`). ثم نجعل العقدة الفارغة الجديدة هي مكان ذلك الابن (`f = s`). نستمر حتى نتوقف. الفهرس `s` النهائي (قبل تعيينه 0) أو الفهرس `f` هو موقع العقدة الفارغة الذي يجب أن نضع فيه `lValue` (`x[f] = lValue`)."
  },
  {
    "question": "لماذا يتم تنفيذ `x[i] = x[1]` في بداية كل تكرار من المرحلة الثانية؟",
    "options": [
      "لنسخ قيمة الجذر (الأكبر) إلى نهاية الكومة الحالية، وهو مكانه النهائي المرتب",
      "لحذف قيمة الجذر",
      "لتهيئة `x[i]`",
      "لجعل `x[1]` فارغاً"
    ],
    "correct": 0,
    "explanation": "هذا هو جوهر عملية الاستخراج. العنصر الأكبر في الكومة غير المرتبة موجود في الجذر `x[1]`. مكانه النهائي في المصفوفة المرتبة هو الموضع الأخير من الجزء غير المرتب (`i`). لذلك ننقله إلى هناك."
  },
  {
    "question": "في الكود المعطى، ما هو دور المقطع التالي؟\n`if (i == 2) { s = 0; } else { s = 2; }`",
    "options": [
      "تهيئة بدائية لمؤشر الابن عند بدء عملية الهبوط لـ `lValue`، مع معالجة خاصة عندما يكون حجم الكومة 2",
      "كسر الحلقة فوراً عندما i==2",
      "تعيين الابن الأيسر للجذر مباشرة",
      "خطأ برمجي محتمل"
    ],
    "correct": 0,
    "explanation": "هذا المقطع يبدو أنه جزء من تهيئة بدء عملية البحث عن أكبر ابن للجذر (العقدة 1) بعد وضع `lValue` فيه. عادة أكبر أبناء الجذر هما العقدة 2 و3. عندما i==2 (أي بقي عنصران فقط)، فإن العقدة 3 خارج الحدود (i-1 =1). لذا، نعين s=0 ربما للإشارة إلى أنه لا يوجد ابن للمقارنة (أو الابن الوحيد هو 2). التهيئة s=2 في الحالة الأخرى تفترض أن الابن الأيسر (2) هو المرشح الابتدائي، وسيتم تعديله لاحقاً إذا كان الابن الأيمن (3) أكبر وأيضاً ضمن الحدود."
  },
  {
    "question": "ما هو العيب الأساسي الذي يمنع Heap Sort من أن تكون الخيار الأول غالباً في المكتبات القياسية للفرز؟",
    "options": [
      "تعقيد الذاكرة الإضافي",
      "عدم الاستقرار (Unstable)",
      "الثوابت العالية التي تجعلها أبطأ عملياً من خوارزميات مثل Quick Sort أو Merge Sort في كثير من الحالات",
      "تعقيد التنفيذ"
    ],
    "correct": 2,
    "explanation": "رغم أن لها تعقيداً زمنياً جيداً O(n log n) وتعمل في المكان، إلا أن عدد العمليات والمقارنات فيها (الثوابت) أعلى من منافسيها. Quick Sort أسرع عملياً في المتوسط، و Merge Sort مستقر ويعطي أداءً متوقعاً. لذا تستخدم Heap Sort في سياقات محددة (مثل أنظمة الوقت الحقيقي حيث أسوأ حالة O(n log n) مهم، أو عند قيود الذاكرة)."
  },
  {
    "question": "إذا قمت بتشغيل Heap Sort على مصفوفة مكونة من عنصر واحد فقط، فكم عدد المرات التي ستدخل فيها الحلقة الرئيسية للبناء؟",
    "options": ["0", "1", "2", "تعتمد على قيمة العنصر"],
    "correct": 0,
    "explanation": "حلقة البناء تبدأ من i=2 إلى n. إذا كان n=1، فإن نطاق الحلقة (2..1) فارغ، ولن تنفذ أي تكرار. الخوارزمية ستعتبر المصفوفة المرتبة من عنصر واحد بمثابة كومة صحيحة (و ترتيبها مكتمل)."
  },
  {
    "question": "ما الفرق بين 'رفع' عنصر (heapify-up) و 'هبوط' عنصر (heapify-down)؟ ومتى نستخدم كل منها؟",
    "options": [
      "الرفع: عند إدخال عنصر جديد في نهاية الكومة. الهبوط: عند استخراج الجذر أو تخفيض قيمة جذر.",
      "الرفع: عند استخراج الجذر. الهبوط: عند إدخال عنصر جديد.",
      "كلاهما نفس الشيء",
      "الرفع: لبناء الكومة. الهبوط: لتفكيكها."
    ],
    "correct": 0,
    "explanation": "الرفع (Heapify-up / Sift-up): نستخدمه عندما نضيف عنصراً في نهاية الكومة (أو نزيد قيمة عقدة). نقارنه مع أبيه ونسحبه لأعلى إذا كان أكبر (في Max Heap). الهبوط (Heapify-down / Sift-down): نستخدمه عندما نستبدل الجذر بقيمة أصغر (مثل بعد استخراج العنصر الأكبر، نضع آخر عنصر في الجذر). نقارنه مع أكبر أبنائه وندفعه للأسفل."
  },
  {
    "question": "كيف يمكنك تعديل Heap Sort لفرز أول k من أكبر العناصر فقط (بدلاً من كل العناصر)؟",
    "options": [
      "ننفذ مرحلة البناء كاملة، ثم نستخرج الجذر k مرات فقط",
      "نفرز الكل ثم نأخذ أول k عنصر",
      "لا يمكن",
      "نبني كومة صغيرة حجم k فقط"
    ],
    "correct": 0,
    "explanation": "هذا أحد الاستخدامات العملية للكومة. نبني Max Heap (O(n)). ثم نستخرج الجذر (الأكبر) ونعيد بناء الكومة (O(log n)). نكرر هذه العملية k مرات. التعقيد الكلي: O(n + k log n). إذا كان k صغيراً مقارنة بـ n، فهذا فعال جداً."
  },
  {
    "question": "في التمثيل بالمصفوفة، لماذا من المهم أن تكون الشجرة 'ممتلئة من اليسار' (Left-complete)؟",
    "options": [
      "لضمان عدم وجود فراغات في منتصف المصفوفة، وبالتالي استخدام الذاكرة بكفاءة",
      "لجعل الشجرة أسرع في البحث",
      "لجعل العلاقات بين الأب والابن تعمل دائماً بنفس المعادلات",
      "الإجابتان 1 و 3"
    ],
    "correct": 3,
    "explanation": "1) الشكل الممتلئ من اليسار يعني أننا نملأ المصفوفة بالتسلسل من الفهرس 1 إلى n بدون فراغات. 2) هذا يضمن أن معادلات (أب لـ i هو i/2، أبناء i هم 2i و 2i+1) تكون صحيحة لجميع العقد التي لها أبناء، دون الحاجة إلى فحص إضافي."
  },
  {
    "question": "إذا أردت تنفيذ قائمة انتظار ذات أولوية (Priority Queue) باستخدام كومة، فما هي العمليات الأساسية وتعقيداتها؟",
    "options": [
      "إدراج (Insert): O(log n)، إزالة الأعلى (Extract-Max): O(log n)، عرض الأعلى (Peek): O(1)",
      "إدراج: O(1)، إزالة: O(n)، عرض: O(1)",
      "إدراج: O(n)، إزالة: O(1)، عرض: O(n)",
      "كل العمليات O(log n)"
    ],
    "correct": 0,
    "explanation": "هذا هو السبب الرئيسي لشعبية بنية الكومة. الإدراج: نضيف في النهاية ثم نرفع (heapify-up) O(log n). إزالة الأعلى: نستبدل الجذر بآخر عنصر ثم نهبط (heapify-down) O(log n). عرض الأعلى (رؤية العنصر ذي الأولوية القصوى دون حذفه): ببساطة ننظر للجذر O(1)."
  },
  {
    "question": "ما هو الخطأ في المنطق التالي: 'بما أن بناء الكومة يأخذ O(n) ومرحلة الترتيب تأخذ O(n log n)، إذاً تعقيد Heap Sort هو O(n log n) لأن الحد الأكبر هو المهيمن'؟",
    "options": [
      "لا يوجد خطأ، هذا صحيح تماماً",
      "الخطأ أن بناء الكومة يأخذ O(n log n) في الطريقة التي نستخدمها",
      "الخطأ أن الحد الأصغر O(n) لا يؤثر على التدوين المقارب",
      "الخطأ أن مرحلة الترتيب هي O(n)"
    ],
    "correct": 0,
    "explanation": "هذا المنطق صحيح. في التحليل المقارب (Big O)، نأخذ الحد الذي ينمو أسرع مع زيادة n. O(n + n log n) = O(n log n) لأن n log n ينمو أسرع من n. العبارة صحيحة سواء كان بناء الكومة O(n) أو O(n log n) (في طريقتنا)."
  },
  {
    "question": "إذا كان لدينا مصفوفة مرتبة تصاعدياً وأردنا تحويلها إلى Max Heap بأقل عدد من التبديلات، ما هي الاستراتيجية؟",
    "options": [
      "نبدأ من أول عنصر ونرفع كل عنصر",
      "نبدأ من آخر عقدة غير ورقية وننفذ heapify-down عليها نحو الأعلى (طريقة Bottom-up)",
      "نعكس المصفوفة أولاً",
      "نستخدم خوارزمية مختلفة"
    ],
    "correct": 1,
    "explanation": "الطريقة الأكثر كفاءة هي البناء من الأسفل إلى الأعلى (Bottom-up). نبدأ من الفهرس n/2 (أول عقدة غير ورقية من الأسفل) ونتجه نحو الجذر (نزل إلى 1). لكل عقدة، ننفذ heapify-down. هذه الطريقة تستغرق O(n) وستكون فعالة حتى لو كانت المصفوفة مرتبة تصاعدياً (وهي حالة صعبة)."
  },
  {
    "question": "لماذا تعتبر خوارزمية Heap Sort مناسبة لأنظمة الوقت الحقيقي (Real-time Systems) أكثر من Quick Sort؟",
    "options": [
      "لأنها أسرع دائماً",
      "لأنها تعطي ضماناً لأسوأ حالة زمنية (O(n log n))، بينما أسوأ حالة Quick Sort O(n²) غير مقبولة في الوقت الحقيقي",
      "لأنها تستخدم ذاكرة أقل",
      "لأنها أسهل في التنفيذ"
    ],
    "correct": 1,
    "explanation": "في الأنظمة التي يجب أن تكون مضمونة الاستجابة في وقت محدد (مثل الأنظمة الطبية، التحكم في الطائرات)، لا يمكن المخاطرة بأسوأ حالة O(n²) لـ Quick Sort (حتى لو نادرة). Heap Sort تضمن أداء O(n log n) في جميع الحالات، مما يجعلها متوقعة وآمنة للاستخدام في مثل هذه السياقات."
  },
  {
    "question": "ما هو سبب تعيين `s = 0` في الفرع else من الشرط `if (s < i)` (السطر 70 تقريباً)؟",
    "options": [
      "لأن الابن المُختار (`s`) خارج حدود الكومة غير المرتبة (>= i)، لذا نريد كسر حلقة while",
      "لتهيئة s لقيمة جديدة",
      "لأنه لا يوجد أبناء",
      "لأن قيمة value غير معروفة"
    ],
    "correct": 0,
    "explanation": "الشرط `if (s < i)` يتحقق من أن الفهرس `s` (الذي يمثل أكبر ابن مرشح) لا يزال ضمن الجزء غير المرتب من المصفوفة (أقل من i). إذا كان `s >= i`، فهذا يعني أن كلا الابنين (أو الابن الوحيد) موجودان في المنطقة التي تم ترتيبها بالفعل (في نهاية المصفوفة). عندها، نكسر حلقة while عن طريق تعيين `s = 0`، لأننا دخلنا 'مرحلة الترتيب' ولا نريد المقارنة مع عناصر مرتبة."
  },
  {
    "question": "كيف تتعامل Heap Sort مع القيم المتساوية (التكرارات) من حيث الأداء؟",
    "options": [
      "تصبح أبطأ لأنها تسبب مزيداً من التبديلات",
      "تصبح أسرع لأن التبديلات تقل",
      "لا يتأثر الأداء بشكل كبير، يبقى O(n log n)",
      "تتوقف الخوارزمية"
    ],
    "correct": 2,
    "explanation": "وجود قيم متساوية لا يغير التعقيد الزمني المقارب. قد يقلل قليلاً من عدد التبديلات الداخلية لأن شرط المقارنة (`<` أو `>`) قد لا يتحقق في بعض الخطوات عند المساواة، ولكنه لا يغير الترتيب العام لـ O(n log n)."
  },
  {
    "question": "ما هو التحدي في محاولة جعل Heap Sort خوارزمية مستقرة (Stable)؟",
    "options": [
      "يمكن جعلها مستقرة بسهولة بإضافة فهرس ثانوي للمقارنة",
      "صعب جداً لأن عمليات التبديل بين الأب والأبناء البعيدة قد تفقد الاستقرار، والحفاظ عليه قد يتطلب ذاكرة إضافية أو يجعل الخوارزمية أبطأ",
      "لا يمكن أبداً لأنها تعتمد على الشجرة",
      "هي بالفعل مستقرة"
    ],
    "correct": 1,
    "explanation": "الاستقرار يعني أن العناصر المتساوية تحافظ على ترتيبها الأصلي. في Heap Sort، عندما تتبادل عقدة في الجذر مع آخر ورقة (وهي قد تكون بعيدة)، أو أثناء heapify-down، قد ينتهي عنصر متساوٍ قبل آخر كان بعده أصلاً. لجعلها مستقرة، قد نحتاج إلى إرفاق مؤشر ترتيب أصلية أو استخدام ذاكرة إضافية، مما يزيد التعقيد."
  }

                    
                 ],
                lec3: [
{ question: "في خوارزمية هوفمان، أين توضع الأحرف؟", 
   options: ["في العقد غير الورقية", "في الجذر فقط", "في الأوراق", "في الفروع"], 
   correct: 2,
   explanation: "الأحرف توضع في الأوراق فقط." },

 { question: "ما الهدف الأساسي من خوارزمية هوفمان؟", 
   options: ["ترتيب الأحرف", "ضغط البيانات بأقصر تمثيل ثنائي", "تشفير النص بكلمة سر", "بناء شجرة بحث"], 
   correct: 1,
   explanation: "الهدف هو ضغط البيانات بحيث يكون لكل حرف تمثيل ثنائي أقصر حسب تكراره." },

 { question: "في شجرة هوفمان، الحرف الأكثر تكراراً يكون:", 
   options: ["أبعد عن الجذر", "في المنتصف", "أقرب إلى الجذر", "ليس له علاقة"], 
   correct: 2,
   explanation: "الحروف الأكثر تكراراً توضع أقرب للجذر لتقصير طول الشيفرة." },

 { question: "عدد عقد شجرة هوفمان إذا كان عدد الأحرف n يساوي:", 
   options: ["n", "2n", "2n - 1", "n - 1"], 
   correct: 2,
   explanation: "شجرة هوفمان تحتوي على 2n-1 عقد إذا كان عدد الأحرف n." },

 { question: "لماذا لا يجوز أن تكون شيفرة حرف بداية لشيفرة حرف آخر؟", 
   options: ["لتقليل الذاكرة", "لمنع الغموض عند فك التشفير", "لتسريع البحث", "لأنه شرط شكلي"], 
   correct: 1,
   explanation: "لكي لا يكون هناك غموض عند فك الشيفرة." },


 // ============================
 // المرحلة 2: التكرار والاختيار
 // ============================

 { question: "في كل خطوة من بناء شجرة هوفمان نختار:", 
   options: ["أكبر تكرارين", "أصغر تكرارين غير مستخدمين", "أي عقدتين", "العقد الورقية فقط"], 
   correct: 1,
   explanation: "نختار أصغر عقدتين غير مستخدمتين لدمجهما." },

 { question: "إذا كانت التكرارات: a=5 , b=2 , c=1 , d=1 فما أول عقدتين يتم دمجهما؟", 
   options: ["a و b", "c و d", "a و c", "b و c"], 
   correct: 1,
   explanation: "أصغر تكرارين هما c و d، لذا ندمجهما أولاً." },

 { question: "تكرار العقدة الأب يساوي:", 
   options: ["أكبر تكرار بين الأبناء", "أصغر تكرار", "مجموع تكراري الابنين", "عدد العقد"], 
   correct: 2,
   explanation: "تكرار العقدة الأب يساوي مجموع تكراري الابنين." },

 { question: "العقد التي لها del = true هي:", 
   options: ["العقد المحذوفة", "العقد المستخدمة", "العقد المتاحة للاختيار", "العقد الجذر"], 
   correct: 2,
   explanation: "del = true تعني أن العقدة تم اختيارها أو مستخدمة." },

 { question: "بعد اختيار عقدة بواسطة findminfreq فإن del تصبح:", 
   options: ["true", "false", "null", "1"], 
   correct: 1,
   explanation: "بعد الاختيار تصبح del = false لتمييز أنها مستخدمة." },


 // ============================
 // المرحلة 3: التمثيل بالمصفوفة
 // ============================

 { question: "تمثيل شجرة هوفمان في البرنامج يتم باستخدام:", 
   options: ["مصفوفة عقد", "مصفوفة محارف", "Stack", "Queue"], 
   correct: 0,
   explanation: "يتم تمثيل الشجرة باستخدام مصفوفة العقد." },

 { question: "الحقل father في العقدة يشير إلى:", 
   options: ["عدد الأبناء", "تكرار الأب", "دليل العقدة الأب", "يمين أو يسار"], 
   correct: 2,
   explanation: "father يخزن فهرس العقدة الأب لكل عقدة." },

 { question: "الحقل isLeft يدل على:", 
   options: ["هل العقدة ورقة", "هل العقدة يسارية", "هل العقدة مستخدمة", "هل هي جذر"], 
   correct: 1,
   explanation: "isLeft يحدد إذا كانت العقدة الابنة يسارية أم لا." },

 { question: "الجذر في شجرة هوفمان يكون عند الفهرس:", 
   options: ["0", "n", "2n-2", "2n-1"], 
   correct: 2,
   explanation: "الجذر يكون عند الفهرس 2n-2 في تمثيل المصفوفة." },

 { question: "عدد العقد الورقية في شجرة هوفمان يساوي:", 
   options: ["n", "2n-1", "n-1", "2n"], 
   correct: 0,
   explanation: "عدد العقد الورقية يساوي عدد الأحرف n." },


 // ============================
 // المرحلة 4: الترميز (Code)
 // ============================

 { question: "عند الصعود من ابن يساري إلى الأب نضيف:", 
   options: ["1", "0", "لا شيء", "حسب التكرار"], 
   correct: 1,
   explanation: "نضيف 0 عند الصعود من ابن يساري." },

 { question: "عند الصعود من ابن يميني إلى الأب نضيف:", 
   options: ["0", "1", "حسب العمق", "لا شيء"], 
   correct: 1,
   explanation: "نضيف 1 عند الصعود من ابن يميني." },

 { question: "يتم توليد شيفرة الحرف بالتحرك من:", 
   options: ["الجذر إلى الورقة", "الورقة إلى الجذر", "اليمين إلى اليسار", "اليسار إلى اليمين"], 
   correct: 1,
   explanation: "نبدأ من الورقة إلى الجذر لتوليد الشيفرة." },

 { question: "تخزن الشيفرة في:", 
   options: ["node", "symbol", "CodeType", "alph"], 
   correct: 2,
   explanation: "الشيفرة تخزن في هيكل CodeType." },

 { question: "startPos في CodeType يدل على:", 
   options: ["عدد البتات", "بداية الشيفرة داخل المصفوفة", "نهاية الشيفرة", "طول الرسالة"], 
   correct: 1,
   explanation: "startPos يحدد بداية الشيفرة في مصفوفة البتات." },


 // ============================
 // المرحلة 5: خصائص الشيفرة
 // ============================

 { question: "شيفرة هوفمان هي:", 
   options: ["ثابتة الطول", "متغيرة الطول", "عشوائية", "ثلاثية"], 
   correct: 1,
   explanation: "شيفرة هوفمان متغيرة الطول حسب تكرار الحروف." },

 { question: "الأحرف الأقل تكراراً يكون لها:", 
   options: ["أقصر شيفرة", "أطول شيفرة", "نفس الطول", "بدون شيفرة"], 
   correct: 1,
   explanation: "الأحرف الأقل تكراراً لها أطول شيفرة." },

 { question: "إذا تغيرت التكرارات فإن:", 
   options: ["الشيفرة تبقى نفسها", "الشجرة تتغير", "الجذر فقط يتغير", "لا شيء يتغير"], 
   correct: 1,
   explanation: "تغيير التكرارات يغير الشجرة وبالتالي الشيفرة." },

 { question: "سبب أن شيفرة هوفمان تضغط البيانات هو:", 
   options: ["تستخدم 0 و 1 فقط", "تعطي الأقصر للأكثر تكراراً", "تلغي بعض الأحرف", "تعيد ترتيب النص"], 
   correct: 1,
   explanation: "الشيفرة تعطي رموز أقصر للحروف الأكثر تكراراً." },

 { question: "هل يمكن أن يكون حرفان لهما نفس الشيفرة؟", 
   options: ["نعم", "لا", "أحياناً", "حسب التكرار"], 
   correct: 1,
   explanation: "لا، كل حرف له شيفرة فريدة لتجنب الغموض." }
                ],
                lec4:[
 
                ]
            }
        },
        circuits: {
            name: "نظرية المخططات",
            lectures: {
                lec1: [
                 ]
            }
        }
    };

    let currentQuestion = 0;
    let userAnswers = [];
    let score = 0;
    let timer;
    let timeLeft = 20 * 60;
    let questions = [];

    // عناصر DOM
    const startScreen = document.getElementById('start-screen');
    const subjectScreen = document.getElementById('subject-screen');
    const lectureScreen = document.getElementById('lecture-screen');
    const examScreen = document.getElementById('exam-screen');
    const resultScreen = document.getElementById('result-screen');
    const startBtn = document.getElementById('start-btn');
    const timerDisplay = document.getElementById('timer');
    const currentQDisplay = document.getElementById('current-q');
    const scoreDisplay = document.getElementById('score');
    const questionText = document.getElementById('question-text');
    const optionsContainer = document.getElementById('options-container');
    const prevBtn = document.getElementById('prev-btn');
    const nextBtn = document.getElementById('next-btn');
    const submitBtn = document.getElementById('submit-btn');
    const correctSound = document.getElementById('correct-sound');
    const wrongSound = document.getElementById('wrong-sound');
    const correctCountDisplay = document.getElementById('correct-count');
    const wrongCountDisplay = document.getElementById('wrong-count');
    const skippedCountDisplay = document.getElementById('skipped-count');
    const finalScoreDisplay = document.getElementById('final-score');
    const answersReview = document.getElementById('answers-review');
    const restartBtn = document.getElementById('restart-btn');
    const homeBtn = document.getElementById('home-btn');
    const subjectList = document.getElementById('subject-list');
    const lectureList = document.getElementById('lecture-list');
    const lectureTitle = document.getElementById('lecture-title');
    const backSubjectsBtn = document.getElementById('back-subjects');

    // ===================== وظائف اختيار المادة والمحاضرة =====================
    function showSubjects() {
        subjectList.innerHTML = '';
        Object.keys(subjects).forEach(subKey => {
            const sub = subjects[subKey];
            const btn = document.createElement('button');
            btn.textContent = sub.name;
            btn.className = 'btn-subject';
            btn.addEventListener('click', () => showLectures(subKey));
            subjectList.appendChild(btn);
        });
        startScreen.classList.remove('active');
        subjectScreen.classList.add('active');
    }

   function showLectures(subKey) {
    const sub = subjects[subKey];
    lectureTitle.textContent = sub.name;
    lectureList.innerHTML = '';

    // زر الفحص الشامل لجميع المحاضرات
    const fullExamBtn = document.createElement('button');
    fullExamBtn.textContent = `فحص شامل لجميع المحاضرات`;
    fullExamBtn.className = 'btn-lecture';
    fullExamBtn.addEventListener('click', () => startFullExam(subKey));
    lectureList.appendChild(fullExamBtn);

    // عرض المحاضرات العادية
    Object.keys(sub.lectures).forEach(lecKey => {
        const btn = document.createElement('button');
        btn.textContent = `المحاضرة ${lecKey.replace('lec','')}`;
        btn.className = 'btn-lecture';
        btn.addEventListener('click', () => startLecture(subKey, lecKey));
        lectureList.appendChild(btn);
    });

    subjectScreen.classList.remove('active');
    lectureScreen.classList.add('active');
}

// وظيفة فحص شامل لجميع المحاضرات
function startFullExam(subKey) {
    const allLectures = subjects[subKey].lectures;
    let allQuestions = [];
    Object.values(allLectures).forEach(lec => {
        allQuestions = allQuestions.concat(lec);
    });

    questions = shuffleArray(allQuestions).slice(0, 20); // نأخذ 20 سؤال عشوائي
    userAnswers = new Array(questions.length).fill(-1);
    currentQuestion = 0;
    score = 0;
    timeLeft = 20 * 60;
    scoreDisplay.textContent = '0';
    timerDisplay.textContent = '20:00';
    timerDisplay.classList.remove('timer-warning', 'timer-danger');

    lectureScreen.classList.remove('active');
    examScreen.classList.add('active');
    startTimer();
    displayQuestion(0);
}


    backSubjectsBtn.addEventListener('click', () => {
        lectureScreen.classList.remove('active');
        subjectScreen.classList.add('active');
    });

    function startLecture(subKey, lecKey) {
        const allQuestions = subjects[subKey].lectures[lecKey];
        questions = shuffleArray(allQuestions).slice(0, 20);
        userAnswers = new Array(questions.length).fill(-1);
        currentQuestion = 0;
        score = 0;
        timeLeft = 20 * 60;
        scoreDisplay.textContent = '0';
        timerDisplay.textContent = '20:00';
        timerDisplay.classList.remove('timer-warning', 'timer-danger');

        lectureScreen.classList.remove('active');
        examScreen.classList.add('active');
        startTimer();
        displayQuestion(0);
    }

    function shuffleArray(array) {
        let arr = array.slice();
        for (let i = arr.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [arr[i], arr[j]] = [arr[j], arr[i]];
        }
        return arr;
    }

    // ===================== وظائف الاختبار =====================
    function startTimer() {
        clearInterval(timer);
        timer = setInterval(() => {
            timeLeft--;
            const minutes = Math.floor(timeLeft / 60);
            const seconds = timeLeft % 60;
            timerDisplay.textContent = `${minutes.toString().padStart(2,'0')}:${seconds.toString().padStart(2,'0')}`;
            if(timeLeft <= 60) timerDisplay.classList.add('timer-danger');
            else if(timeLeft <= 300) timerDisplay.classList.add('timer-warning');
            if(timeLeft <= 0){ clearInterval(timer); finishExam(); }
        },1000);
    }

    function displayQuestion(index){
        currentQuestion = index;
        const q = questions[index];
        currentQDisplay.textContent = index + 1;
        questionText.textContent = q.question;
        optionsContainer.innerHTML = '';
        q.options.forEach((opt,i)=>{
            const btn = document.createElement('button');
            btn.textContent = opt;
            btn.className = 'option-btn';
            if(userAnswers[index]===i) btn.classList.add('selected');
            btn.addEventListener('click', ()=> selectOption(i));
            optionsContainer.appendChild(btn);
        });
        prevBtn.disabled = index===0;
        nextBtn.disabled = index===questions.length-1;
    }

function selectOption(optionIndex) {
    // إذا الجواب موجود بالفعل ما في تعديل
    if (userAnswers[currentQuestion] !== -1) return;

    // حفظ الإجابة
    userAnswers[currentQuestion] = optionIndex;

    const options = document.querySelectorAll('.option-btn');

    const isCorrect = optionIndex === questions[currentQuestion].correct;

    options.forEach((btn, i) => {
        btn.classList.remove('selected');

        if (i === optionIndex) {
            btn.classList.add('selected');
        }

        // تلوين الإجابة الصحيحة والخاطئة
        if (i === questions[currentQuestion].correct) {
            btn.classList.add('correct-answer'); // أخضر
        } else if (i === optionIndex && !isCorrect) {
            btn.classList.add('wrong-answer'); // أحمر
        }

        // تعطيل الخيارات فقط، مش زر التالي
        btn.disabled = true;
    });

    // الأصوات
    if (isCorrect) {
        playSound('correct');
        score++;
        scoreDisplay.textContent = score;

        // انتقال تلقائي بعد نص ثانية
        setTimeout(() => {
            if (currentQuestion < questions.length - 1) {
                displayQuestion(currentQuestion + 1);
            } else {
                finishExam();
            }
        }, 500);
    } else {
        // إذا غلط، صوت خطأ، واللاعب يضغط "التالي" بنفسه
        playSound('wrong');
        nextBtn.disabled = false; // تأكد أن زر التالي مفعل
    }
}



    prevBtn.addEventListener('click', ()=> {
        if(currentQuestion>0) displayQuestion(currentQuestion-1);
    });

    nextBtn.addEventListener('click', ()=> {
        if(currentQuestion<questions.length-1) displayQuestion(currentQuestion+1);
    });

    submitBtn.addEventListener('click', ()=> {
        if(confirm("هل أنت متأكد من إنهاء الاختبار؟")) finishExam();
    });

    function finishExam(){
        clearInterval(timer);
        let correct=0,wrong=0,skipped=0;
        questions.forEach((q,i)=>{
            if(userAnswers[i]===-1) skipped++;
            else if(userAnswers[i]===q.correct) correct++;
            else wrong++;
        });
        const finalScore = Math.round((correct/questions.length)*100);
        correctCountDisplay.textContent = correct;
        wrongCountDisplay.textContent = wrong;
        skippedCountDisplay.textContent = skipped;
        finalScoreDisplay.textContent = finalScore+'%';
        answersReview.innerHTML = '';
        questions.forEach((q,i)=>{
            const div = document.createElement('div');
            div.className='answer-item';
            let status='skipped', statusText='غير مجاب', userAnswerText='لم تجب';
            if(userAnswers[i]!==-1){
                userAnswerText=q.options[userAnswers[i]];
                if(userAnswers[i]===q.correct){ status='correct'; statusText='صحيح'; }
                else { status='wrong'; statusText='خطأ'; }
            }
            div.classList.add(status);
            div.innerHTML = `<strong>سؤال ${i+1}:</strong> ${q.question}<br>
            إجابتك: ${userAnswerText}<br>
            الإجابة الصحيحة: ${q.options[q.correct]}<br>
            الحالة: ${statusText}<br>
            شرح: ${q.explanation}`;
            answersReview.appendChild(div);
        });

        examScreen.classList.remove('active');
        resultScreen.classList.add('active');

        if(finalScore>=70) playSound('correct'); else playSound('wrong');
    }

    restartBtn.addEventListener('click', ()=>{
        currentQuestion=0; userAnswers=[]; score=0; timeLeft=20*60;
        scoreDisplay.textContent='0'; timerDisplay.textContent='20:00';
        timerDisplay.classList.remove('timer-warning','timer-danger');
        resultScreen.classList.remove('active'); startScreen.classList.add('active');
    });

    homeBtn.addEventListener('click', ()=>{
        resultScreen.classList.remove('active'); startScreen.classList.add('active');
    });

    function playSound(type){
        if(type==='correct'){ correctSound.currentTime=0; correctSound.play(); }
        else if(type==='wrong'){ wrongSound.currentTime=0; wrongSound.play(); }
    }

    startBtn.addEventListener('click', showSubjects);
</script>
