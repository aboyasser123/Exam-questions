 
    // ===================== البيانات =====================
    const subjects = {
        algo2: {
            name: "خوارزميات 2",
            lectures: {
            
                lec2: [
{
    "question": "ما هو الهيكل الرئيسي الذي تعتمد عليه خوارزمية Heap Sort لتحقيق كفاءتها العالية؟",
    "options": [
      "قائمة مرتبطة",
      "كومة ثنائية (Binary Heap)",
      "شجرة بحث ثنائية",
      "مصفوفة مرتبة"
    ],
    "correct": 1,
    "explanation": "تعتمد Heap Sort على هيكل 'الكومة الثنائية' (Binary Heap) - وهي شجرة ثنائية كاملة تحقق خاصية الكومة (الأب أكبر من الأبناء في Max Heap). هذا الهيكل يسمح بالوصول للعنصر الأكبر في O(1) وتحديث الهيكل في O(log n)."
  },
  {
    "question": "في أي مرحلة من Heap Sort يتم ضمان أن أكبر عنصر يصبح في أول المصفوفة؟",
    "options": [
      "مرحلة بناء الكومة",
      "مرحلة الترتيب النهائي",
      "قبل البدء بالخوارزمية",
      "في كل تكرار من المرحلة الثانية"
    ],
    "correct": 0,
    "explanation": "في نهاية مرحلة بناء الكومة (المرحلة الأولى)، تكون المصفوفة ممثلة كـ Max Heap، وبالتالي يكون العنصر الأكبر في الجذر، وهو أول عنصر في المصفوفة (إذا اعتبرنا الفهرس يبدأ من 1)."
  },
  {
    "question": "إذا كانت المصفوفة تحتوي على 100 عنصر، فكم مرة تقريباً ستهبط العقدة من الجذر إلى مستوى الورقة في أسوأ حالة أثناء عملية heapify-down؟",
    "options": [
      "حوالي 7 مرات",
      "حوالي 100 مرة",
      "حوالي 50 مرة",
      "مرة واحدة فقط"
    ],
    "correct": 0,
    "explanation": "ارتفاع شجرة ثنائية كاملة تحتوي على 100 عقدة هو ⌊log₂(100)⌋ ≈ 7 مستويات. في أسوأ حالة، قد تهبط العقدة من الجذر (المستوى 1) إلى مستوى الورقة (المستوى 7)، أي حوالي 7 عمليات هبوط أو مقارنات."
  },
  {
    "question": "لماذا نقوم بتبديل العنصر الأخير مع الجذر في بداية كل تكرار من المرحلة الثانية (الترتيب)؟",
    "options": [
      "لجعل الكومة عشوائية",
      "لنتمكن من تقليص حجم الكومة الفعال",
      "لأن العنصر الأخير هو الأصغر دائماً",
      "لأن هذا شرط لإنهاء الخوارزمية"
    ],
    "correct": 1,
    "explanation": "نبدل الجذر (الأكبر) مع آخر عنصر في الكومة الحالية لنضع العنصر الأكبر في مكانه النهائي الصحيح (في نهاية المصفوفة المرتبة). ثم نقلص حجم الكومة الفعال بمقدار 1، ونعيد بناء الكومة على العناصر المتبقية."
  },
  {
    "question": "إذا بدأنا فهرسة المصفوفة من 1، وكانت العقدة الحالية في الفهرس i=10، فما هو الفهرس الذي يمثل أبويها؟",
    "options": ["5", "10", "20", "3"],
    "correct": 0,
    "explanation": "للعقدة i، أبويها يكون في الفهرس ⌊i/2⌋. ⌊10/2⌋ = 5."
  },
  {
    "question": "في كود بناء الكومة، ما هو الغرض من الحلقة التي تبدأ من i=2 حتى n؟",
    "options": [
      "لترتيب المصفوفة نهائياً",
      "لإدخال كل عنصر جديد في الكومة والحفاظ على خاصية الكومة",
      "لحذف العناصر المكررة",
      "لحساب حجم الكومة"
    ],
    "correct": 1,
    "explanation": "هذه الحلقة تقوم ببناء الكومة بشكل تصاعدي. تبدأ من العنصر الثاني (i=2) وتدخل كل عنصر جديد في الكومة الحالية، ثم ترفعه لأعلى (heapify-up) إذا لزم الأمر للحفاظ على خاصية الكومة (الأب أكبر من الأبناء)."
  },
  {
    "question": "ما هو الشرط الذي يحدد ما إذا كانت العقدة i تمثل ورقة في الشجرة الثنائية الكاملة؟",
    "options": [
      "إذا كان 2*i > n",
      "إذا كان i == 1",
      "إذا كان i/2 == 0",
      "إذا كان i < n"
    ],
    "correct": 0,
    "explanation": "العقدة i تكون ورقة إذا لم يكن لها أبناء، أي إذا كان الفهرس المحسوب لابنها الأيسر (2*i) أكبر من العدد الكلي للعقد n (يتجاوز حدود المصفوفة)."
  },
  {
    "question": "ما هو دور المتحول `elt` في كود بناء الكومة؟",
    "options": [
      "يخزن قيمة العقدة التي نريد إدراجها في الكومة مؤقتاً قبل أن نجد مكانها المناسب",
      "يخزن قيمة الجذر",
      "يخزن حجم المصفوفة",
      "يستخدم كفهرس مؤقت"
    ],
    "correct": 0,
    "explanation": "يستخدم `elt` لحفظ قيمة العنصر الجديد (الموجود في الموقع i) قبل أن نبدأ في رفعه لأعلى. هذا مهم لأنه أثناء رفعه، قد ننقل قيم الأباء للأسفل، وعندما نجد المكان المناسب، نضع قيمة `elt` فيه."
  },
  {
    "question": "ماذا يحدث إذا كانت خاصية الكومة (الأب أكبر من الأبناء) محققة بالفعل عند إدخال عنصر جديد أثناء البناء؟",
    "options": [
      "تدخل حلقة while وتقوم بالعديد من التبديلات",
      "لا تدخل حلقة while أبداً، ويتم وضع العنصر في مكانه الحالي مباشرة",
      "تتوقف الخوارزمية",
      "تحذف العنصر الجديد"
    ],
    "correct": 1,
    "explanation": "شرط حلقة while هو أن يكون الأب أصغر من العنصر الجديد (`x[f] < elt`). إذا كان الأب بالفعل أكبر أو مساوٍ، فإن الشرط يكون خطأ، ولا ندخل الحلقة، ونضع `elt` في موقعه الحالي (`x[s] = elt`)."
  },
  {
    "question": "في مرحلة الترتيب، لماذا نستخدم حلقة تنازلية من i=n إلى 2؟",
    "options": [
      "لأننا نريد وضع أكبر عناصر متبقية في نهاية المصفوفة واحدة تلو الأخرى",
      "لأن الفهرس 1 محجوز للجذر",
      "لجعل الكومة أصغر تدريجياً",
      "السببان 1 و 3 معاً"
    ],
    "correct": 3,
    "explanation": "نبدأ من i=n لأننا نريد وضع أكبر عنصر (الجذر) في آخر موقع (i). بعد وضعه، نقلص حجم الكومة الفعال بمقدار 1 (i--). ننتهي عند i=2 لأنه عندما يتبقى عنصر واحد فقط، فهو تلقائياً في مكانه الصحيح."
  },
  {
    "question": "في كود المرحلة الثانية، ما هو معنى `lValue = x[i]`؟",
    "options": [
      "أخذ قيمة آخر عنصر في الكومة الحالية لتخزينها مؤقتاً",
      "تعيين قيمة الجذر",
      "نسخ قيمة أصغر عنصر",
      "حذف العنصر الأخير"
    ],
    "correct": 0,
    "explanation": "هذه الخطوة تحفظ قيمة العنصر الموجود في آخر موضع في الكومة الحالية (الموقف i). لاحقاً سنضع الجذر (الأكبر) في هذا الموضع، ونحاول إدراج `lValue` في مكان مناسب داخل الكومة المتبقية."
  },
  {
    "question": "ما هو الهدف من حلقة while الداخلية في مرحلة الترتيب؟",
    "options": [
      "لرفع قيمة صغيرة لأعلى في الكومة",
      "لهبوط بقيمة `lValue` لأعماق الكومة حتى تجد مكانها المناسب",
      "لترتيب المصفوفة بسرعة",
      "لحساب عدد العناصر"
    ],
    "correct": 1,
    "explanation": "هدفها هو استعادة خاصية الكومة بعد وضع `lValue` (الذي كان في آخر موضع) في الجذر. نقارن `lValue` مع أكبر أبناء العقدة الحالية (`value`). إذا كان `lValue` أصغر، ندفع الابن الكبير لأعلى، ونهبط بـ `lValue` للأسفل. نستمر حتى يصبح `lValue` أكبر من أبنائه، أو نصبح في منطقة مرتبة."
  },
  {
    "question": "لماذا نتحقق من الشرط `if (s+1 <= i-1)` داخل حلقة while في مرحلة الترتيب؟",
    "options": [
      "للتأكد من وجود أخ أيمن للعقدة الحالية ضمن نطاق الكومة غير المرتبة",
      "للتأكد من أن الفهرس لا يتجاوز n",
      "لمعرفة إذا كانت العقدة ورقة",
      "لحساب عدد الإخوة"
    ],
    "correct": 0,
    "explanation": "العقدة الحالية لها ابن أيسر في `s = 2*f`. هذا الشرط يتحقق مما إذا كان لها أيضاً ابن أيمن، وذلك عن طريق التحقق من أن `s+1` (فهرس الابن الأيمن) أقل من أو يساوي `i-1` (آخر فهرس في الكومة غير المرتبة). إذا وجد، نقارن بين الابن الأيسر والأيمن لاختيار الأكبر."
  },
  {
    "question": "ماذا يعني تعيين `s = 0` داخل شروط if في مرحلة الترتيب؟",
    "options": [
      "لتهيئة الفهرس لبداية جديدة",
      "كعلامة (flag) لكسر حلقة while الداخلية لاحقاً",
      "لحذف العنصر الحالي",
      "للدلالة على أننا وصلنا للجذر"
    ],
    "correct": 1,
    "explanation": "عندما نكون في حالة يجب فيها الخروج من حلقة while (مثل دخول منطقة مرتبة أو عدم وجود أبناء للمقارنة)، نعين `s = 0`. شرط استمرار حلقة while غالباً ما يكون `(s > 0) && ...`، لذا فإن `s = 0` سيكسر الحلقة."
  },
  {
    "question": "إذا كانت المصفوفة [3, 5, 1, 4, 2]، فما هي حالتها بعد مرحلة بناء الكومة (Max Heap)؟",
    "options": [
      "[5, 4, 1, 3, 2]",
      "[1, 2, 3, 4, 5]",
      "[2, 3, 1, 5, 4]",
      "[5, 3, 4, 1, 2]"
    ],
    "correct": 0,
    "explanation": "بعد بناء Max Heap، يجب أن يكون الجذر (الموقع 1) هو الأكبر (5). وكل أب أكبر من أبنائه. الشجرة: الجذر 5، أبناؤه 4 و1، ابن 4 هو 3 و2. المصفوفة: [5, 4, 1, 3, 2] (بافتراض الفهرس 1)."
  },
  {
    "question": "ما هو التعقيد الزمني الإجمالي لـ Heap Sort؟ ولماذا؟",
    "options": [
      "O(n) لأنها تمر على العناصر مرة واحدة",
      "O(n log n) لأن بناء الكومة O(n) وكل من عمليات n-1 استخراج تحتاج O(log n)",
      "O(n²) لأنها تحتوي على حلقتين متداخلتين",
      "O(log n) لأنها تعمل على شجرة"
    ],
    "correct": 1,
    "explanation": "البناء: O(n). ثم ننفذ عملية استخراج وإعادة بناء (heapify-down) لـ n-1 عنصر. كل عملية heapify-down في أسوأ الحالات هي O(log n). الإجمالي: O(n) + (n-1)*O(log n) = O(n log n)."
  },
  {
    "question": "هل يمكن استخدام بنية الكومة (Heap) لأغراض أخرى غير الفرز؟",
    "options": [
      "لا، صممت للفرز فقط",
      "نعم، مثل تنفيذ قائمة انتظار ذات أولوية (Priority Queue)",
      "نعم، لحل مسائل البحث فقط",
      "نعم، لضغط البيانات"
    ],
    "correct": 1,
    "explanation": "بنية الكومة هي أساس هيكل بيانات 'قائمة الانتظار ذات الأولوية' (Priority Queue)، حيث يمكن إدراج عناصر بأولويات واستخراج العنصر ذي الأولوية القصوى (أو الدنيا) بكفاءة."
  },
  {
    "question": "إذا كان لديك كومة عظمى (Max Heap) تحتوي على العناصر [50, 30, 20, 15, 10, 8, 16]، وقمت باستخراج العنصر الأكبر (50) وأعدت بناء الكومة، ما هي العناصر الجديدة في الكومة؟",
    "options": [
      "[30, 20, 16, 15, 10, 8]",
      "[30, 16, 20, 15, 10, 8]",
      "[30, 15, 20, 8, 10, 16]",
      "[16, 30, 20, 15, 10, 8]"
    ],
    "correct": 1,
    "explanation": "بعد استخراج 50، نضع آخر عنصر (16) في الجذر. ثم ننفذ heapify-down: 16 < max(30,20) → نبدل 16 مع 30 (الأكبر). 16 < max(15,10) → نبدل 16 مع 15 (توقف لأن 15 و10 أصغر من 16). النتيجة: [30, 16, 20, 15, 10, 8]."
  },
  {
    "question": "ما هو الشرط الذي يجعل حلقة while في مرحلة الترتيب تتوقف بسبب 'دخول مرحلة الترتيب'؟",
    "options": [
      "عندما يكون `lValue` أكبر من جميع الأبناء",
      "عندما لا يكون للعقدة الحالية أبناء ضمن نطاق الكومة غير المرتبة (s >= i)",
      "عندما نصل إلى الجذر",
      "عندما تكون المصفوفة مرتبة"
    ],
    "correct": 1,
    "explanation": "عندما نصل إلى عقدة يكون أبناؤها (s = 2*f) خارج نطاق الكومة التي لم نرتبها بعد (أي s >= i)، فهذا يعني أننا في المنطقة التي تم ترتيبها بالفعل (العناصر الكبيرة في النهاية). عندها نكسر الحلقة ونضع `lValue` في العقدة الفارغة الحالية."
  },
  {
    "question": "لماذا تعتبر Heap Sort خوارزمية 'غير مستقرة' (Unstable)؟",
    "options": [
      "لأنها قد تغير الترتيب النسبي للعناصر المتساوية في القيمة",
      "لأنها تستخدم ذاكرة إضافية",
      "لأن تعقيدها الزمني غير ثابت",
      "لأنها لا تعمل على المصفوفات"
    ],
    "correct": 0,
    "explanation": "خلال عمليات التبديل التي تحدث أثناء بناء الكومة أو heapify-down، قد ينتهي بأحد العناصر المتساوية في القيمة قبل الآخر في المصفوفة النهائية، على الرغم من أنه كان بعده في المصفوفة الأصلية. لذا لا تحافظ على الاستقرار."
  },
                     {
    "question": "ما هو الاختلاف الرئيسي بين طريقة بناء الكومة من أسفل إلى أعلى (Bottom-up) مقابل الطريقة المستخدمة في المحاضرة (من أعلى إلى أسفل بالإدراج المتتالي)؟",
    "options": [
      "الطريقة Bottom-up أسرع وتعقيدها O(n)، بينما الطريقة في المحاضرة O(n log n)",
      "لا يوجد اختلاف، كلتاهما O(n log n)",
      "الطريقة في المحاضرة أسرع لأنها أبسط",
      "الطريقة Bottom-up لا تعمل مع Max Heap"
    ],
    "correct": 0,
    "explanation": "الطريقة Bottom-up (تبدأ من العقد غير الورقية وتنفذ heapify-down عليها) لها تعقيد خطي O(n) أثباتاً رياضياً. الطريقة في المحاضرة (إدراج عناصر واحدا تلو الآخر ورفعها heapify-up) لها تعقيد O(n log n) ولكنها أبسط في الفهم والتنفيذ."
  },
  {
    "question": "في سياق خوارزمية Heap Sort، ماذا يعني أن الكومة تكون 'مشروطة جزئياً' (Partial Order)؟",
    "options": [
      "أن العناصر مرتبة ترتيباً كاملاً تصاعدياً",
      "أن العلاقة بين الأب وأبنائه محفوظة، ولكن ليس بالضرورة بين الإخوة أو بين عمودين مختلفين",
      "أن الكومة فارغة جزئياً",
      "أن بعض العنوانات مفقودة"
    ],
    "correct": 1,
    "explanation": "خاصية الكومة تضعل فقط أن كل أب أكبر من (أو يساوي) أبنائه المباشرين. لا تضعل شيئاً عن العلاقة بين الأخوة (اليسار واليمين) أو بين ابن وعمه. هذا يخلق ترتيباً جزئياً وليس كاملاً، لكنه كافٍ لضمان أن الجذر هو الأكبر."
  },
  {
    "question": "إذا كان لدينا مصفوفة حجمها n=16، ما هو عدد العقد غير الورقية فيها؟",
    "options": ["8", "7", "15", "9"],
    "correct": 0,
    "explanation": "في شجرة ثنائية كاملة، عدد العقد غير الورقية = ⌊n/2⌋. ⌊16/2⌋ = 8. هذه العقد تبدأ من الفهرس 1 إلى 8."
  },
  {
    "question": "خلال عملية heapify-down، كيف نختار الابن الذي نبدل معه الأب إذا كان الأب أصغر من كلا الابنين؟",
    "options": [
      "نبدل مع الابن الأيسر دائماً",
      "نبدل مع الابن الأيمن دائماً",
      "نبدل مع الابن الأكبر منهما",
      "نبدل مع أي ابن عشوائياً"
    ],
    "correct": 2,
    "explanation": "نقارن بين الابن الأيسر والأيمن (إذا كانا موجودين) ونختار الأكبر. ثم نقارن هذا الابن الأكبر مع الأب. إذا كان الابن أكبر، نبدل. هذا يحافظ على خاصية الكومة (الأب أكبر من كلا الابنين بعد التبديل)."
  },
  {
    "question": "ما هو الخطأ المنطقي الذي سيحدث إذا استخدمنا شرط `while (s > 1 && x[f] <= elt)` بدلاً من `<` في كود البناء؟",
    "options": [
      "سيؤدي إلى دخول لا نهائي إذا كان الأب مساوياً للابن",
      "سيتوقف مبكراً جداً",
      "سيجعل الخوارزمية أسرع",
      "لن يؤثر لأن المساواة مقبولة"
    ],
    "correct": 0,
    "explanation": "إذا كان الأب مساوياً للابن (`x[f] == elt`)، فباستخدام `<=` سيكون الشرط صحيحاً، وسنستمر في رفع الابن حتى الجذر مع أنهما متساويان، مما قد يؤدي إلى تكرار لا نهائي إذا لم نحدّث المؤشرات بشكل صحيح. الأصح هو `<` فقط، لأن المساواة تحقق خاصية الكومة (الأب >= الأبناء)."
  },
  {
    "question": "لماذا في مرحلة الترتيب نحتاج إلى متحولين `lValue` و `value`؟ لماذا لا نستخدم `elt` فقط؟",
    "options": [
      "لأن `elt` مستخدم في المرحلة الأولى فقط",
      "لأن `lValue` هو العنصر المنقول من النهاية، و`value` هو أكبر أبناء العقدة الفارغة أثناء الهبوط",
      "لجعل الكود أطول",
      "لا يوجد سبب، يمكن استخدام `elt`"
    ],
    "correct": 1,
    "explanation": "`lValue` يحفظ قيمة العنصر الذي أخذناه من آخر موضع (x[i]) والذي نريد إيجاد مكان له. `value` يحفظ قيمة أكبر ابن للعقدة الفارغة الحالية (f) أثناء هبوطنا لأسفل. هذان دوران مختلفان. استخدام متحول واحد قد يسبب كتابة فوق القيم قبل الأوان."
  },
  {
    "question": "إذا أردنا فرز المصفوفة تنازلياً (من الأكبر إلى الأصغر) باستخدام Heap Sort، ما هو التغيير البسيط الذي يمكن إجراؤه؟",
    "options": [
      "استخدام Min Heap بدلاً من Max Heap",
      "عكس اتجاه الحلقة النهائية",
      "تغيير جميع علامات المقارنة",
      "الإجابة 1 و 2 معاً"
    ],
    "correct": 0,
    "explanation": "للفرز تنازلياً، نبني Min Heap (حيث الأب أصغر من الأبناء). عندها سيكون العنصر الأصغر في الجذر. في مرحلة الترتيب، نستخرج الأصغر ونضعه في البداية (أو في النهاية ثم نعكس). العمليات المتبقية تبقى كما هي."
  },
  {
    "question": "ما هو الوضع الأمثل (Best Case) لمدخلات Heap Sort؟ وما هو تعقيده الزمني في هذه الحالة؟",
    "options": [
      "مصفوفة مرتبة تصاعدياً، O(n)",
      "مصفوفة مرتبة تنازلياً، O(n log n)",
      "مصفوفة عشوائية، O(n log n)",
      "لا يوجد وضع أمثل، التعقيد دائماً O(n log n)"
    ],
    "correct": 3,
    "explanation": "Heap Sort ليس لديها حالة أفضل مختلفة بشكل كبير. حتى لو كانت المصفوفة مرتبة بالفعل، فإن بناء الكومة لا يزال يتطلب O(n) في أفضل التقنيات، وكل عملية heapify-down في مرحلة الترتيب قد تستغرق O(log n). التعقيد يبقى Θ(n log n) في جميع الحالات."
  },
  {
    "question": "ماذا سيكون تأثير خطأ برمجي جعلنا نبدأ الحلقة التنازلية من i=n إلى 1 (بدلاً من إلى 2)؟",
    "options": [
      "سيفرز العنصر الأخير مرتين",
      "عند i=1، سنحاول وضع الجذر في مكانه وهو مكانه بالفعل، وقد يسبب خطأ أو تبديل غير ضروري",
      "سيجعل الخوارزمية أسرع",
      "لن يتغير شيء"
    ],
    "correct": 1,
    "explanation": "عندما i=1، سيكون حجم الكومة المتبقية عنصراً واحداً. عملية أخذ الجذر ووضعه في المكان i=1 هي نفس المكان. الكود قد يحاول عمل مقارنات وتبديلات غير ضرورية مع عناصر خارج الحدود أو يدخل في حلقة لا نهائية إذا لم يكن محمياً بشروط مناسبة."
  },
  {
    "question": "كيف يمكنك تعديل خوارزمية Heap Sort لترتيب مصفوفة من السجلات (Records) بناءً على حقل معين (مثل العمر)؟",
    "options": [
      "لا يمكن، تعمل فقط على الأرقام",
      "نقوم بمقارنة القيمة الموجودة في الحقل المطلوب أثناء جميع عمليات المقارنة في الخوارزمية",
      "نحول كل سجل إلى رقم",
      "نستخدم مصفوفة منفصلة للفهارس"
    ],
    "correct": 1,
    "explanation": "نغير دوال المقارنة فقط. بدلاً من مقارنة `x[f] < elt`، نقارن `x[f].age < elt.age` (إذا كان الحقل اسمه age). باقي الخوارزمية يبقى كما هو (تبديل السجلات كاملة، إلخ). هذا يجعلها خوارزمية فرز عامة قابلة للتخصيص."
  },
  {
    "question": "ما هو الغرض من التعديل `f = s/2` داخل حلقة while في مرحلة البناء؟",
    "options": [
      "لتحريك المؤشر f (الأب) إلى مستوى أعلى (أقرب إلى الجذر) في التكرار التالي",
      "لتحريك المؤشر للأسفل",
      "لحساب الابن الجديد",
      "لتهيئة f بقيمة جديدة"
    ],
    "correct": 0,
    "explanation": "بعد أن ننقل قيمة الأب للأسفل (`x[s] = x[f]`)، نريد في التكرار التالي مقارنة `elt` مع الأب الجديد (أب الأب السابق). لذلك نحرك المؤشر s إلى مكان الأب القديم (`s = f`)، ثم نحسب أبه الجديد: `f = s/2`. وهكذا نصعد في الشجرة."
  },
  {
    "question": "لماذا في بعض تطبيقات Heap Sort، تتم تهيئة الحلقة الأولى من i = n/2 إلى 1 (تنازلياً)؟",
    "options": [
      "لأن هذا هو بناء الكومة بطريقة Bottom-up الأكثر كفاءة",
      "لأنه يبدأ من الأوراق",
      "لأنه أسهل في الكتابة",
      "لا يوجد سبب، هو نفس الشيء"
    ],
    "correct": 0,
    "explanation": "هذه هي الطريقة الأمثل لبناء الكومة (تعقيد O(n)). نبدأ من آخر عقدة غير ورقية (n/2) وننفذ heapify-down عليها، ثم ننتقل للعقدة التي قبلها، وهكذا حتى الجذر. هذا يستفيد من حقيقة أن الأشجار الفرعية الصغيرة هي بالفعل كومات."
  },
  {
    "question": "إذا قمت بتشغيل Heap Sort على مصفوفة [1,2,3,4,5,6,7]، فكم عدد التبديلات الإضافية التي ستحدث مقارنة لو كانت المصفوفة مرتبة تنازلياً [7,6,5,4,3,2,1]؟",
    "options": [
      "سيكون هناك تبديلات أكثر في الحالة الأولى",
      "سيكون هناك تبديلات أقل في الحالة الأولى",
      "سيكون العدد متساوياً تقريباً",
      "لا يمكن معرفة"
    ],
    "correct": 1,
    "explanation": "عندما تكون المصفوفة مرتبة تصاعدياً (وأردنا ترتيبها تصاعدياً أيضاً)، فإن بناء Max Heap سيتطلب رفع كل عنصر صغير من أسفل الشجرة إلى مكانه الصحيح أعلى، مما يتطلب الكثير من التبديلات. بينما إذا كانت المصفوفة مرتبة تنازلياً، فهي قريبة من Max Heap بالفعل (الجذر هو الأكبر)، وسيتطلب بناء الكومة تبديلات أقل. بشكل عام، حالة الترتيب التصاعدي هي من أسوأ الحالات لبناء الكومة."
  },
  {
    "question": "ما هو التحدي الرئيسي في تنفيذ Heap Sort باستخدام فهرسة تبدأ من 0؟",
    "options": [
      "معادلات حساب الأب والأبناء تتغير",
      "لا يمكن تنفيذها",
      "الخوارزمية تصبح أبطأ",
      "يجب إضافة عنصر وهمي في البداية"
    ],
    "correct": 0,
    "explanation": "المعادلات تتغير: الأب لـ i يصبح (i-1)/2، الابن الأيسر يصبح 2*i+1، الابن الأيمن 2*i+2. يجب تعديل كل الشروط التي تستخدم هذه الحسابات في الكود، وأيضاً شروط التوقف مثل `s > 1` تصبح `s > 0` أو ما شابه."
  },
  {
    "question": "في نهاية مرحلة الترتيب، عندما i=2، لماذا نعتبر أن الفرز اكتمل؟",
    "options": [
      "لأن العنصرين المتبقيين (في الفهرس 1 و 2) سيتم ترتيبهم تلقائياً بتبديل بسيط",
      "لأنه لم يتبق سوى عنصر واحد",
      "لأن الحلقة تنتهي عند i=2",
      "لأن الكومة تختفي"
    ],
    "correct": 0,
    "explanation": "عندما i=2، حجم الكومة غير المرتبة هو عنصرين (في الفهرس 1 و 2). في Max Heap، العنصر في الفهرس 1 (الجذر) هو الأكبر بينهما. عملية التبديل (`x[2] = x[1]`) ثم إدراج `lValue` في الجذر ستؤدي إلى أن يصبح العنصر الأكبر في الفهرس 2، والأصغر في الفهرس 1. وهكذا اكتمل الترتيب."
  },
  {
    "question": "ما هو دور الشرط `if (s > 1)` داخل حلقة while في كود البناء (السطور 20-25 في الكود المعطى)؟",
    "options": [
      "للتأكد من أننا لم نصل إلى الجذر بعد قبل حساب أب جديد",
      "لحساب الأب بطريقة مختلفة إذا وصلنا للجذر",
      "لمنع القسمة على صفر",
      "الإجابتان 1 و 2"
    ],
    "correct": 3,
    "explanation": "عندما نصعد ونجد أن `s` أصبحت 1 (أي وصلنا للجذر)، فإن حساب `f = s/2` سيكون 0 (إذا كانت القسمة صحيحة). الفهرس 0 غير صالح (إذا بدأنا من 1). لذلك، نتحقق: إذا `s > 1` نحسب الأب، وإلا (s=1) نضع `f = 1` أو نخرج من الحلقة. في الكود المعطى، يضع `f = 1`، لكن هذا قد يسبب مشكلة لأن حلقة while ستحاول المقارنة مع `x[1]` مجدداً وقد تدور لا نهائياً إذا لم ينكسر شرط آخر (`x[f] < elt`)."
  },
  {
    "question": "إذا كان لدينا كومة عظمى تحتوي على أعداد مكررة، فهل يمكن أن يكون هناك أكثر من كومة عظمى صحيحة تمثل نفس المصفوفة؟",
    "options": [
      "لا، الكومة العظمى فريدة لمصفوفة معينة",
      "نعم، لأن الإخوة يمكن تبديلهم مع الحفاظ على خاصية الكومة",
      "فقط إذا كانت المصفوفة مرتبة",
      "فقط إذا كانت الأعداد كلها متساوية"
    ],
    "correct": 1,
    "explanation": "خاصية الكومة لا تحدد ترتيب الإخوة (الابن الأيسر واليمين). إذا كان لديك أب بقيم أبناء متساوية، يمكن تبديل مواقع الأبناء ولا تزال الخاصية محققة. لذا قد يكون هناك تمثيلات شجرية مختلفة لنفس المصفوفة كـ Max Heap."
  },
  {
    "question": "كيف تؤثر خاصية 'الشجرة الثنائية الكاملة' على كفاءة خوارزمية Heap Sort؟",
    "options": [
      "تضمن أن ارتفاع الشجرة هو ⌊log n⌋، مما يحافظ على تعقيد O(log n) لعمليات الرفع والهبوط",
      "تزيد من التعقيد لأنها تفرض هيكلاً صارماً",
      "تسمح باستخدام مصفوفة بدلاً من مؤشرات، مما يوفر ذاكرة",
      "الإجابتان 1 و 3"
    ],
    "correct": 3,
    "explanation": "1) الشكل الكامل يضمن أن الشجرة مضغوطة وارتفاعها لوغاريتمي، وهذا أساس لضمان أن heapify-up و heapify-down هما O(log n). 2) لأنه شكل كامل، يمكن تمثيله بمصفوفة بسيطة دون الحاجة لمؤشرات (left/right)، باستخدام معادلات حسابية للعلاقات، مما يوفر الذاكرة ويبسط التنفيذ."
  },
  {
    "question": "ما هو الموقف الذي قد تختار فيه Quick Sort على Heap Sort رغم أن تعقيد أسوأ حالة لـ Quick Sort هو O(n²)؟",
    "options": [
      "عندما تكون البيانات كبيرة جداً وتريد أسوأ حالة مضمونة",
      "عندما يكون الذاكرة محدودة للغاية",
      "عندما تكون بياناتك عشوائية وتريد أسرع أداء عملي في المتوسط",
      "عندما تحتاج فرز مستقر (Stable Sort)"
    ],
    "correct": 2,
    "explanation": "في الممارسة العملية، على بيانات عشوائية، Quick Sort أسرع من Heap Sort بسبب ثوابت التنفيذ الأصغر وتوافقها مع ذاكرة التخزين المؤقت. ومع أن أسوأ حالة Quick Sort هي O(n²)، إلا أن هذا نادر مع اختيار محور (pivot) جيد. لذا للبيانات العامة، يفضل Quick Sort للسرعة."
  },
  {
    "question": "خلال عملية heapify-down في مرحلة الترتيب، ماذا يحدث إذا كان للعقدة الحالية ابن واحد فقط (يساري)؟",
    "options": [
      "نقارن معه مباشرة لأنه الابن الوحيد",
      "نبحث عن ابن أيمن ونجد أنه غير موجود، فنخرج",
      "نعتبر أن العقدة ورقة",
      "نستخدم قيمة افتراضية للابن الأيمن"
    ],
    "correct": 0,
    "explanation": "نحسب `s = 2*f` (الابن الأيسر). ثم نتحقق مما إذا كان له ابن أيمن (`s+1 <= i-1`). إذا لم يكن له (أي s+1 > i-1)، فإن `s` يمثل الابن الوحيد (الأيسر). نقارن `lValue` مع `x[s]` مباشرة. لا داعي لمقارنة الإخوة."
  },
  {
    "question": "ما هو معنى القيمة التي نخرج بها من حلقة while في مرحلة الترتيب (القيمة التي نضعها في `s` لنكسر الحلقة)؟",
    "options": [
      "فهرس العقدة الفارغة النهائية التي يجب وضع `lValue` فيها",
      "فهرس أكبر ابن",
      "القيمة صفر فقط للإشارة",
      "فهرس الجذر الجديد"
    ],
    "correct": 0,
    "explanation": "نحن نهبط بـ `lValue` للأسفل. في كل خطوة، ننقل أكبر ابن (`value`) لأعلى إلى العقدة الفارغة (`f`). ثم نجعل العقدة الفارغة الجديدة هي مكان ذلك الابن (`f = s`). نستمر حتى نتوقف. الفهرس `s` النهائي (قبل تعيينه 0) أو الفهرس `f` هو موقع العقدة الفارغة الذي يجب أن نضع فيه `lValue` (`x[f] = lValue`)."
  },
  {
    "question": "لماذا يتم تنفيذ `x[i] = x[1]` في بداية كل تكرار من المرحلة الثانية؟",
    "options": [
      "لنسخ قيمة الجذر (الأكبر) إلى نهاية الكومة الحالية، وهو مكانه النهائي المرتب",
      "لحذف قيمة الجذر",
      "لتهيئة `x[i]`",
      "لجعل `x[1]` فارغاً"
    ],
    "correct": 0,
    "explanation": "هذا هو جوهر عملية الاستخراج. العنصر الأكبر في الكومة غير المرتبة موجود في الجذر `x[1]`. مكانه النهائي في المصفوفة المرتبة هو الموضع الأخير من الجزء غير المرتب (`i`). لذلك ننقله إلى هناك."
  },
  {
    "question": "في الكود المعطى، ما هو دور المقطع التالي؟\n`if (i == 2) { s = 0; } else { s = 2; }`",
    "options": [
      "تهيئة بدائية لمؤشر الابن عند بدء عملية الهبوط لـ `lValue`، مع معالجة خاصة عندما يكون حجم الكومة 2",
      "كسر الحلقة فوراً عندما i==2",
      "تعيين الابن الأيسر للجذر مباشرة",
      "خطأ برمجي محتمل"
    ],
    "correct": 0,
    "explanation": "هذا المقطع يبدو أنه جزء من تهيئة بدء عملية البحث عن أكبر ابن للجذر (العقدة 1) بعد وضع `lValue` فيه. عادة أكبر أبناء الجذر هما العقدة 2 و3. عندما i==2 (أي بقي عنصران فقط)، فإن العقدة 3 خارج الحدود (i-1 =1). لذا، نعين s=0 ربما للإشارة إلى أنه لا يوجد ابن للمقارنة (أو الابن الوحيد هو 2). التهيئة s=2 في الحالة الأخرى تفترض أن الابن الأيسر (2) هو المرشح الابتدائي، وسيتم تعديله لاحقاً إذا كان الابن الأيمن (3) أكبر وأيضاً ضمن الحدود."
  },
  {
    "question": "ما هو العيب الأساسي الذي يمنع Heap Sort من أن تكون الخيار الأول غالباً في المكتبات القياسية للفرز؟",
    "options": [
      "تعقيد الذاكرة الإضافي",
      "عدم الاستقرار (Unstable)",
      "الثوابت العالية التي تجعلها أبطأ عملياً من خوارزميات مثل Quick Sort أو Merge Sort في كثير من الحالات",
      "تعقيد التنفيذ"
    ],
    "correct": 2,
    "explanation": "رغم أن لها تعقيداً زمنياً جيداً O(n log n) وتعمل في المكان، إلا أن عدد العمليات والمقارنات فيها (الثوابت) أعلى من منافسيها. Quick Sort أسرع عملياً في المتوسط، و Merge Sort مستقر ويعطي أداءً متوقعاً. لذا تستخدم Heap Sort في سياقات محددة (مثل أنظمة الوقت الحقيقي حيث أسوأ حالة O(n log n) مهم، أو عند قيود الذاكرة)."
  },
  {
    "question": "إذا قمت بتشغيل Heap Sort على مصفوفة مكونة من عنصر واحد فقط، فكم عدد المرات التي ستدخل فيها الحلقة الرئيسية للبناء؟",
    "options": ["0", "1", "2", "تعتمد على قيمة العنصر"],
    "correct": 0,
    "explanation": "حلقة البناء تبدأ من i=2 إلى n. إذا كان n=1، فإن نطاق الحلقة (2..1) فارغ، ولن تنفذ أي تكرار. الخوارزمية ستعتبر المصفوفة المرتبة من عنصر واحد بمثابة كومة صحيحة (و ترتيبها مكتمل)."
  },
  {
    "question": "ما الفرق بين 'رفع' عنصر (heapify-up) و 'هبوط' عنصر (heapify-down)؟ ومتى نستخدم كل منها؟",
    "options": [
      "الرفع: عند إدخال عنصر جديد في نهاية الكومة. الهبوط: عند استخراج الجذر أو تخفيض قيمة جذر.",
      "الرفع: عند استخراج الجذر. الهبوط: عند إدخال عنصر جديد.",
      "كلاهما نفس الشيء",
      "الرفع: لبناء الكومة. الهبوط: لتفكيكها."
    ],
    "correct": 0,
    "explanation": "الرفع (Heapify-up / Sift-up): نستخدمه عندما نضيف عنصراً في نهاية الكومة (أو نزيد قيمة عقدة). نقارنه مع أبيه ونسحبه لأعلى إذا كان أكبر (في Max Heap). الهبوط (Heapify-down / Sift-down): نستخدمه عندما نستبدل الجذر بقيمة أصغر (مثل بعد استخراج العنصر الأكبر، نضع آخر عنصر في الجذر). نقارنه مع أكبر أبنائه وندفعه للأسفل."
  },
  {
    "question": "كيف يمكنك تعديل Heap Sort لفرز أول k من أكبر العناصر فقط (بدلاً من كل العناصر)؟",
    "options": [
      "ننفذ مرحلة البناء كاملة، ثم نستخرج الجذر k مرات فقط",
      "نفرز الكل ثم نأخذ أول k عنصر",
      "لا يمكن",
      "نبني كومة صغيرة حجم k فقط"
    ],
    "correct": 0,
    "explanation": "هذا أحد الاستخدامات العملية للكومة. نبني Max Heap (O(n)). ثم نستخرج الجذر (الأكبر) ونعيد بناء الكومة (O(log n)). نكرر هذه العملية k مرات. التعقيد الكلي: O(n + k log n). إذا كان k صغيراً مقارنة بـ n، فهذا فعال جداً."
  },
  {
    "question": "في التمثيل بالمصفوفة، لماذا من المهم أن تكون الشجرة 'ممتلئة من اليسار' (Left-complete)؟",
    "options": [
      "لضمان عدم وجود فراغات في منتصف المصفوفة، وبالتالي استخدام الذاكرة بكفاءة",
      "لجعل الشجرة أسرع في البحث",
      "لجعل العلاقات بين الأب والابن تعمل دائماً بنفس المعادلات",
      "الإجابتان 1 و 3"
    ],
    "correct": 3,
    "explanation": "1) الشكل الممتلئ من اليسار يعني أننا نملأ المصفوفة بالتسلسل من الفهرس 1 إلى n بدون فراغات. 2) هذا يضمن أن معادلات (أب لـ i هو i/2، أبناء i هم 2i و 2i+1) تكون صحيحة لجميع العقد التي لها أبناء، دون الحاجة إلى فحص إضافي."
  },
  {
    "question": "إذا أردت تنفيذ قائمة انتظار ذات أولوية (Priority Queue) باستخدام كومة، فما هي العمليات الأساسية وتعقيداتها؟",
    "options": [
      "إدراج (Insert): O(log n)، إزالة الأعلى (Extract-Max): O(log n)، عرض الأعلى (Peek): O(1)",
      "إدراج: O(1)، إزالة: O(n)، عرض: O(1)",
      "إدراج: O(n)، إزالة: O(1)، عرض: O(n)",
      "كل العمليات O(log n)"
    ],
    "correct": 0,
    "explanation": "هذا هو السبب الرئيسي لشعبية بنية الكومة. الإدراج: نضيف في النهاية ثم نرفع (heapify-up) O(log n). إزالة الأعلى: نستبدل الجذر بآخر عنصر ثم نهبط (heapify-down) O(log n). عرض الأعلى (رؤية العنصر ذي الأولوية القصوى دون حذفه): ببساطة ننظر للجذر O(1)."
  },
  {
    "question": "ما هو الخطأ في المنطق التالي: 'بما أن بناء الكومة يأخذ O(n) ومرحلة الترتيب تأخذ O(n log n)، إذاً تعقيد Heap Sort هو O(n log n) لأن الحد الأكبر هو المهيمن'؟",
    "options": [
      "لا يوجد خطأ، هذا صحيح تماماً",
      "الخطأ أن بناء الكومة يأخذ O(n log n) في الطريقة التي نستخدمها",
      "الخطأ أن الحد الأصغر O(n) لا يؤثر على التدوين المقارب",
      "الخطأ أن مرحلة الترتيب هي O(n)"
    ],
    "correct": 0,
    "explanation": "هذا المنطق صحيح. في التحليل المقارب (Big O)، نأخذ الحد الذي ينمو أسرع مع زيادة n. O(n + n log n) = O(n log n) لأن n log n ينمو أسرع من n. العبارة صحيحة سواء كان بناء الكومة O(n) أو O(n log n) (في طريقتنا)."
  },
  {
    "question": "إذا كان لدينا مصفوفة مرتبة تصاعدياً وأردنا تحويلها إلى Max Heap بأقل عدد من التبديلات، ما هي الاستراتيجية؟",
    "options": [
      "نبدأ من أول عنصر ونرفع كل عنصر",
      "نبدأ من آخر عقدة غير ورقية وننفذ heapify-down عليها نحو الأعلى (طريقة Bottom-up)",
      "نعكس المصفوفة أولاً",
      "نستخدم خوارزمية مختلفة"
    ],
    "correct": 1,
    "explanation": "الطريقة الأكثر كفاءة هي البناء من الأسفل إلى الأعلى (Bottom-up). نبدأ من الفهرس n/2 (أول عقدة غير ورقية من الأسفل) ونتجه نحو الجذر (نزل إلى 1). لكل عقدة، ننفذ heapify-down. هذه الطريقة تستغرق O(n) وستكون فعالة حتى لو كانت المصفوفة مرتبة تصاعدياً (وهي حالة صعبة)."
  },
  {
    "question": "لماذا تعتبر خوارزمية Heap Sort مناسبة لأنظمة الوقت الحقيقي (Real-time Systems) أكثر من Quick Sort؟",
    "options": [
      "لأنها أسرع دائماً",
      "لأنها تعطي ضماناً لأسوأ حالة زمنية (O(n log n))، بينما أسوأ حالة Quick Sort O(n²) غير مقبولة في الوقت الحقيقي",
      "لأنها تستخدم ذاكرة أقل",
      "لأنها أسهل في التنفيذ"
    ],
    "correct": 1,
    "explanation": "في الأنظمة التي يجب أن تكون مضمونة الاستجابة في وقت محدد (مثل الأنظمة الطبية، التحكم في الطائرات)، لا يمكن المخاطرة بأسوأ حالة O(n²) لـ Quick Sort (حتى لو نادرة). Heap Sort تضمن أداء O(n log n) في جميع الحالات، مما يجعلها متوقعة وآمنة للاستخدام في مثل هذه السياقات."
  },
  {
    "question": "ما هو سبب تعيين `s = 0` في الفرع else من الشرط `if (s < i)` (السطر 70 تقريباً)؟",
    "options": [
      "لأن الابن المُختار (`s`) خارج حدود الكومة غير المرتبة (>= i)، لذا نريد كسر حلقة while",
      "لتهيئة s لقيمة جديدة",
      "لأنه لا يوجد أبناء",
      "لأن قيمة value غير معروفة"
    ],
    "correct": 0,
    "explanation": "الشرط `if (s < i)` يتحقق من أن الفهرس `s` (الذي يمثل أكبر ابن مرشح) لا يزال ضمن الجزء غير المرتب من المصفوفة (أقل من i). إذا كان `s >= i`، فهذا يعني أن كلا الابنين (أو الابن الوحيد) موجودان في المنطقة التي تم ترتيبها بالفعل (في نهاية المصفوفة). عندها، نكسر حلقة while عن طريق تعيين `s = 0`، لأننا دخلنا 'مرحلة الترتيب' ولا نريد المقارنة مع عناصر مرتبة."
  },
  {
    "question": "كيف تتعامل Heap Sort مع القيم المتساوية (التكرارات) من حيث الأداء؟",
    "options": [
      "تصبح أبطأ لأنها تسبب مزيداً من التبديلات",
      "تصبح أسرع لأن التبديلات تقل",
      "لا يتأثر الأداء بشكل كبير، يبقى O(n log n)",
      "تتوقف الخوارزمية"
    ],
    "correct": 2,
    "explanation": "وجود قيم متساوية لا يغير التعقيد الزمني المقارب. قد يقلل قليلاً من عدد التبديلات الداخلية لأن شرط المقارنة (`<` أو `>`) قد لا يتحقق في بعض الخطوات عند المساواة، ولكنه لا يغير الترتيب العام لـ O(n log n)."
  },
  {
    "question": "ما هو التحدي في محاولة جعل Heap Sort خوارزمية مستقرة (Stable)؟",
    "options": [
      "يمكن جعلها مستقرة بسهولة بإضافة فهرس ثانوي للمقارنة",
      "صعب جداً لأن عمليات التبديل بين الأب والأبناء البعيدة قد تفقد الاستقرار، والحفاظ عليه قد يتطلب ذاكرة إضافية أو يجعل الخوارزمية أبطأ",
      "لا يمكن أبداً لأنها تعتمد على الشجرة",
      "هي بالفعل مستقرة"
    ],
    "correct": 1,
    "explanation": "الاستقرار يعني أن العناصر المتساوية تحافظ على ترتيبها الأصلي. في Heap Sort، عندما تتبادل عقدة في الجذر مع آخر ورقة (وهي قد تكون بعيدة)، أو أثناء heapify-down، قد ينتهي عنصر متساوٍ قبل آخر كان بعده أصلاً. لجعلها مستقرة، قد نحتاج إلى إرفاق مؤشر ترتيب أصلية أو استخدام ذاكرة إضافية، مما يزيد التعقيد."
  }

                    
                ],
                lec3: [
{ question: "في خوارزمية هوفمان، أين توضع الأحرف؟", 
   options: ["في العقد غير الورقية", "في الجذر فقط", "في الأوراق", "في الفروع"], 
   correct: 2,
   explanation: "الأحرف توضع في الأوراق فقط." },

 { question: "ما الهدف الأساسي من خوارزمية هوفمان؟", 
   options: ["ترتيب الأحرف", "ضغط البيانات بأقصر تمثيل ثنائي", "تشفير النص بكلمة سر", "بناء شجرة بحث"], 
   correct: 1,
   explanation: "الهدف هو ضغط البيانات بحيث يكون لكل حرف تمثيل ثنائي أقصر حسب تكراره." },

 { question: "في شجرة هوفمان، الحرف الأكثر تكراراً يكون:", 
   options: ["أبعد عن الجذر", "في المنتصف", "أقرب إلى الجذر", "ليس له علاقة"], 
   correct: 2,
   explanation: "الحروف الأكثر تكراراً توضع أقرب للجذر لتقصير طول الشيفرة." },

 { question: "عدد عقد شجرة هوفمان إذا كان عدد الأحرف n يساوي:", 
   options: ["n", "2n", "2n - 1", "n - 1"], 
   correct: 2,
   explanation: "شجرة هوفمان تحتوي على 2n-1 عقد إذا كان عدد الأحرف n." },

 { question: "لماذا لا يجوز أن تكون شيفرة حرف بداية لشيفرة حرف آخر؟", 
   options: ["لتقليل الذاكرة", "لمنع الغموض عند فك التشفير", "لتسريع البحث", "لأنه شرط شكلي"], 
   correct: 1,
   explanation: "لكي لا يكون هناك غموض عند فك الشيفرة." },


 // ============================
 // المرحلة 2: التكرار والاختيار
 // ============================

 { question: "في كل خطوة من بناء شجرة هوفمان نختار:", 
   options: ["أكبر تكرارين", "أصغر تكرارين غير مستخدمين", "أي عقدتين", "العقد الورقية فقط"], 
   correct: 1,
   explanation: "نختار أصغر عقدتين غير مستخدمتين لدمجهما." },

 { question: "إذا كانت التكرارات: a=5 , b=2 , c=1 , d=1 فما أول عقدتين يتم دمجهما؟", 
   options: ["a و b", "c و d", "a و c", "b و c"], 
   correct: 1,
   explanation: "أصغر تكرارين هما c و d، لذا ندمجهما أولاً." },

 { question: "تكرار العقدة الأب يساوي:", 
   options: ["أكبر تكرار بين الأبناء", "أصغر تكرار", "مجموع تكراري الابنين", "عدد العقد"], 
   correct: 2,
   explanation: "تكرار العقدة الأب يساوي مجموع تكراري الابنين." },

 { question: "العقد التي لها del = true هي:", 
   options: ["العقد المحذوفة", "العقد المستخدمة", "العقد المتاحة للاختيار", "العقد الجذر"], 
   correct: 2,
   explanation: "del = true تعني أن العقدة تم اختيارها أو مستخدمة." },

 { question: "بعد اختيار عقدة بواسطة findminfreq فإن del تصبح:", 
   options: ["true", "false", "null", "1"], 
   correct: 1,
   explanation: "بعد الاختيار تصبح del = false لتمييز أنها مستخدمة." },


 // ============================
 // المرحلة 3: التمثيل بالمصفوفة
 // ============================

 { question: "تمثيل شجرة هوفمان في البرنامج يتم باستخدام:", 
   options: ["مصفوفة عقد", "مصفوفة محارف", "Stack", "Queue"], 
   correct: 0,
   explanation: "يتم تمثيل الشجرة باستخدام مصفوفة العقد." },

 { question: "الحقل father في العقدة يشير إلى:", 
   options: ["عدد الأبناء", "تكرار الأب", "دليل العقدة الأب", "يمين أو يسار"], 
   correct: 2,
   explanation: "father يخزن فهرس العقدة الأب لكل عقدة." },

 { question: "الحقل isLeft يدل على:", 
   options: ["هل العقدة ورقة", "هل العقدة يسارية", "هل العقدة مستخدمة", "هل هي جذر"], 
   correct: 1,
   explanation: "isLeft يحدد إذا كانت العقدة الابنة يسارية أم لا." },

 { question: "الجذر في شجرة هوفمان يكون عند الفهرس:", 
   options: ["0", "n", "2n-2", "2n-1"], 
   correct: 2,
   explanation: "الجذر يكون عند الفهرس 2n-2 في تمثيل المصفوفة." },

 { question: "عدد العقد الورقية في شجرة هوفمان يساوي:", 
   options: ["n", "2n-1", "n-1", "2n"], 
   correct: 0,
   explanation: "عدد العقد الورقية يساوي عدد الأحرف n." },


 // ============================
 // المرحلة 4: الترميز (Code)
 // ============================

 { question: "عند الصعود من ابن يساري إلى الأب نضيف:", 
   options: ["1", "0", "لا شيء", "حسب التكرار"], 
   correct: 1,
   explanation: "نضيف 0 عند الصعود من ابن يساري." },

 { question: "عند الصعود من ابن يميني إلى الأب نضيف:", 
   options: ["0", "1", "حسب العمق", "لا شيء"], 
   correct: 1,
   explanation: "نضيف 1 عند الصعود من ابن يميني." },

 { question: "يتم توليد شيفرة الحرف بالتحرك من:", 
   options: ["الجذر إلى الورقة", "الورقة إلى الجذر", "اليمين إلى اليسار", "اليسار إلى اليمين"], 
   correct: 1,
   explanation: "نبدأ من الورقة إلى الجذر لتوليد الشيفرة." },

 { question: "تخزن الشيفرة في:", 
   options: ["node", "symbol", "CodeType", "alph"], 
   correct: 2,
   explanation: "الشيفرة تخزن في هيكل CodeType." },

 { question: "startPos في CodeType يدل على:", 
   options: ["عدد البتات", "بداية الشيفرة داخل المصفوفة", "نهاية الشيفرة", "طول الرسالة"], 
   correct: 1,
   explanation: "startPos يحدد بداية الشيفرة في مصفوفة البتات." },


 // ============================
 // المرحلة 5: خصائص الشيفرة
 // ============================

 { question: "شيفرة هوفمان هي:", 
   options: ["ثابتة الطول", "متغيرة الطول", "عشوائية", "ثلاثية"], 
   correct: 1,
   explanation: "شيفرة هوفمان متغيرة الطول حسب تكرار الحروف." },

 { question: "الأحرف الأقل تكراراً يكون لها:", 
   options: ["أقصر شيفرة", "أطول شيفرة", "نفس الطول", "بدون شيفرة"], 
   correct: 1,
   explanation: "الأحرف الأقل تكراراً لها أطول شيفرة." },

 { question: "إذا تغيرت التكرارات فإن:", 
   options: ["الشيفرة تبقى نفسها", "الشجرة تتغير", "الجذر فقط يتغير", "لا شيء يتغير"], 
   correct: 1,
   explanation: "تغيير التكرارات يغير الشجرة وبالتالي الشيفرة." },

 { question: "سبب أن شيفرة هوفمان تضغط البيانات هو:", 
   options: ["تستخدم 0 و 1 فقط", "تعطي الأقصر للأكثر تكراراً", "تلغي بعض الأحرف", "تعيد ترتيب النص"], 
   correct: 1,
   explanation: "الشيفرة تعطي رموز أقصر للحروف الأكثر تكراراً." },

 { question: "هل يمكن أن يكون حرفان لهما نفس الشيفرة؟", 
   options: ["نعم", "لا", "أحياناً", "حسب التكرار"], 
   correct: 1,
   explanation: "لا، كل حرف له شيفرة فريدة لتجنب الغموض." }
                ],
                lec4:[
  {
    "question": "ما هو المبدأ الأساسي الذي تستند إليه شجرة البحث الثنائية (Binary Search Tree)؟",
    "options": [
      "كل عقدة لها قيمتان",
      "القيمة في العقدة اليسرى أصغر من القيمة في العقدة الحالية والقيمة في العقدة اليمنى أكبر",
      "كل عقدة لها أكثر من ولدين",
      "جميع الأوراق على نفس المستوى"
    ],
    "correct": 1,
    "explanation": "في شجرة البحث الثنائية، يتم تخزين العناصر بناءً على ترتيبها: القيمة في كل عقدة يسارية أصغر من قيمة العقدة الأصل، والقيمة في كل عقدة يمينية أكبر من قيمة العقدة الأصل."
  },
  {
    "question": "كيف يتم تمثيل العقدة (Node) في تنفيذ شجرة البحث الثنائية باستخدام المؤشرات؟",
    "options": [
      "بمصفوفة تحتوي على القيم والأبناء",
      "باستخدام صف يحتوي على: قيمة (value)، مؤشر للابن اليساري (left)، مؤشر للابن اليميني (right)",
      "بقائمة مرتبطة أحادية الاتجاه",
      "بسجل يحتوي على القيمة فقط"
    ],
    "correct": 1,
    "explanation": "يتم تمثيل كل عقدة في الشجرة الثنائية ببنية تحتوي على حقول: القيمة (value) من نوع int، ومؤشر للابن اليساري (left) وآخر للابن اليميني (right)، وكلاهما من نفس نوع العقدة (Node)."
  },
  {
    "question": "كيف نعرف أننا وصلنا إلى نهاية فرع في شجرة البحث الثنائية؟",
    "options": [
      "عندما تكون قيمة العقدة تساوي صفر",
      "عندما يكون المؤشر left أو right يشير إلى null",
      "عندما تكون قيمة العقدة أكبر من قيمة الأب",
      "عندما تكون العقدة في المستوى الأخير"
    ],
    "correct": 1,
    "explanation": "عندما يكون المؤشر left أو right لـعقدة ما يشير إلى null، فهذا يعني أنه لا يوجد ابن في هذا الاتجاه، وبالتالي نكون وصلنا إلى نهاية الفرع (ورقة أو نهاية المسار)."
  },
  {
    "question": "ما هي الخطوة الأولى عند بناء شجرة بحث ثنائية جديدة؟",
    "options": [
      "إنشاء عقدة وتسميتها كجذر (root) وتعيين قيمتها للرقم الأول",
      "إدخال جميع الأرقام في قائمة ثم بناء الشجرة",
      "إنشاء جميع العقد ثم ربطها ببعض",
      "فرز الأرقام أولاً ثم بناء الشجرة"
    ],
    "correct": 0,
    "explanation": "يبدأ بناء الشجرة بإنشاء أول عقدة وتعتبر جذر (root)، بحيث تكون قيمة الجذر هي أول رقم يدخل، ومؤشرات left و right تكون null."
  },
  {
    "question": "ما هي الطريقة المستخدمة لإدراج رقم جديد في شجرة البحث الثنائية؟",
    "options": [
      "نبدأ من الجذر ونقارن: إذا كان الرقم أكبر نذهب يميناً، إذا كان أصغر نذهب يساراً، حتى نصل إلى null فننشئ عقدة جديدة",
      "نضع الرقم دائماً في أقصى اليسار",
      "نضع الرقم في موقع عشوائي في الشجرة",
      "نقوم بفرز الشجرة أولاً ثم نضع الرقم في المنتصف"
    ],
    "correct": 0,
    "explanation": "يتم إدراج العناصر عن طريق البدء من الجذر ومقارنة القيمة المراد إدخالها مع قيمة العقدة الحالية، ثم التحرك يميناً أو يساراً بناءً على المقارنة حتى الوصول لموضع فارغ (null) حيث تُنشأ العقدة الجديدة."
  },
  {
    "question": "ما هو نوع العبور (Traversal) الذي يُعطي الأرقام مرتبة تصاعدياً في شجرة بحث ثنائية؟",
    "options": [
      "Preorder (جذر-يسار-يمين)",
      "Inorder (يسار-جذر-يمين)",
      "Postorder (يسار-يمين-جذر)",
      "Level-order (حسب المستويات)"
    ],
    "correct": 1,
    "explanation": "العبور من النوع Inorder (الذهاب أقصى اليسار، ثم طباعة الجذر، ثم الذهاب يميناً) في شجرة بحث ثنائية ينتج قائمة مرتبة تصاعدياً بسبب خاصية الشجرة (اليسار < الجذر < اليمين)."
  },
  {
    "question": "ما هو شرط استمرار حلقة البحث عن عنصر في الشجرة؟",
    "options": [
      "أن يكون المؤشر P يساوي null",
      "أن يكون المتغير found يساوي true",
      "أن يكون المؤشر P ليس null وأن يكون found يساوي false",
      "أن يكون Q يساوي P"
    ],
    "correct": 2,
    "explanation": "تستمر عملية البحث طالما أن المؤشر P لم يصل إلى نهاية فرع (ليس null) ولم يتم العثور على العنصر بعد (found == false)."
  },
  {
    "question": "ما هو دور المتغير Q في خوارزمية البحث والحذف؟",
    "options": [
      "يخزن العقدة الجذر",
      "يشير إلى العقدة التي سبقت P (أب العقدة الحالية)",
      "يخزن أصغر عنصر في الشجرة",
      "يحدد نوع العبور المستخدم"
    ],
    "correct": 1,
    "explanation": "يتم استخدام Q لتتبع العقدة الأب للعقدة الحالية P، مما يساعد لاحقاً في عملية إعادة الربط عند حذف العقدة."
  },
  {
    "question": "في خوارزمية البحث، ماذا يعني أن قيمة found أصبحت true؟",
    "options": [
      "أن الشجرة فارغة",
      "أن العقدة الحالية P هي null",
      "أن العنصر المطلوب موجود في الشجرة",
      "أنه يجب الانتقال إلى الابن الأيسر"
    ],
    "correct": 2,
    "explanation": "عندما تصبح found == true فهذا يعني أن قيمة P.value تساوي القيمة المطلوبة (key)، وبالتالي تم العثور على العنصر المطلوب في الشجرة."
  },
  {
    "question": "ما هي الحالات الثلاث الممكنة عند حذف عقدة من شجرة البحث الثنائية؟",
    "options": [
      "العقدة لها أخ واحد، لها عم، لها جد",
      "العقدة تحتوي على رقم زوجي، رقم فردي، رقم سالب",
      "العقدة ليس لها أبناء، لها ابن واحد، لها اثنان من الأبناء",
      "العقدة في أول الشجرة، في وسط الشجرة، في آخر الشجرة"
    ],
    "correct": 2,
    "explanation": "عند حذف عقدة: 1) قد لا يكون لها أبناء (ورقة). 2) قد يكون لها ابن واحد فقط (يساري أو يميني). 3) قد يكون لها ابنان (يساري ويميني). وتختلف الخوارزمية باختلاف الحالة."
  },
  {
    "question": "كيف يتم التعامل مع حذف عقدة ليس لها أبناء (ورقة)؟",
    "options": [
      "نجعل العقدة الأب تؤشر إلى null في الاتجاه المناسب",
      "نستبدلها بالجذر",
      "نربطها بأقرب عقدة مجاورة",
      "نحذف الشجرة كلها"
    ],
    "correct": 0,
    "explanation": "عند حذف عقدة ورقة (لا أبناء لها)، نقوم ببساطة بتعديل المؤشر في العقدة الأب (التي يخزنها Q) ليشير إلى null بدلاً من الإشارة إلى العقدة المحذوفة."
  },
  {
    "question": "كيف نتعامل مع حذف عقدة لها ابن واحد فقط؟",
    "options": [
      "نربط العقدة الأب مباشرة بالابن الوحيد للعقدة المحذوفة",
      "نحذف الابن أيضاً",
      "نستبدل العقدة بأصغر عنصر في الشجرة",
      "نقوم بقلب الشجرة"
    ],
    "correct": 0,
    "explanation": "إذا كان للعقدة المحذوفة ابن واحد فقط (يساري أو يميني)، فإننا نجعل العقدة الأب (Q) تؤشر مباشرة إلى هذا الابن، متجاوزين العقدة المحذوفة."
  },
  {
    "question": "ما هي الاستراتيجية المستخدمة عند حذف عقدة لها اثنان من الأبناء؟",
    "options": [
      "حذف العقدة دون استبدال",
      "استبدال العقدة المحذوفة بأكبر عنصر في الفرع الأيسر، أو بأصغر عنصر في الفرع الأيمن",
      "قلب ترتيب الفرعين",
      "دمج الابن الأيسر واليمين في عقدة واحدة"
    ],
    "correct": 1,
    "explanation": "لضمان بقاء الشجرة بحث ثنائية صحيحة، نستبدل العقدة المحذوفة (ذات الابنيتين) إما بأكبر عقدة في فرعها الأيسر (أقصى اليمين في اليسار) أو بأصغر عقدة في فرعها الأيمن (أقصى اليسار في اليمين)، ثم نحذف العقدة البديلة من موقعها الأصلي."
  },
  {
    "question": "لماذا نبحث عن 'أصغر عنصر في الفرع الأيمن' عند حذف عقدة لها ابنان؟",
    "options": [
      "لأنه الأقرب من حيث القيمة إلى العقدة المحذوفة ويضمن أن جميع العناصر في الفرع الأيمن تبقى أكبر منه",
      "لأنه الأسهل في الوصول إليه",
      "لأن قيمته دائمًا تساوي صفر",
      "لأنه الورقة الأبعد في الشجرة"
    ],
    "correct": 0,
    "explanation": "أصغر عنصر في الفرع الأيمن (الموجود في أقصى اليسار من ذلك الفرع) هو العنصر الذي يأتي مباشرة بعد العقدة المحذوفة في الترتيب التصاعدي. استبدال العقدة به يضمن أن جميع العناصر في اليسار تبقى أصغر منه، وجميع العناصر في اليمين تبقى أكبر منه."
  },
  {
    "question": "ما هو دور المؤشرات V و T و S في حالة حذف عقدة لها ابنان؟",
    "options": [
      "V يشير للخلف (البديل)، T يشير لأب الخلف، S تستخدم للبحث عن الخلف",
      "V يشير للجذر، T يشير للأب، S يشير للابن",
      "جميعها تخزن نسخة من العقدة المحذوفة",
      "V و T و S هي مؤشرات لنفس العقدة"
    ],
    "correct": 0,
    "explanation": "V: يشير إلى العقدة البديلة (الخلف) التي ستأخذ مكان المحذوفة. T: يشير إلى أب العقدة البديلة (V). S: مؤشر مساعد يستخدم في حلقة while للبحث عن العقدة البديلة (أصغر عنصر في الفرع الأيمن)."
  },
  {
    "question": "متى تنتهي حلقة البحث عن العقدة البديلة (الخلف) S؟",
    "options": [
      "عندما تصبح S تساوي null",
      "عندما تصبح قيمة S أصغر من P",
      "عندما تصبح found تساوي true",
      "عندما يصبح T مساوياً لـ P"
    ],
    "correct": 0,
    "explanation": "نستمر في تحريك S نحو اليسار (S = S.left) حتى تصبح S == null. عندها، تكون العقدة السابقة لـ S (والتي يخزنها V) هي أصغر عقدة في الفرع (الخلف المطلوب)."
  },
  {
    "question": "ماذا يعني الشرط (T != P) في حالة حذف عقدة لها ابنان؟",
    "options": [
      "أن العقدة البديلة (V) ليست الابن المباشر الأيمن للعقدة المحذوفة (P)",
      "أن العقدة المحذوفة هي الجذر",
      "أن العقدة البديلة لها ابن أيسر",
      "أن T يشير إلى null"
    ],
    "correct": 0,
    "explanation": "إذا كان T != P، فهذا يعني أننا تحركنا لليسار على الأقل مرة واحدة أثناء البحث عن الخلف. وبالتالي العقدة البديلة (V) ليست الابن الأيمن المباشر لـ P، بل هي في مكان أعمق داخل الفرع الأيمن."
  },
  {
    "question": "ماذا يحدث إذا كانت العقدة المراد حذفها هي الجذر (root)؟",
    "options": [
      "يتم إلغاء عملية الحذف",
      "يتم تعيين العقدة البديلة (V) كجذر جديد للشجرة",
      "تظل الشجرة بدون جذر",
      "نربط الجذر بأقرب عقدة"
    ],
    "correct": 1,
    "explanation": "إذا كان Q == null، فهذا يعني أن العقدة المحذوفة (P) هي الجذر. في هذه الحالة، نقوم بتعيين العقدة البديلة (V) لتكون الجذر الجديد للشجرة (root = V)."
  },
  {
    "question": "كيف يتم ربط العقدة البديلة (V) مكان المحذوفة (P) من ناحية الأبناء؟",
    "options": [
      "V.right = P.right و V.left = P.left",
      "يتم نسخ قيمة P إلى V فقط",
      "يتم عكس أبناء V",
      "لا يتم ربطهم، يتم إنشاء أبناء جدد"
    ],
    "correct": 0,
    "explanation": "لجعل العقدة البديلة V تؤدي دور العقدة المحذوفة P، يجب أن ترث أبناءها. لذلك نقوم بتعيين: V.right = P.right و V.left = P.left، لتحتفظ الشجرة بعلاقاتها."
  },
  {
    "question": "ما هو الشرط الذي يحدد إذا كان يجب ربط الأب (Q) بالخلف (V) من الجهة اليسرى أم اليمنى؟",
    "options": [
      "إذا كانت P == Q.left نربط Q.left = V، وإلا Q.right = V",
      "دائماً نربط Q.left = V",
      "نربط من الجهة التي تحقق أن قيمة V متوسطة",
      "نقرر عشوائياً"
    ],
    "correct": 0,
    "explanation": "يجب الحفاظ على العلاقة الأصلية بين العقدة الأب (Q) والعقدة المحذوفة (P). إذا كانت P هي الابن الأيسر لـ Q، فالخلف V يصبح الابن الأيسر الجديد لـ Q. والعكس صحيح."
  },
  {
    "question": "في المثال بالشرح، عند حذف العقدة ذات القيمة 10، ما هي العقدة التي استُخدمت كبديل (خلف)؟",
    "options": [
      "العقدة 9",
      "العقدة 12",
      "العقدة 14",
      "العقدة 15"
    ],
    "correct": 1,
    "explanation": "لأن العقدة 10 لها ابنان، تم أخذ أصغر عقدة في فرعها الأيمن (الذي جذره 14) كبديل. أصغر عقدة في هذا الفرع هي 12 (الموجودة في أقصى اليسار من الفرع الذي يبدأ بـ14)."
  },
  {
    "question": "ما الفرق الأساسي بين بناء شجرة بحث ثنائية باستخدام المؤشرات مقابل استخدام المصفوفة؟",
    "options": [
      "في المؤشرات نربط العقد ببعضها عبر مراجع، بينما في المصفوفة نعتمد على حسابات الفهرس (2*i, 2*i+1)",
      "المصفوفة أسرع دائماً",
      "لا فرق، فهما نفس الشيء",
      "المؤشرات تستخدم للشجر غير الثنائي فقط"
    ],
    "correct": 0,
    "explanation": "الفرق الجوهري هو في التمثيل: التمثيل بالمصفوفة يكون ضمنياً ويعتمد على مواقع الفهرس، بينما التمثيل بالمؤشرات يكون صريحاً حيث تحتوي كل عقدة على مراجع (مؤشرات) للعقد الأبناء."
  },
  {
    "question": "ما معنى أن عملية الإدراج (build) في الشجرة هي عملية 'تعاودية' (Recursive)؟",
    "options": [
      "أنها تستدعي نفسها بمعاملات مختلفة (مثل nodeP.left أو nodeP.right) حتى تصل للنقطة المنشودة",
      "أنها تدور في حلقة لا نهائية",
      "أنها تعيد ترتيب الشجرة في كل مرة",
      "أنها تحذف العناصر القديمة"
    ],
    "correct": 0,
    "explanation": "الدالة build تستدعي نفسها، ولكن مع تمرير مؤشر إلى ابن (يسار أو يمين) العقدة الحالية كـ 'جذر' جديد للبحث. هذا يستمر بشكل متكرر حتى الوصول إلى موقع فارغ (null) حيث يتم إنشاء العقدة الجديدة."
  },
  {
    "question": "كيف يتم معالجة حالة إدخال رقم مكرر في الدالة build كما ورد في الكود؟",
    "options": [
      "يتم تجاهل الرقم وطباعة رسالة 'DuplicateNumber'",
      "يتم إضافته في نفس المكان",
      "يتم وضعه كابن أيسر دائماً",
      "يتم إعادة بناء الشجرة من جديد"
    ],
    "correct": 0,
    "explanation": "وفقاً للكود، إذا كان الرقم المدخل يساوي قيمة العقدة الحالية (nodeP.value)، فإنه يدخل الفرع else الذي يطبع رسالة 'DuplicateNumber' ولا يقوم بأي إدراج، لأن الأشجار البحث الثنائية في هذا التطبيق لا تسمح بقيم مكررة."
  },
  {
    "question": "ما هو شرط التوقف في حلقة الإدخال الرئيسية (main) لبناء الشجرة؟",
    "options": [
      "عند إدخال القيمة -1",
      "عند إدخال 100 رقم",
      "عندما تمتلئ الذاكرة",
      "عند إدخال قيمة سالبة"
    ],
    "correct": 0,
    "explanation": "تستمر الحلقة في طلب أرقام من المستخدم وإدخالها في الشجرة حتى يقوم المستخدم بإدخال القيمة -1، والتي تعتبر إشارة لإنهاء عملية الإدخال."
  },
  {
    "question": "ما هو نوع القيم المخزنة في شجرة البحث الثنائية في هذا التطبيق؟",
    "options": [
      "نصوص (String)",
      "أرقام صحيحة (int)",
      "أرقام عشرية (double)",
      "قيم منطقية (boolean)"
    ],
    "correct": 1,
    "explanation": "حقل value في بنية Node مُعرّف كنوع int، وبالتالي الشجرة مصممة لتخزين وقارنة الأعداد الصحيحة."
  },
  {
    "question": "ما هو الهدف من استخدام JOptionPane في الكود الرئيسي (Main)؟",
    "options": [
      "لرسم الشجرة بيانياً",
      "لإدخال البيانات من خلال نوافذ حوارية للمستخدم",
      "لطباعة الشجرة في ملف",
      "لتحميل الأرقام من الإنترنت"
    ],
    "correct": 1,
    "explanation": "تُستخدم JOptionPane.showInputDialog لإنشاء نافذة حوارية بسيطة تطلب من المستخدم إدخال رقم، مما يجعل البرنامج تفاعلياً."
  },
  {
    "question": "في دالة print (للعبور)، ماذا يتم طباعته عندما تكون P == null؟",
    "options": [
      "يتم طباعة القيمة 0",
      "يتم طباعة فراغ أو مسافة ' ' للإشارة للنهاية",
      "يتوقف البرنامج عن العمل",
      "يعود للعقدة السابقة دون طباعة"
    ],
    "correct": 1,
    "explanation": "هذا هو الشرط الأساسي للتوقف في الدالة العاودية. عندما تصل الدالة إلى عقدة غير موجودة (null)، تطبع حرف فراغ (أو أي رمز) للإشارة إلى عدم وجود شيء، ثم تعود."
  },
  {
    "question": "لماذا يُفضل استخدام شجرة بحث ثنائية متوازنة؟",
    "options": [
      "لأنها تضمن أن عمليات البحث والإدراج والحذف تكون بكفاءة O(log n) في أسوأ الحالات",
      "لأنها تستخدم ذاكرة أقل",
      "لأن شكلها أجمل",
      "لأنها لا تسمح بالقيم المكررة"
    ],
    "correct": 0,
    "explanation": "إذا كانت الشجرة غير متوازنة (مائلة بشدة)، فقد تتحول إلى ما يشبه القائمة المرتبطة، مما يجعل عمليات البحث بكفاءة O(n). الشجرة المتوازنة تحافظ على ارتفاع يقارب اللوغاريتمي لعدد العقد، مما يحافظ على الكفاءة."
  },
  {
    "question": "في العبور Preorder، ما هو ترتيب زيارة العقد؟",
    "options": [
      "الجذر، ثم الابن الأيسر، ثم الابن الأيمن",
      "الابن الأيسر، ثم الجذر، ثم الابن الأيمن",
      "الابن الأيسر، ثم الابن الأيمن، ثم الجذر",
      "الجذر، ثم الابن الأيمن، ثم الابن الأيسر"
    ],
    "correct": 0,
    "explanation": "Preorder (أو VLR): تبدأ بزيارة الجذر أولاً (V)، ثم تنتقل بشكل عاودي إلى الشجرة اليسرى بأكملها (L)، ثم إلى الشجرة اليمنى بأكملها (R)."
  },
  {
    "question": "في العبور Postorder، ما هو ترتيب زيارة العقد؟",
    "options": [
      "الجذر، ثم الابن الأيسر، ثم الابن الأيمن",
      "الابن الأيسر، ثم الجذر، ثم الابن الأيمن",
      "الابن الأيسر، ثم الابن الأيمن، ثم الجذر",
      "الجذر، ثم الابن الأيمن، ثم الابن الأيسر"
    ],
    "correct": 2,
    "explanation": "Postorder (أو LRV): تزور بشكل عاودي الشجرة اليسرى بأكملها (L)، ثم الشجرة اليمنى بأكملها (R)، ثم تزور الجذر (V) أخيراً."
  },
  {
    "question": "ما هي الحالة التي يكون فيها العبور Inorder مفيداً جداً في شجرة البحث الثنائية؟",
    "options": [
      "عندما نريد نسخ الشجرة",
      "عندما نريد الحصول على العناصر مرتبة تصاعدياً أو تنازلياً",
      "عندما نريد معرفة ارتفاع الشجرة",
      "عندما نريد حساب عدد الأوراق"
    ],
    "correct": 1,
    "explanation": "بسبب خاصية الترتيب في شجرة البحث الثنائية (اليسار < الجذر < اليمين)، فإن العبور Inorder ينتج قائمة مرتبة من العناصر. هذا مفيد للحصول على البيانات بشكل مرتب دون الحاجة لفرضها في بنية أخرى."
  },
  {
    "question": "كيف نبدأ عملية البحث في الدالة search؟",
    "options": [
      "بوضع P على الجذر root، وQ على null، وfound على false",
      "بوضع P على null، وQ على الجذر",
      "بوضع found على true مباشرة",
      "باستدعاء الدالة build أولاً"
    ],
    "correct": 0,
    "explanation": "تهيئة البحث تكون بتعيين المؤشر الحالي P ليشير إلى جذر الشجرة (بداية البحث)، وتعيين Q كـ null (لأن الجذر ليس له أب)، وتعيين found كـ false (لم يتم العثور بعد)."
  },
  {
    "question": "ماذا يحدث إذا حاولنا حذف عنصر غير موجود في الشجرة؟",
    "options": [
      "تطبع رسالة 'This number is not in the tree'",
      "تحذف الجذر عوضاً عنه",
      "تنشئ العقدة ثم تحذفها",
      "لا يحدث شيء وتستمر العملية"
    ],
    "correct": 0,
    "explanation": "إذا انتهت حلقة البحث وخرجنا منها بـ found == false، فهذا يعني أن الرقم المطلوب (key) غير موجود في الشجرة. يتم طباعة رسالة تنبيه للمستخدم."
  },
  {
    "question": "ما هو دور المؤشر P.right في بداية البحث عن الخلف (لحذف عقدة ذات ابنين)؟",
    "options": [
      "ينتقل مباشرة إلى الابن الأيسر للعقدة المحذوفة",
      "ينتقل خطوة واحدة إلى اليمين (الفرع الأيمن) للبدء بالبحث عن أصغر عنصر فيه",
      "يستخدم لحساب ارتفاع الشجرة",
      "يعيد تعيين الجذر"
    ],
    "correct": 1,
    "explanation": "بعد التأكد من أن العقدة P لها ابنان، نبدأ البحث عن الخلف (البديل) في الفرع الأيمن لـ P. لذلك نضع V = P.right كبداية للبحث في ذلك الفرع."
  },
  {
    "question": "ما الفائدة من تعليمة 'T.left = V.right' عند حذف عقدة لها ابنان؟",
    "options": [
      "لربط ابن الخلف الأيمن بوالد الخلف، لأن الخلف (V) سيتم نقله لمكان آخر",
      "لحذف الابن الأيسر للخلف",
      "لقلب اتجاه الفرع الأيمن",
      "لتحديث قيمة الجذر"
    ],
    "correct": 0,
    "explanation": "عندما ننقل العقدة V (الخلف) لتحل محل P، يجب علينا أولاً إزالتها من موقعها الأصلي. V.right (الابن الوحيد لـ V عادةً) يجب أن يصبح الابن الأيسر الجديد لـ T (والد V)، لملء الفراغ الناتج عن نقل V."
  },
  {
    "question": "كيف يمكن أن يؤثر ترتيب إدخال البيانات على شكل شجرة البحث الثنائية الناتجة؟",
    "options": [
      "لا يؤثر، فالشجرة النهائية دائماً نفسها",
      "يؤثر بشكل كبير، فإدخال الأرقام مرتبة (متصاعدة أو تنازلية) ينتج شجرة مائلة تشبه القائمة المرتبطة",
      "يؤثر فقط على لون العقد",
      "يؤثر على نوع القيم التي يمكن إدخالها"
    ],
    "correct": 1,
    "explanation": "إذا أدخلت الأرقام مرتبة (مثل 1,2,3,4...)، ستتحول الشجرة إلى قائمة مرتبة يمينية (كل عقدة لها ابن أيمن فقط). وهذا أسوأ حالة للأداء (O(n)). بينما الإدخال العشوائي يميل لإنتاج شجرة أكثر توازناً."
  },
  {
    "question": "بعد حذف عقدة ناجح، كيف نتأكد أن الشجرة لا تزال تحافظ على خاصية شجرة البحث الثنائية؟",
    "options": [
      "نقوم بطباعتها باستخدام Inorder، فإذا كانت مرتبة، فهي صحيحة",
      "نقوم بحساب عدد العقد",
      "نتأكد من أن كل عقدة لها لونان",
      "لا يمكن التأكد إلا بإعادة بنائها"
    ],
    "correct": 0,
    "explanation": "خاصية شجرة البحث الثنائية هي أن العبور Inorder يعطي تسلسلاً مرتباً. بعد أي عملية حذف، يمكن طباعة الشجرة باستخدام Inorder للتحقق من أن العناصر ما زالت مرتبة، مما يدل على صحة العملية."
  },
  {
    "question": "ما هو الهدف التعليمي الأساسي من خوارزمية البحث والحذف في شجرة البحث الثنائية كما وردت بالمحاضرة؟",
    "options": [
      "فهم كيفية تخزين البيانات في مصفوفة",
      "فهم كيفية تنفيذ بنية بيانات ديناميكية غير خطية واستخدام المؤشرات للتنقل فيها وإجراء عمليات معقدة مع الحفاظ على الخواص",
      "تعلم كيفية رسم الأشجار",
      "فهم كيفية استخدام الحلقات البسيطة فقط"
    ],
    "correct": 1,
    "explanation": "تعتبر شجرة البحث الثنائية بنية بيانات ديناميكية غير خطية أساسية. هذه الخوارزمية تعلم كيفية التعامل مع هذه البنية باستخدام المؤشرات، وإجراء عمليات البحث والإدراج والحذف المعقدة التي تتطلب إعادة ربط دقيق للمؤشرات مع الحفاظ على خواص الشجرة."
  }
]
            
            }
        },
        circuits: {
            name: "نظرية المخططات",
            lectures: {
    lec3:[

       
  {
    "question": "ما هو الفرق الأساسي بين المخطط الموزون (Weighted Graph) والمخطط غير الموزون (Unweighted Graph)؟",
    "options": [
      "المخطط غير الموزون لا يمكن تطبيق Dijkstra عليه",
      "المخطط الموزون يكون دائمًا موجهًا",
      "المخطط الموزون يحتوي على عقد أكثر",
      "المخطط الموزون له أوزان على الحواف تمثل كلفة أو زمن أو مسافة"
    ],
    "correct": 3,
    "explanation": "الفرق الأساسي هو أن المخطط الموزون يحتوي على أوزان على الحواف تمثل قيمًا مثل الكلفة أو الزمن أو المسافة، بينما في المخطط غير الموزون تعتبر جميع الحواف متساوية الوزن."
  },
  {
    "question": "ما هي القيمة التي تمثل طول المسار في المخطط الموزون؟",
    "options": [
      "عدد الحواف في المسار",
      "عدد العقد في المسار",
      "مجموع أوزان الحواف في المسار",
      "متوسط أوزان الحواف في المسار"
    ],
    "correct": 2,
    "explanation": "في المخطط الموزون، طول المسار يساوي مجموع أوزان جميع الحواف التي يمر عليها، وليس مجرد عدد الحواف."
  },
  {
    "question": "ما هي الخوارزمية المناسبة لإيجاد أقصر مسار في مخطط موزون بأوزان موجبة؟",
    "options": [
      "خوارزمية BFS",
      "خوارزمية Dijkstra",
      "خوارزمية DFS",
      "خوارزمية Prim"
    ],
    "correct": 1,
    "explanation": "خوارزمية Dijkstra هي الخوارزمية المناسبة لإيجاد أقصر مسار في مخطط موزون بأوزان موجبة، بينما BFS مناسبة للمخططات غير الموزونة."
  },
  {
    "question": "ما هو الشرط الأساسي لأوزان الحواف في خوارزمية Dijkstra؟",
    "options": [
      "يمكن أن تكون الأوزان سالبة",
      "يجب أن تكون جميع الأوزان متساوية",
      "يجب أن تكون جميع الأوزان موجبة",
      "يجب أن تكون الأوزان أعدادًا صحيحة فقط"
    ],
    "correct": 2,
    "explanation": "خوارزمية Dijkstra تتطلب أن تكون جميع الأوزان موجبة، لأن الأوزان السالبة قد تؤدي إلى حلول لا نهائية أو نتائج غير صحيحة."
  },
  {
    "question": "ما هو دور المتغير d[u] في خوارزمية Dijkstra؟",
    "options": [
      "يمثل اللون الحالي للعقدة u",
      "يمثل عدد الحواف من العقدة المصدر إلى العقدة u",
      "يمثل أقصر مسافة معروفة من العقدة المصدر إلى العقدة u",
      "يمثل السلف المباشر للعقدة u"
    ],
    "correct": 2,
    "explanation": "d[u] يمثل أقصر مسافة معروفة حالياً من عقدة المصدر (source) إلى العقدة u، ويتم تحديث هذه القيمة أثناء تنفيذ الخوارزمية."
  },
  {
    "question": "ما هو دور المصفوفة pred[v] في خوارزمية Dijkstra؟",
    "options": [
      "تشير إلى لون العقدة v",
      "تشير إلى وزن الحواف المرتبطة بالعقدة v",
      "تشير إلى عدد جوارات العقدة v",
      "تشير إلى العقدة السابقة للعقدة v في أقصر مسار"
    ],
    "correct": 3,
    "explanation": "pred[v] تخزن العقدة السابقة للعقدة v في أقصر مسار معروف من المصدر إلى v، مما يسمح بإعادة بناء المسار لاحقاً."
  },
  {
    "question": "ما هي العقدة التي يتم اختيارها أولاً في خوارزمية Dijkstra؟",
    "options": [
      "العقدة ذات أكبر عدد من الجوارات",
      "أي عقدة عشوائية",
      "العقدة ذات الوزن الأكبر",
      "عقدة المصدر (source)"
    ],
    "correct": 3,
    "explanation": "تبدأ الخوارزمية من عقدة المصدر (source) التي نريد إيجاد أقصر المسارات منها إلى جميع العقد الأخرى."
  },
  {
    "question": "كيف يتم اختيار العقدة التالية للمعالجة في خوارزمية Dijkstra؟",
    "options": [
      "العقدة الأقرب جغرافياً",
      "العقدة ذات أكبر عدد من الجوارات",
      "العقدة ذات أقل قيمة d[u] من بين العقد غير المعالجة",
      "العقدة الأولى في القائمة"
    ],
    "correct": 2,
    "explanation": "في كل خطوة، يتم اختيار العقدة ذات أقل مسافة معروفة (d[u]) من بين العقد التي لم تتم معالجتها بعد."
  },
  {
    "question": "ما هو الشرط الذي يتم اختباره عند فحص حافة بين العقدة u والعقدة v؟",
    "options": [
      "إذا كانت w(u,v) < d[v]",
      "إذا كانت d[u] = d[v]",
      "إذا كانت d[u] < d[v]",
      "إذا كانت d[u] + w(u,v) < d[v]"
    ],
    "correct": 3,
    "explanation": "يتم اختبار إذا كان المرور عبر العقدة u يوفر مساراً أقصر إلى v، أي إذا كانت المسافة من المصدر إلى u زائد وزن الحافة (u,v) أقل من المسافة الحالية إلى v."
  },
  {
    "question": "ماذا يحدث إذا تم اختبار الشرط d[u] + w(u,v) < d[v] وكان محققاً؟",
    "options": [
      "يتم حذف العقدة v من المخطط",
      "لا يحدث أي تغيير",
      "يتم تغيير لون العقدة v إلى أحمر",
      "يتم تحديث d[v] = d[u] + w(u,v) و pred[v] = u"
    ],
    "correct": 3,
    "explanation": "إذا وجدنا مساراً أقصر إلى v عبر u، نحدث المسافة d[v] لتكون المسافة الجديدة الأقصر، ونعين u كسلف لـ v في هذا المسار."
  },
  {
    "question": "ما هو الشرط اللازم حول اتصال المخطط لتطبيق خوارزمية Dijkstra؟",
    "options": [
      "يجب أن يكون المخطط غير متصل",
      "يجب أن يكون المخطط شجراً",
      "يجب أن يكون المخطط متصلاً (connected)",
      "لا يشترط اتصال المخطط"
    ],
    "correct": 2,
    "explanation": "يجب أن يكون المخطط متصلاً حتى يمكن الوصول من عقدة المصدر إلى جميع العقد الأخرى، وإلا ستكون بعض المسافات لا نهائية."
  },
  {
    "question": "ما هو نوع المخططات التي يمكن تطبيق Dijkstra عليها؟",
    "options": [
      "دائرية فقط",
      "موجهة فقط",
      "غير موجهة فقط",
      "موجهة أو غير موجهة"
    ],
    "correct": 3,
    "explanation": "يمكن تطبيق خوارزمية Dijkstra على كل من المخططات الموجهة (Directed) وغير الموجهة (Undirected)، طالما كانت الأوزان موجبة."
  },
  {
    "question": "ماذا تمثل القيمة ∞ في تهيئة خوارزمية Dijkstra؟",
    "options": [
      "مسافة صفر",
      "مسافة قصوى محددة",
      "مسافة لا نهائية (غير معروفة بعد)",
      "مسافة سالبة"
    ],
    "correct": 2,
    "explanation": "يتم تهيئة مسافات جميع العقد (ما عدا المصدر) بالقيمة ∞ التي تمثل مسافة غير معروفة أو لا نهائية، لأننا لم نكتشف بعد طريقاً إليها."
  },
  {
    "question": "ماذا يحدث للعقدة بعد معالجتها في خوارزمية Dijkstra؟",
    "options": [
      "يتم حذفها من المخطط",
      "يتم تعليمها كمعالجة وإزالتها من قائمة الانتظار",
      "يتم تغيير وزن حوافها",
      "تظل في قائمة الانتظار للمعالجة مرة أخرى"
    ],
    "correct": 1,
    "explanation": "بعد معالجة جميع جوارات العقدة، يتم تعليمها على أنها معالجة (مثلاً بتغيير لونها إلى أسود) وإزالتها من قائمة العقد المطلوب معالجتها (Q)."
  },
  {
    "question": "ما هو الشرط الأساسي للتأكد من صحة خوارزمية Dijkstra؟",
    "options": [
      "جميع الأوزان يجب أن تكون أعداداً صحيحة",
      "يجب أن يكون هناك مسار واحد فقط بين أي عقدتين",
      "جميع الأوزان يجب أن تكون غير سالبة",
      "يجب أن يكون المخطط شجراً"
    ],
    "correct": 2,
    "explanation": "الشرط الأساسي هو أن تكون جميع الأوزان غير سالبة (موجبة أو صفر)، لأن الأوزان السالبة قد تؤدي إلى حلول غير صحيحة أو دوائر لا نهائية."
  },
  {
    "question": "كيف يمكن إيجاد المسار الفعلي (ليس فقط طوله) بين المصدر والعقدة v؟",
    "options": [
      "باستخدام مصفوفة d فقط",
      "بإعادة تشغيل الخوارزمية",
      "بحساب متوسط الأوزان",
      "باستخدام مصفوفة pred للعودة إلى الوراء من v إلى المصدر"
    ],
    "correct": 3,
    "explanation": "باستخدام مصفوفة pred، يمكننا البدء من العقدة v والعودة عبر السلف pred[v] مراراً حتى نصل إلى المصدر، مما يعطينا المسار العكسي."
  },
  {
    "question": "ما هو التعقيد الزمني لخوارزمية Dijkstra باستخدام مصفوفة مجاورة؟",
    "options": [
      "O(V + E) حيث E عدد الحواف",
      "O(V²) حيث V عدد العقد",
      "O(E log V)",
      "O(V log V)"
    ],
    "correct": 1,
    "explanation": "باستخدام مصفوفة مجاورة، التعقيد الزمني لخوارزمية Dijkstra هو O(V²)، حيث V عدد العقد، لأننا نحتاج لفحص جميع العقد في كل خطوة."
  },
  {
    "question": "ماذا يعني أن d[v] = 5 بعد تنفيذ خوارزمية Dijkstra؟",
    "options": [
      "عدد الحواف من المصدر إلى v هو 5",
      "متوسط وزن الحواف إلى v هو 5",
      "v هي العقدة الخامسة في المخطط",
      "أقصر مسافة من المصدر إلى v هي 5"
    ],
    "correct": 3,
    "explanation": "d[v] = 5 يعني أن أقصر مسافة معروفة من عقدة المصدر إلى العقدة v هي 5 وحدات (بناءً على أوزان الحواف)."
  },
  {
    "question": "ما هو دور قائمة الانتظار Q في خوارزمية Dijkstra؟",
    "options": [
      "تخزين المسارات النهائية",
      "تخزين العقد المعالجة",
      "تخزين العقد التي لم تتم معالجتها بعد",
      "تخزين أوزان الحواف"
    ],
    "correct": 2,
    "explanation": "Q هي قائمة الانتظار (أو المجموعة) التي تحتوي على جميع العقد التي لم تتم معالجتها بعد، ويتم إزالة العقد منها واحدة تلو الأخرى بعد معالجتها."
  },
  {
    "question": "لماذا لا يمكن استخدام خوارزمية BFS لإيجاد أقصر مسار في مخطط موزون؟",
    "options": [
      "لأن BFS أبطأ من Dijkstra",
      "لأن BFS لا تتعامل مع العقد المتصلة",
      "لأن BFS تعمل فقط على المخططات الموجهة",
      "لأن BFS تعد الحواف فقط وليس الأوزان"
    ],
    "correct": 3,
    "explanation": "خوارزمية BFS تعتبر جميع الحواف متساوية الوزن (وزن 1 لكل حافة)، لذلك لا يمكنها التعامل مع الأوزان المختلفة في المخطط الموزون."
  },
  {
    "question": "ما هو الشرط الذي يجب تحقيقه عند معالجة جوارات العقدة u؟",
    "options": [
      "يجب أن تكون العقدة المجاورة v معالجة مسبقاً",
      "يجب أن تكون العقدة المجاورة v غير معالجة بعد",
      "يجب أن يكون وزن الحافة سالباً",
      "يجب أن تكون v أبعد من u"
    ],
    "correct": 1,
    "explanation": "عند معالجة جوارات العقدة u، نفحص فقط العقد المجاورة التي لم تتم معالجتها بعد، لأن العقد المعالجة لها بالفعل أقصر مسار معروف."
  },
  {
    "question": "ماذا يحدث إذا كانت هناك حافة ذات وزن سالب في المخطط؟",
    "options": [
      "تصبح الخوارزمية أسرع",
      "يتم تجاهل الوزن السالب",
      "خوارزمية Dijkstra قد تعطي نتائج غير صحيحة",
      "تتحول الأوزان السالبة إلى موجبة تلقائياً"
    ],
    "correct": 2,
    "explanation": "وجود أوزان سالبة يجعل خوارزمية Dijkstra غير مناسبة، وقد تعطي نتائج غير صحيحة، ويجب استخدام خوارزميات أخرى مثل Bellman-Ford."
  },
  {
    "question": "ما هي قيمة d[s] في بداية خوارزمية Dijkstra؟",
    "options": [
      "∞",
      "0",
      "1",
      "-1"
    ],
    "correct": 1,
    "explanation": "d[s] = 0 حيث s هي عقدة المصدر، لأن المسافة من المصدر إلى نفسها تساوي صفر."
  },
  {
    "question": "ما هي قيمة pred[s] في بداية خوارزمية Dijkstra؟",
    "options": [
      "s",
      "null",
      "∞",
      "0"
    ],
    "correct": 1,
    "explanation": "pred[s] = null لأن عقدة المصدر ليس لها سلف في المسار، فهي نقطة البداية."
  },
  {
    "question": "ما هو الشرط الذي يجعلنا نوقف خوارزمية Dijkstra؟",
    "options": [
      "عندما نصل إلى عقدة محددة مسبقاً",
      "عندما تصبح Q فارغة (جميع العقد معالجة)",
      "عندما نمر بعدد محدد من الخطوات",
      "عندما تصبح جميع المسافات سالبة"
    ],
    "correct": 1,
    "explanation": "تستمر الخوارزمية في التنفيذ طالما أن هناك عقداً لم تتم معالجتها في Q، وعندما تصبح Q فارغة، تكون جميع العقد قد عولجت."
  },
  {
    "question": "لماذا نستخدم extract-min(Q) في خوارزمية Dijkstra؟",
    "options": [
      "لاستخراج العقدة ذات أكبر مسافة معروفة",
      "لاستخراج العقدة الأولى في Q",
      "لاستخراج عقدة عشوائية من Q",
      "لاستخراج العقدة ذات أقل مسافة معروفة من Q"
    ],
    "correct": 3,
    "explanation": "يجب اختيار العقدة ذات أقل مسافة معروفة (d[u]) في كل خطوة لضمان أننا نجد المسار الأقصر أولاً (مبدأ الجشعية)."
  },
  {
    "question": "ما هو المبدأ الأساسي الذي تعتمد عليه خوارزمية Dijkstra؟",
    "options": [
      "مبدأ التقسيم والتغلب (Divide and Conquer)",
      "مبدأ البرمجة الديناميكية (Dynamic Programming)",
      "مبدأ الجشعية (Greedy)",
      "مبدأ البحث الشامل (Brute Force)"
    ],
    "correct": 2,
    "explanation": "تعتمد خوارزمية Dijkstra على مبدأ الجشعية، حيث تختار في كل خطوة العقدة ذات المسافة الأقل معتقدة أن هذا سيؤدي إلى الحل الأمثل."
  },
  {
    "question": "ما هو الفرق بين Dijkstra وBFS في حساب طول المسار؟",
    "options": [
      "كلاهما يجمع أوزان الحواف",
      "BFS تجمع أوزان الحواف، Dijkstra تعد الحواف",
      "Dijkstra تجمع أوزان الحواف، BFS تعد الحواف",
      "كلاهما يعد الحواف فقط"
    ],
    "correct": 2,
    "explanation": "Dijkstra تحسب طول المسار كمجموع أوزان الحواف، بينما BFS تحسبه كعدد الحواف (بافتراض وزن 1 لكل حافة)."
  },
  {
    "question": "ما هو أول إجراء في خوارزمية Dijkstra؟",
    "options": [
      "فرز الحواف حسب الوزن",
      "تهيئة جميع d[u] = ∞ و d[s] = 0",
      "اختيار عقدة عشوائية لبدء الخوارزمية",
      "حساب جميع المسارات الممكنة"
    ],
    "correct": 1,
    "explanation": "أول إجراء هو التهيئة: تعيين مسافة لا نهائية لجميع العدد (∞) وتعيين مسافة صفر لعقدة المصدر."
  },
  {
    "question": "ما هو التطبيق العملي الشهير لخوارزمية Dijkstra؟",
    "options": [
      "ضغط البيانات",
      "فرز الملفات حسب الحجم",
      "أنظمة الملاحة مثل خرائط جوجل",
      "التشفير والأمان"
    ],
    "correct": 2,
    "explanation": "تستخدم خوارزمية Dijkstra بشكل واسع في أنظمة الملاحة والخرائط الرقمية (مثل Google Maps) لإيجاد أقصر طريق بين موقعين."
  },
  {
    "question": "ماذا يحدث إذا أردنا إيجاد أقصر مسار بين عقدتين غير المصدر؟",
    "options": [
      "نستخدم نفس النتائج مع عقدة المصدر الأصلية",
      "نعيد تشغيل الخوارزمية مع جعل إحدى العقدتين مصدراً",
      "نقوم بقلب اتجاه جميع الحواف",
      "نضيف العقدتين فقط إلى المخطط"
    ],
    "correct": 1,
    "explanation": "للحصول على أقصر مسار بين عقدتين A وB، نطبق Dijkstra مع جعل A كعقدة مصدر، ثم ننظر إلى d[B] وpred[B]."
  },
  {
    "question": "ما هو الشرط الذي يضمن أن العقدة قد وجدت أقصر مسار لها؟",
    "options": [
      "عندما تكون أول عقدة في Q",
      "عندما يتم معالجتها وإزالتها من Q",
      "عندما يكون d[u] = 0",
      "عندما يكون pred[u] = null"
    ],
    "correct": 1,
    "explanation": "عندما يتم استخراج عقدة من Q ومعالجتها، نكون قد وجدنا أقصر مسار إليها (بسبب مبدأ الجشعية وافتراض الأوزان الموجبة)."
  },
  {
    "question": "كيف يتم تمثيل حالة العقدة في خوارزمية Dijkstra؟",
    "options": [
      "باستخدام الحرف الأول من اسم العقدة",
      "باستخدام رقم عشوائي",
      "باستخدام متغير لون (مثلاً: أبيض، أسود)",
      "باستخدام وزن العقدة"
    ],
    "correct": 2,
    "explanation": "غالباً ما تستخدم الألوان لتمثيل حالة العقدة: أبيض (لم تتم زيارتها)، رمادي (قيد المعالجة)، أسود (تمت معالجتها)."
  },
  {
    "question": "ما هو الخطأ الشائع في فهم خوارزمية Dijkstra؟",
    "options": [
      "أنها أسرع خوارزمية لإيجاد أقصر مسار",
      "أنها تعمل فقط مع المخططات غير الموجهة",
      "أنها تعمل مع الأوزان السالبة",
      "أنها تحتاج إلى مصفوفة كبيرة"
    ],
    "correct": 2,
    "explanation": "الخطأ الشائع هو الاعتقاد أن Dijkstra تعمل مع الأوزان السالبة، بينما في الواقع تتطلب جميع الأوزان أن تكون غير سالبة."
  },
  {
    "question": "لماذا تعتبر خوارزمية Dijkstra كفؤة؟",
    "options": [
      "لأنها تستخدم ذاكرة قليلة جداً",
      "لأنها لا تحتاج إلى مقارنات",
      "لأنها تعمل بسرعة ثابتة",
      "لأنها لا تفحص جميع المسارات الممكنة"
    ],
    "correct": 3,
    "explanation": "تعتبر كفؤة لأنها تستخدم مبدأ الجشعية لتجنب فحص جميع المسارات الممكنة، مما يقلل من عدد العمليات المطلوبة."
  },
  {
    "question": "ماذا يعني أن المخطط 'متصل' (connected)؟",
    "options": [
      "جميع الحواف لها نفس الوزن",
      "يوجد مسار بين أي عقدتين في المخطط",
      "جميع العدد لها نفس عدد الجوارات",
      "لا توجد دوائر في المخطط"
    ],
    "correct": 1,
    "explanation": "المخطط المتصل هو الذي يوجد فيه مسار بين أي عقدتين، مما يضمن إمكانية الوصول من المصدر إلى جميع العقد الأخرى."
  },
  {
    "question": "كيف يمكن تحسين أداء خوارزمية Dijkstra؟",
    "options": [
      "بتجاهل بعض العقد",
      "باستخدام مصفوفة أكبر",
      "باستخدام كومة (Heap) بدلاً من قائمة بسيطة",
      "باستخدام أوزان عشوائية"
    ],
    "correct": 2,
    "explanation": "يمكن تحسين الأداء باستخدام بنية بيانات فعالة مثل كومة الأولوية (Priority Queue/Heap) لتخزين العقد، مما يقلل التعقيد إلى O(E log V)."
  },
  {
    "question": "ما هي المعلومة التي لا توفرها خوارزمية Dijkstra؟",
    "options": [
      "طول أقصر مسار من المصدر إلى كل عقدة",
      "أقصر مسارات من مصدر واحد إلى جميع العقد",
      "أقصر مسارات بين جميع أزواج العقد",
      "مسار أقصر من المصدر إلى كل عقدة"
    ],
    "correct": 2,
    "explanation": "Dijkstra توفر أقصر مسارات من عقدة مصدر واحدة إلى جميع العقد الأخرى، وليس أقصر مسارات بين جميع أزواج العقد (مما يتطلب خوارزميات أخرى مثل Floyd-Warshall)."
  },
  {
    "question": "ماذا يحدث إذا كان هناك عدة مسارات بنفس الطول الأقصر؟",
    "options": [
      "تدمج جميع المسارات",
      "توقف الخوارزمية عن العمل",
      "تختار أطول مسار منهم",
      "قد تختار الخوارزمية أي منهم اعتماداً على الترتيب"
    ],
    "correct": 3,
    "explanation": "إذا كان هناك عدة مسارات بنفس الطول الأقصر، فقد تختار الخوارزمية أي منهم حسب ترتيب المعالجة، وعادةً ما يظهر الأول الذي تم اكتشافه."
  },
  {
    "question": "ما هو الشرط الذي يضمن أن خوارزمية Dijkstra ستعمل بشكل صحيح؟",
    "options": [
      "جميع الأوزان أعداد صحيحة",
      "المخطط غير موجه",
      "عدد العقد أقل من 100",
      "جميع الأوزان غير سالبة والمخطط متصل"
    ],
    "correct": 3,
    "explanation": "الشرطين الأساسيين هما: 1) جميع أوزان الحواف غير سالبة (≥ 0)، 2) المخطط متصل (أو على الأقل يمكن الوصول من المصدر إلى جميع العقد المطلوبة)."
  },
  {
    "question": "ما هو الغرض من color[u] في تنفيذ خوارزمية Dijkstra؟",
    "options": [
      "لتحديد لون العرض للعقدة",
      "لتتبع حالة العقدة (معالجة/غير معالجة)",
      "لتحديد اتجاه العقدة",
      "لتخزين وزن العقدة"
    ],
    "correct": 1,
    "explanation": "يستخدم color[u] لتتبع حالة العقدة: عادةً أبيض (غير مزار)، رمادي (قيد المعالجة)، أسود (تمت معالجتها)."
  },
  {
    "question": "كيف نعرف أن العقدة قد وصلت إلى أقصر مسار ممكن؟",
    "options": [
      "عندما يكون d[u] = 0",
      "عندما تكون العقدة الأولى في المخطط",
      "عندما يتم استخراجها من Q باستخدام extract-min",
      "عندما يكون pred[u] = u"
    ],
    "correct": 2,
    "explanation": "عند استخراج عقدة من Q باستخدام extract-min (أي أنها الأقرب بين العقد غير المعالجة)، نكون قد وجدنا أقصر مسار إليها بسبب مبدأ الجشعية."
  }



  ]
            }
        }
    };

    let currentQuestion = 0;
    let userAnswers = [];
    let score = 0;
    let timer;
    let timeLeft = 20 * 60;
    let questions = [];

    // عناصر DOM
    const startScreen = document.getElementById('start-screen');
    const subjectScreen = document.getElementById('subject-screen');
    const lectureScreen = document.getElementById('lecture-screen');
    const examScreen = document.getElementById('exam-screen');
    const resultScreen = document.getElementById('result-screen');
    const startBtn = document.getElementById('start-btn');
    const timerDisplay = document.getElementById('timer');
    const currentQDisplay = document.getElementById('current-q');
    const scoreDisplay = document.getElementById('score');
    const questionText = document.getElementById('question-text');
    const optionsContainer = document.getElementById('options-container');
    const prevBtn = document.getElementById('prev-btn');
    const nextBtn = document.getElementById('next-btn');
    const submitBtn = document.getElementById('submit-btn');
    const correctSound = document.getElementById('correct-sound');
    const wrongSound = document.getElementById('wrong-sound');
    const correctCountDisplay = document.getElementById('correct-count');
    const wrongCountDisplay = document.getElementById('wrong-count');
    const skippedCountDisplay = document.getElementById('skipped-count');
    const finalScoreDisplay = document.getElementById('final-score');
    const answersReview = document.getElementById('answers-review');
    const restartBtn = document.getElementById('restart-btn');
    const homeBtn = document.getElementById('home-btn');
    const subjectList = document.getElementById('subject-list');
    const lectureList = document.getElementById('lecture-list');
    const lectureTitle = document.getElementById('lecture-title');
    const backSubjectsBtn = document.getElementById('back-subjects');

    // ===================== وظائف اختيار المادة والمحاضرة =====================
    function showSubjects() {
        subjectList.innerHTML = '';
        Object.keys(subjects).forEach(subKey => {
            const sub = subjects[subKey];
            const btn = document.createElement('button');
            btn.textContent = sub.name;
            btn.className = 'btn-subject';
            btn.addEventListener('click', () => showLectures(subKey));
            subjectList.appendChild(btn);
        });
        startScreen.classList.remove('active');
        subjectScreen.classList.add('active');
    }

   function showLectures(subKey) {
    const sub = subjects[subKey];
    lectureTitle.textContent = sub.name;
    lectureList.innerHTML = '';

    // زر الفحص الشامل لجميع المحاضرات
    const fullExamBtn = document.createElement('button');
    fullExamBtn.textContent = `فحص شامل لجميع المحاضرات`;
    fullExamBtn.className = 'btn-lecture';
    fullExamBtn.addEventListener('click', () => startFullExam(subKey));
    lectureList.appendChild(fullExamBtn);

    // عرض المحاضرات العادية
    Object.keys(sub.lectures).forEach(lecKey => {
        const btn = document.createElement('button');
        btn.textContent = `المحاضرة ${lecKey.replace('lec','')}`;
        btn.className = 'btn-lecture';
        btn.addEventListener('click', () => startLecture(subKey, lecKey));
        lectureList.appendChild(btn);
    });

    subjectScreen.classList.remove('active');
    lectureScreen.classList.add('active');
}

// وظيفة فحص شامل لجميع المحاضرات
function startFullExam(subKey) {
    const allLectures = subjects[subKey].lectures;
    let allQuestions = [];
    Object.values(allLectures).forEach(lec => {
        allQuestions = allQuestions.concat(lec);
    });

    questions = shuffleArray(allQuestions).slice(0, 20); // نأخذ 20 سؤال عشوائي
    userAnswers = new Array(questions.length).fill(-1);
    currentQuestion = 0;
    score = 0;
    timeLeft = 20 * 60;
    scoreDisplay.textContent = '0';
    timerDisplay.textContent = '20:00';
    timerDisplay.classList.remove('timer-warning', 'timer-danger');

    lectureScreen.classList.remove('active');
    examScreen.classList.add('active');
    startTimer();
    displayQuestion(0);
}


    backSubjectsBtn.addEventListener('click', () => {
        lectureScreen.classList.remove('active');
        subjectScreen.classList.add('active');
    });

    function startLecture(subKey, lecKey) {
        const allQuestions = subjects[subKey].lectures[lecKey];
        questions = shuffleArray(allQuestions).slice(0, 20);
        userAnswers = new Array(questions.length).fill(-1);
        currentQuestion = 0;
        score = 0;
        timeLeft = 20 * 60;
        scoreDisplay.textContent = '0';
        timerDisplay.textContent = '20:00';
        timerDisplay.classList.remove('timer-warning', 'timer-danger');

        lectureScreen.classList.remove('active');
        examScreen.classList.add('active');
        startTimer();
        displayQuestion(0);
    }

    function shuffleArray(array) {
        let arr = array.slice();
        for (let i = arr.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [arr[i], arr[j]] = [arr[j], arr[i]];
        }
        return arr;
    }

    // ===================== وظائف الاختبار =====================
    function startTimer() {
        clearInterval(timer);
        timer = setInterval(() => {
            timeLeft--;
            const minutes = Math.floor(timeLeft / 60);
            const seconds = timeLeft % 60;
            timerDisplay.textContent = `${minutes.toString().padStart(2,'0')}:${seconds.toString().padStart(2,'0')}`;
            if(timeLeft <= 60) timerDisplay.classList.add('timer-danger');
            else if(timeLeft <= 300) timerDisplay.classList.add('timer-warning');
            if(timeLeft <= 0){ clearInterval(timer); finishExam(); }
        },1000);
    }

    function displayQuestion(index){
        currentQuestion = index;
        const q = questions[index];
        currentQDisplay.textContent = index + 1;
        questionText.textContent = q.question;
        optionsContainer.innerHTML = '';
        q.options.forEach((opt,i)=>{
            const btn = document.createElement('button');
            btn.textContent = opt;
            btn.className = 'option-btn';
            if(userAnswers[index]===i) btn.classList.add('selected');
            btn.addEventListener('click', ()=> selectOption(i));
            optionsContainer.appendChild(btn);
        });
        prevBtn.disabled = index===0;
        nextBtn.disabled = index===questions.length-1;
    }

function selectOption(optionIndex) {
    // إذا الجواب موجود بالفعل ما في تعديل
    if (userAnswers[currentQuestion] !== -1) return;

    // حفظ الإجابة
    userAnswers[currentQuestion] = optionIndex;

    const options = document.querySelectorAll('.option-btn');

    const isCorrect = optionIndex === questions[currentQuestion].correct;

    options.forEach((btn, i) => {
        btn.classList.remove('selected');

        if (i === optionIndex) {
            btn.classList.add('selected');
        }

        // تلوين الإجابة الصحيحة والخاطئة
        if (i === questions[currentQuestion].correct) {
            btn.classList.add('correct-answer'); // أخضر
        } else if (i === optionIndex && !isCorrect) {
            btn.classList.add('wrong-answer'); // أحمر
        }

        // تعطيل الخيارات فقط، مش زر التالي
        btn.disabled = true;
    });

    // الأصوات
    if (isCorrect) {
        playSound('correct');
        score++;
        scoreDisplay.textContent = score;

        // انتقال تلقائي بعد نص ثانية
        setTimeout(() => {
            if (currentQuestion < questions.length - 1) {
                displayQuestion(currentQuestion + 1);
            } else {
                finishExam();
            }
        }, 500);
    } else {
        // إذا غلط، صوت خطأ، واللاعب يضغط "التالي" بنفسه
        playSound('wrong');
        nextBtn.disabled = false; // تأكد أن زر التالي مفعل
    }
}



    prevBtn.addEventListener('click', ()=> {
        if(currentQuestion>0) displayQuestion(currentQuestion-1);
    });

    nextBtn.addEventListener('click', ()=> {
        if(currentQuestion<questions.length-1) displayQuestion(currentQuestion+1);
    });

    submitBtn.addEventListener('click', ()=> {
        if(confirm("هل أنت متأكد من إنهاء الاختبار؟")) finishExam();
    });

    function finishExam(){
        clearInterval(timer);
        let correct=0,wrong=0,skipped=0;
        questions.forEach((q,i)=>{
            if(userAnswers[i]===-1) skipped++;
            else if(userAnswers[i]===q.correct) correct++;
            else wrong++;
        });
        const finalScore = Math.round((correct/questions.length)*100);
        correctCountDisplay.textContent = correct;
        wrongCountDisplay.textContent = wrong;
        skippedCountDisplay.textContent = skipped;
        finalScoreDisplay.textContent = finalScore+'%';
        answersReview.innerHTML = '';
        questions.forEach((q,i)=>{
            const div = document.createElement('div');
            div.className='answer-item';
            let status='skipped', statusText='غير مجاب', userAnswerText='لم تجب';
            if(userAnswers[i]!==-1){
                userAnswerText=q.options[userAnswers[i]];
                if(userAnswers[i]===q.correct){ status='correct'; statusText='صحيح'; }
                else { status='wrong'; statusText='خطأ'; }
            }
            div.classList.add(status);
            div.innerHTML = `<strong>سؤال ${i+1}:</strong> ${q.question}<br>
            إجابتك: ${userAnswerText}<br>
            الإجابة الصحيحة: ${q.options[q.correct]}<br>
            الحالة: ${statusText}<br>
            شرح: ${q.explanation}`;
            answersReview.appendChild(div);
        });

        examScreen.classList.remove('active');
        resultScreen.classList.add('active');

        if(finalScore>=70) playSound('correct'); else playSound('wrong');
    }

    restartBtn.addEventListener('click', ()=>{
        currentQuestion=0; userAnswers=[]; score=0; timeLeft=20*60;
        scoreDisplay.textContent='0'; timerDisplay.textContent='20:00';
        timerDisplay.classList.remove('timer-warning','timer-danger');
        resultScreen.classList.remove('active'); startScreen.classList.add('active');
    });

    homeBtn.addEventListener('click', ()=>{
        resultScreen.classList.remove('active'); startScreen.classList.add('active');
    });

    function playSound(type){
        if(type==='correct'){ correctSound.currentTime=0; correctSound.play(); }
        else if(type==='wrong'){ wrongSound.currentTime=0; wrongSound.play(); }
    }

    startBtn.addEventListener('click', showSubjects);
