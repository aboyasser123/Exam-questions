
    // ===
    // 
    
    
    // ================== البيانات =====================
    const subjects = {
        رسوميات :{
          name:"رسوميات حاسوبية ",
          lectures:{

          }

        },
          algo2: {
            name: "خوارزميات 2",
            lectures: {
                lec1:  [
  {
    "question": "في الكود التالي، ما وظيفة السطر: mid = (low + high) / 2 ؟",
    "options": [
      "حساب حجم المصفوفة",
      "حساب دليل المنتصف لتجزئة المصفوفة",
      "إيجاد أكبر عنصر",
      "إيقاف التعاودية"
    ],
    "correct": 1,
    "explanation": "يحسب هذا السطر موقع المنتصف الذي يتم عنده تقسيم المصفوفة إلى جزأين."
  },
  {
    "question": "في السطر mergeSort(low, mid, t); ما الهدف منه؟",
    "options": [
      "دمج النصفين",
      "ترتيب الجزء الأول من المصفوفة",
      "ترتيب الجزء الثاني",
      "نسخ المصفوفة"
    ],
    "correct": 1,
    "explanation": "يتم استدعاء التابع لترتيب النصف الأول من المصفوفة."
  },
  {
    "question": "في السطر mergeSort(mid + 1, high, t); ما وظيفته؟",
    "options": [
      "ترتيب الجزء الثاني من المصفوفة",
      "دمج النصفين",
      "حساب mid",
      "إيقاف التعاودية"
    ],
    "correct": 0,
    "explanation": "يتم استدعاء التابع لترتيب النصف الثاني من المصفوفة."
  },
  {
    "question": "ما وظيفة السطر merge(low, mid, high, t);",
    "options": [
      "حساب mid",
      "دمج النصفين مع ترتيب",
      "تجزئة المصفوفة",
      "إيقاف التعاودية"
    ],
    "correct": 1,
    "explanation": "هذا السطر يقوم بدمج النصفين بعد أن تم ترتيبهما."
  },
  {
    "question": "في تابع merge، ما معنى السطر i = low; ؟",
    "options": [
      "بدء قراءة الجزء الأول من المصفوفة",
      "بدء قراءة الجزء الثاني",
      "بدء المصفوفة المساعدة",
      "تحديد نهاية الدمج"
    ],
    "correct": 0,
    "explanation": "يشير i إلى بداية الجزء الأول من المصفوفة."
  },
  {
    "question": "في تابع merge، ما معنى السطر j = mid + 1; ؟",
    "options": [
      "بداية الجزء الأول",
      "بداية الجزء الثاني",
      "بداية المصفوفة المساعدة",
      "نهاية المصفوفة"
    ],
    "correct": 1,
    "explanation": "يشير j إلى بداية الجزء الثاني من المصفوفة."
  },
  {
    "question": "في تابع merge، ما معنى السطر k = low; ؟",
    "options": [
      "بداية المصفوفة المساعدة",
      "بداية الجزء الأول",
      "بداية الجزء الثاني",
      "نهاية المصفوفة"
    ],
    "correct": 0,
    "explanation": "يشير k إلى بداية المصفوفة المساعدة."
  },
  {
    "question": "في الكود: while (i <= mid && j <= high) ماذا تعني هذه الحلقة؟",
    "options": [
      "تنفيذ الدمج طالما يوجد عناصر في الجزأين",
      "تنفيذ الدمج لجزء واحد فقط",
      "إيقاف الدمج",
      "حساب المنتصف"
    ],
    "correct": 0,
    "explanation": "تستمر الحلقة طالما يوجد عناصر غير معالجة في كلا الجزأين."
  },
  {
    "question": "في السطر aux[k] = t[i]; ماذا يحدث؟",
    "options": [
      "نسخ عنصر من الجزء الأول إلى المصفوفة المساعدة",
      "نسخ عنصر من الجزء الثاني",
      "تبديل القيم",
      "حذف العنصر"
    ],
    "correct": 0,
    "explanation": "يتم نقل العنصر الحالي من الجزء الأول إلى المصفوفة المساعدة."
  },
  {
    "question": "في السطر aux[k] = t[j]; ماذا يحدث؟",
    "options": [
      "نسخ عنصر من الجزء الثاني إلى المصفوفة المساعدة",
      "نسخ عنصر من الجزء الأول",
      "إيقاف الدمج",
      "تبديل العناصر"
    ],
    "correct": 0,
    "explanation": "يتم نقل العنصر الحالي من الجزء الثاني إلى المصفوفة المساعدة."
  },
  {
    "question": "لماذا نزيد k بعد كل عملية نسخ إلى aux؟",
    "options": [
      "للانتقال إلى الخلية التالية في المصفوفة المساعدة",
      "لإيقاف الحلقة",
      "لحساب mid",
      "لمقارنة العناصر"
    ],
    "correct": 0,
    "explanation": "k يشير إلى موقع الإدخال في المصفوفة المساعدة ويجب تحريكه بعد كل إدخال."
  },
  {
    "question": "متى يتم تنفيذ الحلقة while (i <= mid)؟",
    "options": [
      "عند انتهاء عناصر الجزء الثاني",
      "عند انتهاء عناصر الجزء الأول",
      "في بداية الدمج",
      "عند حساب mid"
    ],
    "correct": 0,
    "explanation": "تُستخدم عندما تنتهي عناصر الجزء الثاني ويبقى عناصر في الجزء الأول."
  },
  {
    "question": "متى يتم تنفيذ الحلقة while (j <= high)؟",
    "options": [
      "عند انتهاء عناصر الجزء الأول",
      "عند بداية الدمج",
      "عند حساب mid",
      "عند إيقاف التعاودية"
    ],
    "correct": 0,
    "explanation": "تُستخدم عندما تنتهي عناصر الجزء الأول ويبقى عناصر في الجزء الثاني."
  },
  {
    "question": "ما وظيفة الحلقة: while (i <= high) { t[i] = aux[i]; i++; } ؟",
    "options": [
      "نسخ المصفوفة المساعدة إلى المصفوفة الأصلية",
      "حساب mid",
      "إعادة التعاودية",
      "دمج الأجزاء"
    ],
    "correct": 0,
    "explanation": "تقوم بنقل القيم المرتبة من المصفوفة المساعدة إلى المصفوفة الأصلية."
  },
  {
    "question": "ما نوع خوارزمية Merge Sort من حيث التعاودية؟",
    "options": [
      "غير تعاودية",
      "تعاودية",
      "عشوائية",
      "خطية"
    ],
    "correct": 1,
    "explanation": "Merge Sort تعتمد على استدعاء نفسها لتقسيم المشكلة."
  },
  {
    "question": "لماذا يكون شرط التوقف low == high؟",
    "options": [
      "لأن المصفوفة أصبحت بعنصر واحد",
      "لأن المصفوفة فارغة",
      "لأن mid أصبح صفر",
      "لأن الترتيب انتهى"
    ],
    "correct": 0,
    "explanation": "عندما low يساوي high فهذا يعني أن الجزء يحتوي على عنصر واحد ولا يحتاج تقسيم."
  },
  {
    "question": "ما الذي يحدث قبل تنفيذ merge في mergeSort؟",
    "options": [
      "يتم ترتيب النصفين أولاً",
      "يتم حساب mid فقط",
      "يتم إيقاف التعاودية",
      "يتم حذف العناصر"
    ],
    "correct": 0,
    "explanation": "يتم أولاً ترتيب الجزأين باستخدام التعاودية ثم دمجهما."
  },
  {
    "question": "لماذا نحتاج إلى مصفوفة aux؟",
    "options": [
      "لتخزين القيم المؤقتة أثناء الدمج",
      "لحساب mid",
      "لتقليل عدد العناصر",
      "لإيقاف التعاودية"
    ],
    "correct": 0,
    "explanation": "المصفوفة aux تستخدم لحفظ القيم المرتبة مؤقتاً أثناء الدمج."
  },
  {
    "question": "إذا كان low = 4 و high = 7، فما قيمة mid؟",
    "options": [
      "4",
      "5",
      "6",
      "7"
    ],
    "correct": 1,
    "explanation": "mid = (4 + 7) / 2 = 5."
  },
  {
    "question": "أي من التالي يمثل الخطوة الأخيرة في merge؟",
    "options": [
      "نسخ المصفوفة المساعدة إلى المصفوفة الأصلية",
      "حساب mid",
      "مقارنة i و j",
      "استدعاء mergeSort"
    ],
    "correct": 0,
    "explanation": "بعد اكتمال الدمج يتم نسخ aux إلى المصفوفة الأصلية."
  }
,





  {
    "question": "ما الفكرة الأساسية التي تعتمد عليها خوارزمية Merge Sort؟",
    "options": [
      "تقسيم المصفوفة إلى أجزاء صغيرة ثم دمجها بترتيب",
      "مقارنة كل عنصر مع جميع العناصر الأخرى",
      "اختيار أصغر عنصر ووضعه في البداية",
      "استخدام التبديل المباشر بين العناصر"
    ],
    "correct": 0,
    "explanation": "تعتمد Merge Sort على مبدأ Divide and Conquer حيث يتم تجزئة المصفوفة إلى أجزاء صغيرة ثم دمجها مع ترتيب."
  },
  {
    "question": "ما شرط التوقف (Base Case) في خوارزمية Merge Sort؟",
    "options": [
      "low != high",
      "low == high",
      "mid == low",
      "mid == high"
    ],
    "correct": 1,
    "explanation": "تتوقف التعاودية عندما يصبح دليل البداية مساوياً لدليل النهاية أي أن المصفوفة تحتوي على عنصر واحد."
  },
  {
    "question": "كيف يتم حساب دليل المنتصف mid في خوارزمية Merge Sort؟",
    "options": [
      "mid = low * high",
      "mid = (low + high) / 2",
      "mid = high - low",
      "mid = (high - low) / 2"
    ],
    "correct": 1,
    "explanation": "يتم حساب mid بجمع دليل البداية والنهاية ثم قسمتهما على 2."
  },
  {
    "question": "ما وظيفة التابع mergeSort(low, high, T)؟",
    "options": [
      "دمج المصفوفة فقط",
      "فرز جزء من المصفوفة باستخدام التعاودية",
      "نسخ المصفوفة إلى مصفوفة مساعدة",
      "إيجاد أكبر عنصر في المصفوفة"
    ],
    "correct": 1,
    "explanation": "الـ mergeSort تابع تعاودي مسؤول عن تجزئة المصفوفة وترتيب أجزائها."
  },
  {
    "question": "كم عدد البارامترات التي يستقبلها تابع mergeSort؟",
    "options": [
      "بارامتر واحد",
      "بارامتران",
      "ثلاثة بارامترات",
      "أربعة بارامترات"
    ],
    "correct": 2,
    "explanation": "يستقبل mergeSort دليل البداية ودليل النهاية واسم المصفوفة."
  },
  {
    "question": "ما وظيفة التابع merge(low, mid, high, T)؟",
    "options": [
      "تجزئة المصفوفة",
      "دمج جزأين من المصفوفة مع الترتيب",
      "إيجاد المنتصف",
      "إيقاف التعاودية"
    ],
    "correct": 1,
    "explanation": "الـ merge مسؤول عن دمج الجزأين الناتجين من التجزئة مع ترتيب العناصر."
  },
  {
    "question": "كم عدد البارامترات التي يستقبلها تابع merge؟",
    "options": [
      "2",
      "3",
      "4",
      "5"
    ],
    "correct": 2,
    "explanation": "يستقبل merge دليل البداية، دليل المنتصف، دليل النهاية، واسم المصفوفة."
  },
  {
    "question": "أي شرط يُستخدم لمتابعة التجزئة في mergeSort؟",
    "options": [
      "if (low == high)",
      "if (low <= high)",
      "if (low != high)",
      "if (mid == high)"
    ],
    "correct": 2,
    "explanation": "يتم الاستمرار بالتجزئة طالما low لا يساوي high."
  },
  {
    "question": "في تابع merge، ما وظيفة العداد i؟",
    "options": [
      "مؤشر المصفوفة المساعدة",
      "مؤشر بداية الجزء الأول",
      "مؤشر بداية الجزء الثاني",
      "مؤشر نهاية المصفوفة"
    ],
    "correct": 1,
    "explanation": "العداد i يشير إلى بداية الجزء الأول من المصفوفة."
  },
  {
    "question": "في تابع merge، ما وظيفة العداد j؟",
    "options": [
      "بداية الجزء الأول",
      "نهاية الجزء الأول",
      "بداية الجزء الثاني",
      "المصفوفة المساعدة"
    ],
    "correct": 2,
    "explanation": "العداد j يشير إلى بداية الجزء الثاني من المصفوفة (mid + 1)."
  },
  {
    "question": "في تابع merge، ما وظيفة العداد k؟",
    "options": [
      "مؤشر المصفوفة الأصلية",
      "مؤشر المصفوفة المساعدة",
      "مؤشر المنتصف",
      "عداد الحلقة الخارجية"
    ],
    "correct": 1,
    "explanation": "العداد k يستخدم للتعامل مع المصفوفة المساعدة."
  },
  {
    "question": "اختر الشرط الصحيح لحلقة الدمج الرئيسية:",
    "options": [
      "while (i < mid || j < high)",
      "while (i <= mid && j <= high)",
      "while (i >= mid && j >= high)",
      "while (i != j)"
    ],
    "correct": 1,
    "explanation": "يجب أن يكون كلا الجزأين يحتويان على عناصر ليتم الدمج."
  },
  {
    "question": "ماذا يحدث إذا كان t[i] < t[j] داخل حلقة الدمج؟",
    "options": [
      "ننسخ t[j] إلى aux",
      "ننسخ t[i] إلى aux ونزيد i و k",
      "نزيد j فقط",
      "نتوقف عن الدمج"
    ],
    "correct": 1,
    "explanation": "يتم نقل العنصر الأصغر من الجزء الأول إلى المصفوفة المساعدة."
  },
  {
    "question": "ماذا يحدث إذا كان t[i] > t[j] داخل حلقة الدمج؟",
    "options": [
      "ننسخ t[i]",
      "ننسخ t[j] ونزيد j و k",
      "نزيد i فقط",
      "ننسخ العنصرين معاً"
    ],
    "correct": 1,
    "explanation": "يتم نقل العنصر الأصغر من الجزء الثاني إلى المصفوفة المساعدة."
  },
  {
    "question": "في حال تساوي t[i] و t[j] ماذا يحدث؟",
    "options": [
      "يتم تجاهل أحد العنصرين",
      "يتم نقل كلا العنصرين وزيادة العدادات",
      "يتم كسر الحلقة",
      "يتم تبديل القيم"
    ],
    "correct": 1,
    "explanation": "يتم نقل كلا العنصرين إلى المصفوفة المساعدة وزيادة العدادات i و j و k بمقدار 2."
  },
  {
    "question": "لماذا نستخدم مصفوفة مساعدة في Merge Sort؟",
    "options": [
      "لتقليل عدد المقارنات",
      "لتخزين النتائج المؤقتة أثناء الدمج",
      "لإيقاف التعاودية",
      "لحساب mid"
    ],
    "correct": 1,
    "explanation": "الدمج يحتاج مصفوفة مساعدة لتخزين القيم المرتبة مؤقتاً."
  },
  {
    "question": "ما الهدف من الحلقة while (i <= mid) بعد انتهاء الدمج الأساسي؟",
    "options": [
      "دمج عناصر الجزء الثاني",
      "نسخ العناصر المتبقية من الجزء الأول",
      "إعادة حساب mid",
      "إيقاف الخوارزمية"
    ],
    "correct": 1,
    "explanation": "تُستخدم لنقل العناصر المتبقية من الجزء الأول في حال انتهاء الجزء الثاني."
  },
  {
    "question": "ما الهدف من الحلقة while (j <= high)؟",
    "options": [
      "نسخ عناصر الجزء الثاني المتبقية",
      "فرز الجزء الأول",
      "تحديث mid",
      "إيقاف الدمج"
    ],
    "correct": 0,
    "explanation": "تُستخدم لنقل العناصر المتبقية من الجزء الثاني."
  },
  {
    "question": "ما الغاية من نسخ المصفوفة المساعدة إلى المصفوفة الأصلية؟",
    "options": [
      "لحذف القيم القديمة",
      "لتحديث المصفوفة الأصلية بالقيم المرتبة",
      "لحساب عدد العناصر",
      "لإنهاء البرنامج"
    ],
    "correct": 1,
    "explanation": "يتم نقل القيم المرتبة من aux إلى المصفوفة الأصلية T."
  },
  {
    "question": "أي من التالي يصف Merge Sort بشكل صحيح؟",
    "options": [
      "خوارزمية فرز بالتوزيع",
      "خوارزمية غير تعاودية",
      "خوارزمية تعتمد على Divide and Conquer",
      "خوارزمية تعتمد على التبديل"
    ],
    "correct": 2,
    "explanation": "Merge Sort تعتمد على مبدأ Divide and Conquer."
  }
                ],
                lec2: [
{
    "question": "ما هو الهيكل الرئيسي الذي تعتمد عليه خوارزمية Heap Sort لتحقيق كفاءتها العالية؟",
    "options": [
      "قائمة مرتبطة",
      "كومة ثنائية (Binary Heap)",
      "شجرة بحث ثنائية",
      "مصفوفة مرتبة"
    ],
    "correct": 1,
    "explanation": "تعتمد Heap Sort على هيكل 'الكومة الثنائية' (Binary Heap) - وهي شجرة ثنائية كاملة تحقق خاصية الكومة (الأب أكبر من الأبناء في Max Heap). هذا الهيكل يسمح بالوصول للعنصر الأكبر في O(1) وتحديث الهيكل في O(log n)."
  },
  {
    "question": "في أي مرحلة من Heap Sort يتم ضمان أن أكبر عنصر يصبح في أول المصفوفة؟",
    "options": [
      "مرحلة بناء الكومة",
      "مرحلة الترتيب النهائي",
      "قبل البدء بالخوارزمية",
      "في كل تكرار من المرحلة الثانية"
    ],
    "correct": 0,
    "explanation": "في نهاية مرحلة بناء الكومة (المرحلة الأولى)، تكون المصفوفة ممثلة كـ Max Heap، وبالتالي يكون العنصر الأكبر في الجذر، وهو أول عنصر في المصفوفة (إذا اعتبرنا الفهرس يبدأ من 1)."
  },
  {
    "question": "إذا كانت المصفوفة تحتوي على 100 عنصر، فكم مرة تقريباً ستهبط العقدة من الجذر إلى مستوى الورقة في أسوأ حالة أثناء عملية heapify-down؟",
    "options": [
      "حوالي 7 مرات",
      "حوالي 100 مرة",
      "حوالي 50 مرة",
      "مرة واحدة فقط"
    ],
    "correct": 0,
    "explanation": "ارتفاع شجرة ثنائية كاملة تحتوي على 100 عقدة هو ⌊log₂(100)⌋ ≈ 7 مستويات. في أسوأ حالة، قد تهبط العقدة من الجذر (المستوى 1) إلى مستوى الورقة (المستوى 7)، أي حوالي 7 عمليات هبوط أو مقارنات."
  },
  {
    "question": "لماذا نقوم بتبديل العنصر الأخير مع الجذر في بداية كل تكرار من المرحلة الثانية (الترتيب)؟",
    "options": [
      "لجعل الكومة عشوائية",
      "لنتمكن من تقليص حجم الكومة الفعال",
      "لأن العنصر الأخير هو الأصغر دائماً",
      "لأن هذا شرط لإنهاء الخوارزمية"
    ],
    "correct": 1,
    "explanation": "نبدل الجذر (الأكبر) مع آخر عنصر في الكومة الحالية لنضع العنصر الأكبر في مكانه النهائي الصحيح (في نهاية المصفوفة المرتبة). ثم نقلص حجم الكومة الفعال بمقدار 1، ونعيد بناء الكومة على العناصر المتبقية."
  },
  {
    "question": "إذا بدأنا فهرسة المصفوفة من 1، وكانت العقدة الحالية في الفهرس i=10، فما هو الفهرس الذي يمثل أبويها؟",
    "options": ["5", "10", "20", "3"],
    "correct": 0,
    "explanation": "للعقدة i، أبويها يكون في الفهرس ⌊i/2⌋. ⌊10/2⌋ = 5."
  },
  {
    "question": "في كود بناء الكومة، ما هو الغرض من الحلقة التي تبدأ من i=2 حتى n؟",
    "options": [
      "لترتيب المصفوفة نهائياً",
      "لإدخال كل عنصر جديد في الكومة والحفاظ على خاصية الكومة",
      "لحذف العناصر المكررة",
      "لحساب حجم الكومة"
    ],
    "correct": 1,
    "explanation": "هذه الحلقة تقوم ببناء الكومة بشكل تصاعدي. تبدأ من العنصر الثاني (i=2) وتدخل كل عنصر جديد في الكومة الحالية، ثم ترفعه لأعلى (heapify-up) إذا لزم الأمر للحفاظ على خاصية الكومة (الأب أكبر من الأبناء)."
  },
  {
    "question": "ما هو الشرط الذي يحدد ما إذا كانت العقدة i تمثل ورقة في الشجرة الثنائية الكاملة؟",
    "options": [
      "إذا كان 2*i > n",
      "إذا كان i == 1",
      "إذا كان i/2 == 0",
      "إذا كان i < n"
    ],
    "correct": 0,
    "explanation": "العقدة i تكون ورقة إذا لم يكن لها أبناء، أي إذا كان الفهرس المحسوب لابنها الأيسر (2*i) أكبر من العدد الكلي للعقد n (يتجاوز حدود المصفوفة)."
  },
  {
    "question": "ما هو دور المتحول `elt` في كود بناء الكومة؟",
    "options": [
      "يخزن قيمة العقدة التي نريد إدراجها في الكومة مؤقتاً قبل أن نجد مكانها المناسب",
      "يخزن قيمة الجذر",
      "يخزن حجم المصفوفة",
      "يستخدم كفهرس مؤقت"
    ],
    "correct": 0,
    "explanation": "يستخدم `elt` لحفظ قيمة العنصر الجديد (الموجود في الموقع i) قبل أن نبدأ في رفعه لأعلى. هذا مهم لأنه أثناء رفعه، قد ننقل قيم الأباء للأسفل، وعندما نجد المكان المناسب، نضع قيمة `elt` فيه."
  },
  {
    "question": "ماذا يحدث إذا كانت خاصية الكومة (الأب أكبر من الأبناء) محققة بالفعل عند إدخال عنصر جديد أثناء البناء؟",
    "options": [
      "تدخل حلقة while وتقوم بالعديد من التبديلات",
      "لا تدخل حلقة while أبداً، ويتم وضع العنصر في مكانه الحالي مباشرة",
      "تتوقف الخوارزمية",
      "تحذف العنصر الجديد"
    ],
    "correct": 1,
    "explanation": "شرط حلقة while هو أن يكون الأب أصغر من العنصر الجديد (`x[f] < elt`). إذا كان الأب بالفعل أكبر أو مساوٍ، فإن الشرط يكون خطأ، ولا ندخل الحلقة، ونضع `elt` في موقعه الحالي (`x[s] = elt`)."
  },
  {
    "question": "في مرحلة الترتيب، لماذا نستخدم حلقة تنازلية من i=n إلى 2؟",
    "options": [
      "لأننا نريد وضع أكبر عناصر متبقية في نهاية المصفوفة واحدة تلو الأخرى",
      "لأن الفهرس 1 محجوز للجذر",
      "لجعل الكومة أصغر تدريجياً",
      "السببان 1 و 3 معاً"
    ],
    "correct": 3,
    "explanation": "نبدأ من i=n لأننا نريد وضع أكبر عنصر (الجذر) في آخر موقع (i). بعد وضعه، نقلص حجم الكومة الفعال بمقدار 1 (i--). ننتهي عند i=2 لأنه عندما يتبقى عنصر واحد فقط، فهو تلقائياً في مكانه الصحيح."
  },
  {
    "question": "في كود المرحلة الثانية، ما هو معنى `lValue = x[i]`؟",
    "options": [
      "أخذ قيمة آخر عنصر في الكومة الحالية لتخزينها مؤقتاً",
      "تعيين قيمة الجذر",
      "نسخ قيمة أصغر عنصر",
      "حذف العنصر الأخير"
    ],
    "correct": 0,
    "explanation": "هذه الخطوة تحفظ قيمة العنصر الموجود في آخر موضع في الكومة الحالية (الموقف i). لاحقاً سنضع الجذر (الأكبر) في هذا الموضع، ونحاول إدراج `lValue` في مكان مناسب داخل الكومة المتبقية."
  },
  {
    "question": "ما هو الهدف من حلقة while الداخلية في مرحلة الترتيب؟",
    "options": [
      "لرفع قيمة صغيرة لأعلى في الكومة",
      "لهبوط بقيمة `lValue` لأعماق الكومة حتى تجد مكانها المناسب",
      "لترتيب المصفوفة بسرعة",
      "لحساب عدد العناصر"
    ],
    "correct": 1,
    "explanation": "هدفها هو استعادة خاصية الكومة بعد وضع `lValue` (الذي كان في آخر موضع) في الجذر. نقارن `lValue` مع أكبر أبناء العقدة الحالية (`value`). إذا كان `lValue` أصغر، ندفع الابن الكبير لأعلى، ونهبط بـ `lValue` للأسفل. نستمر حتى يصبح `lValue` أكبر من أبنائه، أو نصبح في منطقة مرتبة."
  },
  {
    "question": "لماذا نتحقق من الشرط `if (s+1 <= i-1)` داخل حلقة while في مرحلة الترتيب؟",
    "options": [
      "للتأكد من وجود أخ أيمن للعقدة الحالية ضمن نطاق الكومة غير المرتبة",
      "للتأكد من أن الفهرس لا يتجاوز n",
      "لمعرفة إذا كانت العقدة ورقة",
      "لحساب عدد الإخوة"
    ],
    "correct": 0,
    "explanation": "العقدة الحالية لها ابن أيسر في `s = 2*f`. هذا الشرط يتحقق مما إذا كان لها أيضاً ابن أيمن، وذلك عن طريق التحقق من أن `s+1` (فهرس الابن الأيمن) أقل من أو يساوي `i-1` (آخر فهرس في الكومة غير المرتبة). إذا وجد، نقارن بين الابن الأيسر والأيمن لاختيار الأكبر."
  },
  {
    "question": "ماذا يعني تعيين `s = 0` داخل شروط if في مرحلة الترتيب؟",
    "options": [
      "لتهيئة الفهرس لبداية جديدة",
      "كعلامة (flag) لكسر حلقة while الداخلية لاحقاً",
      "لحذف العنصر الحالي",
      "للدلالة على أننا وصلنا للجذر"
    ],
    "correct": 1,
    "explanation": "عندما نكون في حالة يجب فيها الخروج من حلقة while (مثل دخول منطقة مرتبة أو عدم وجود أبناء للمقارنة)، نعين `s = 0`. شرط استمرار حلقة while غالباً ما يكون `(s > 0) && ...`، لذا فإن `s = 0` سيكسر الحلقة."
  },
  {
    "question": "إذا كانت المصفوفة [3, 5, 1, 4, 2]، فما هي حالتها بعد مرحلة بناء الكومة (Max Heap)؟",
    "options": [
      "[5, 4, 1, 3, 2]",
      "[1, 2, 3, 4, 5]",
      "[2, 3, 1, 5, 4]",
      "[5, 3, 4, 1, 2]"
    ],
    "correct": 0,
    "explanation": "بعد بناء Max Heap، يجب أن يكون الجذر (الموقع 1) هو الأكبر (5). وكل أب أكبر من أبنائه. الشجرة: الجذر 5، أبناؤه 4 و1، ابن 4 هو 3 و2. المصفوفة: [5, 4, 1, 3, 2] (بافتراض الفهرس 1)."
  },
  {
    "question": "ما هو التعقيد الزمني الإجمالي لـ Heap Sort؟ ولماذا؟",
    "options": [
      "O(n) لأنها تمر على العناصر مرة واحدة",
      "O(n log n) لأن بناء الكومة O(n) وكل من عمليات n-1 استخراج تحتاج O(log n)",
      "O(n²) لأنها تحتوي على حلقتين متداخلتين",
      "O(log n) لأنها تعمل على شجرة"
    ],
    "correct": 1,
    "explanation": "البناء: O(n). ثم ننفذ عملية استخراج وإعادة بناء (heapify-down) لـ n-1 عنصر. كل عملية heapify-down في أسوأ الحالات هي O(log n). الإجمالي: O(n) + (n-1)*O(log n) = O(n log n)."
  },
  {
    "question": "هل يمكن استخدام بنية الكومة (Heap) لأغراض أخرى غير الفرز؟",
    "options": [
      "لا، صممت للفرز فقط",
      "نعم، مثل تنفيذ قائمة انتظار ذات أولوية (Priority Queue)",
      "نعم، لحل مسائل البحث فقط",
      "نعم، لضغط البيانات"
    ],
    "correct": 1,
    "explanation": "بنية الكومة هي أساس هيكل بيانات 'قائمة الانتظار ذات الأولوية' (Priority Queue)، حيث يمكن إدراج عناصر بأولويات واستخراج العنصر ذي الأولوية القصوى (أو الدنيا) بكفاءة."
  },
  {
    "question": "إذا كان لديك كومة عظمى (Max Heap) تحتوي على العناصر [50, 30, 20, 15, 10, 8, 16]، وقمت باستخراج العنصر الأكبر (50) وأعدت بناء الكومة، ما هي العناصر الجديدة في الكومة؟",
    "options": [
      "[30, 20, 16, 15, 10, 8]",
      "[30, 16, 20, 15, 10, 8]",
      "[30, 15, 20, 8, 10, 16]",
      "[16, 30, 20, 15, 10, 8]"
    ],
    "correct": 1,
    "explanation": "بعد استخراج 50، نضع آخر عنصر (16) في الجذر. ثم ننفذ heapify-down: 16 < max(30,20) → نبدل 16 مع 30 (الأكبر). 16 < max(15,10) → نبدل 16 مع 15 (توقف لأن 15 و10 أصغر من 16). النتيجة: [30, 16, 20, 15, 10, 8]."
  },
  {
    "question": "ما هو الشرط الذي يجعل حلقة while في مرحلة الترتيب تتوقف بسبب 'دخول مرحلة الترتيب'؟",
    "options": [
      "عندما يكون `lValue` أكبر من جميع الأبناء",
      "عندما لا يكون للعقدة الحالية أبناء ضمن نطاق الكومة غير المرتبة (s >= i)",
      "عندما نصل إلى الجذر",
      "عندما تكون المصفوفة مرتبة"
    ],
    "correct": 1,
    "explanation": "عندما نصل إلى عقدة يكون أبناؤها (s = 2*f) خارج نطاق الكومة التي لم نرتبها بعد (أي s >= i)، فهذا يعني أننا في المنطقة التي تم ترتيبها بالفعل (العناصر الكبيرة في النهاية). عندها نكسر الحلقة ونضع `lValue` في العقدة الفارغة الحالية."
  },
  {
    "question": "لماذا تعتبر Heap Sort خوارزمية 'غير مستقرة' (Unstable)؟",
    "options": [
      "لأنها قد تغير الترتيب النسبي للعناصر المتساوية في القيمة",
      "لأنها تستخدم ذاكرة إضافية",
      "لأن تعقيدها الزمني غير ثابت",
      "لأنها لا تعمل على المصفوفات"
    ],
    "correct": 0,
    "explanation": "خلال عمليات التبديل التي تحدث أثناء بناء الكومة أو heapify-down، قد ينتهي بأحد العناصر المتساوية في القيمة قبل الآخر في المصفوفة النهائية، على الرغم من أنه كان بعده في المصفوفة الأصلية. لذا لا تحافظ على الاستقرار."
  },
                     {
    "question": "ما هو الاختلاف الرئيسي بين طريقة بناء الكومة من أسفل إلى أعلى (Bottom-up) مقابل الطريقة المستخدمة في المحاضرة (من أعلى إلى أسفل بالإدراج المتتالي)؟",
    "options": [
      "الطريقة Bottom-up أسرع وتعقيدها O(n)، بينما الطريقة في المحاضرة O(n log n)",
      "لا يوجد اختلاف، كلتاهما O(n log n)",
      "الطريقة في المحاضرة أسرع لأنها أبسط",
      "الطريقة Bottom-up لا تعمل مع Max Heap"
    ],
    "correct": 0,
    "explanation": "الطريقة Bottom-up (تبدأ من العقد غير الورقية وتنفذ heapify-down عليها) لها تعقيد خطي O(n) أثباتاً رياضياً. الطريقة في المحاضرة (إدراج عناصر واحدا تلو الآخر ورفعها heapify-up) لها تعقيد O(n log n) ولكنها أبسط في الفهم والتنفيذ."
  },
  {
    "question": "في سياق خوارزمية Heap Sort، ماذا يعني أن الكومة تكون 'مشروطة جزئياً' (Partial Order)؟",
    "options": [
      "أن العناصر مرتبة ترتيباً كاملاً تصاعدياً",
      "أن العلاقة بين الأب وأبنائه محفوظة، ولكن ليس بالضرورة بين الإخوة أو بين عمودين مختلفين",
      "أن الكومة فارغة جزئياً",
      "أن بعض العنوانات مفقودة"
    ],
    "correct": 1,
    "explanation": "خاصية الكومة تضعل فقط أن كل أب أكبر من (أو يساوي) أبنائه المباشرين. لا تضعل شيئاً عن العلاقة بين الأخوة (اليسار واليمين) أو بين ابن وعمه. هذا يخلق ترتيباً جزئياً وليس كاملاً، لكنه كافٍ لضمان أن الجذر هو الأكبر."
  },
  {
    "question": "إذا كان لدينا مصفوفة حجمها n=16، ما هو عدد العقد غير الورقية فيها؟",
    "options": ["8", "7", "15", "9"],
    "correct": 0,
    "explanation": "في شجرة ثنائية كاملة، عدد العقد غير الورقية = ⌊n/2⌋. ⌊16/2⌋ = 8. هذه العقد تبدأ من الفهرس 1 إلى 8."
  },
  {
    "question": "خلال عملية heapify-down، كيف نختار الابن الذي نبدل معه الأب إذا كان الأب أصغر من كلا الابنين؟",
    "options": [
      "نبدل مع الابن الأيسر دائماً",
      "نبدل مع الابن الأيمن دائماً",
      "نبدل مع الابن الأكبر منهما",
      "نبدل مع أي ابن عشوائياً"
    ],
    "correct": 2,
    "explanation": "نقارن بين الابن الأيسر والأيمن (إذا كانا موجودين) ونختار الأكبر. ثم نقارن هذا الابن الأكبر مع الأب. إذا كان الابن أكبر، نبدل. هذا يحافظ على خاصية الكومة (الأب أكبر من كلا الابنين بعد التبديل)."
  },
  {
    "question": "ما هو الخطأ المنطقي الذي سيحدث إذا استخدمنا شرط `while (s > 1 && x[f] <= elt)` بدلاً من `<` في كود البناء؟",
    "options": [
      "سيؤدي إلى دخول لا نهائي إذا كان الأب مساوياً للابن",
      "سيتوقف مبكراً جداً",
      "سيجعل الخوارزمية أسرع",
      "لن يؤثر لأن المساواة مقبولة"
    ],
    "correct": 0,
    "explanation": "إذا كان الأب مساوياً للابن (`x[f] == elt`)، فباستخدام `<=` سيكون الشرط صحيحاً، وسنستمر في رفع الابن حتى الجذر مع أنهما متساويان، مما قد يؤدي إلى تكرار لا نهائي إذا لم نحدّث المؤشرات بشكل صحيح. الأصح هو `<` فقط، لأن المساواة تحقق خاصية الكومة (الأب >= الأبناء)."
  },
  {
    "question": "لماذا في مرحلة الترتيب نحتاج إلى متحولين `lValue` و `value`؟ لماذا لا نستخدم `elt` فقط؟",
    "options": [
      "لأن `elt` مستخدم في المرحلة الأولى فقط",
      "لأن `lValue` هو العنصر المنقول من النهاية، و`value` هو أكبر أبناء العقدة الفارغة أثناء الهبوط",
      "لجعل الكود أطول",
      "لا يوجد سبب، يمكن استخدام `elt`"
    ],
    "correct": 1,
    "explanation": "`lValue` يحفظ قيمة العنصر الذي أخذناه من آخر موضع (x[i]) والذي نريد إيجاد مكان له. `value` يحفظ قيمة أكبر ابن للعقدة الفارغة الحالية (f) أثناء هبوطنا لأسفل. هذان دوران مختلفان. استخدام متحول واحد قد يسبب كتابة فوق القيم قبل الأوان."
  },
  {
    "question": "إذا أردنا فرز المصفوفة تنازلياً (من الأكبر إلى الأصغر) باستخدام Heap Sort، ما هو التغيير البسيط الذي يمكن إجراؤه؟",
    "options": [
      "استخدام Min Heap بدلاً من Max Heap",
      "عكس اتجاه الحلقة النهائية",
      "تغيير جميع علامات المقارنة",
      "الإجابة 1 و 2 معاً"
    ],
    "correct": 0,
    "explanation": "للفرز تنازلياً، نبني Min Heap (حيث الأب أصغر من الأبناء). عندها سيكون العنصر الأصغر في الجذر. في مرحلة الترتيب، نستخرج الأصغر ونضعه في البداية (أو في النهاية ثم نعكس). العمليات المتبقية تبقى كما هي."
  },
  {
    "question": "ما هو الوضع الأمثل (Best Case) لمدخلات Heap Sort؟ وما هو تعقيده الزمني في هذه الحالة؟",
    "options": [
      "مصفوفة مرتبة تصاعدياً، O(n)",
      "مصفوفة مرتبة تنازلياً، O(n log n)",
      "مصفوفة عشوائية، O(n log n)",
      "لا يوجد وضع أمثل، التعقيد دائماً O(n log n)"
    ],
    "correct": 3,
    "explanation": "Heap Sort ليس لديها حالة أفضل مختلفة بشكل كبير. حتى لو كانت المصفوفة مرتبة بالفعل، فإن بناء الكومة لا يزال يتطلب O(n) في أفضل التقنيات، وكل عملية heapify-down في مرحلة الترتيب قد تستغرق O(log n). التعقيد يبقى Θ(n log n) في جميع الحالات."
  },
  {
    "question": "ماذا سيكون تأثير خطأ برمجي جعلنا نبدأ الحلقة التنازلية من i=n إلى 1 (بدلاً من إلى 2)؟",
    "options": [
      "سيفرز العنصر الأخير مرتين",
      "عند i=1، سنحاول وضع الجذر في مكانه وهو مكانه بالفعل، وقد يسبب خطأ أو تبديل غير ضروري",
      "سيجعل الخوارزمية أسرع",
      "لن يتغير شيء"
    ],
    "correct": 1,
    "explanation": "عندما i=1، سيكون حجم الكومة المتبقية عنصراً واحداً. عملية أخذ الجذر ووضعه في المكان i=1 هي نفس المكان. الكود قد يحاول عمل مقارنات وتبديلات غير ضرورية مع عناصر خارج الحدود أو يدخل في حلقة لا نهائية إذا لم يكن محمياً بشروط مناسبة."
  },
  {
    "question": "كيف يمكنك تعديل خوارزمية Heap Sort لترتيب مصفوفة من السجلات (Records) بناءً على حقل معين (مثل العمر)؟",
    "options": [
      "لا يمكن، تعمل فقط على الأرقام",
      "نقوم بمقارنة القيمة الموجودة في الحقل المطلوب أثناء جميع عمليات المقارنة في الخوارزمية",
      "نحول كل سجل إلى رقم",
      "نستخدم مصفوفة منفصلة للفهارس"
    ],
    "correct": 1,
    "explanation": "نغير دوال المقارنة فقط. بدلاً من مقارنة `x[f] < elt`، نقارن `x[f].age < elt.age` (إذا كان الحقل اسمه age). باقي الخوارزمية يبقى كما هو (تبديل السجلات كاملة، إلخ). هذا يجعلها خوارزمية فرز عامة قابلة للتخصيص."
  },
  {
    "question": "ما هو الغرض من التعديل `f = s/2` داخل حلقة while في مرحلة البناء؟",
    "options": [
      "لتحريك المؤشر f (الأب) إلى مستوى أعلى (أقرب إلى الجذر) في التكرار التالي",
      "لتحريك المؤشر للأسفل",
      "لحساب الابن الجديد",
      "لتهيئة f بقيمة جديدة"
    ],
    "correct": 0,
    "explanation": "بعد أن ننقل قيمة الأب للأسفل (`x[s] = x[f]`)، نريد في التكرار التالي مقارنة `elt` مع الأب الجديد (أب الأب السابق). لذلك نحرك المؤشر s إلى مكان الأب القديم (`s = f`)، ثم نحسب أبه الجديد: `f = s/2`. وهكذا نصعد في الشجرة."
  },
  {
    "question": "لماذا في بعض تطبيقات Heap Sort، تتم تهيئة الحلقة الأولى من i = n/2 إلى 1 (تنازلياً)؟",
    "options": [
      "لأن هذا هو بناء الكومة بطريقة Bottom-up الأكثر كفاءة",
      "لأنه يبدأ من الأوراق",
      "لأنه أسهل في الكتابة",
      "لا يوجد سبب، هو نفس الشيء"
    ],
    "correct": 0,
    "explanation": "هذه هي الطريقة الأمثل لبناء الكومة (تعقيد O(n)). نبدأ من آخر عقدة غير ورقية (n/2) وننفذ heapify-down عليها، ثم ننتقل للعقدة التي قبلها، وهكذا حتى الجذر. هذا يستفيد من حقيقة أن الأشجار الفرعية الصغيرة هي بالفعل كومات."
  },
  {
    "question": "إذا قمت بتشغيل Heap Sort على مصفوفة [1,2,3,4,5,6,7]، فكم عدد التبديلات الإضافية التي ستحدث مقارنة لو كانت المصفوفة مرتبة تنازلياً [7,6,5,4,3,2,1]؟",
    "options": [
      "سيكون هناك تبديلات أكثر في الحالة الأولى",
      "سيكون هناك تبديلات أقل في الحالة الأولى",
      "سيكون العدد متساوياً تقريباً",
      "لا يمكن معرفة"
    ],
    "correct": 1,
    "explanation": "عندما تكون المصفوفة مرتبة تصاعدياً (وأردنا ترتيبها تصاعدياً أيضاً)، فإن بناء Max Heap سيتطلب رفع كل عنصر صغير من أسفل الشجرة إلى مكانه الصحيح أعلى، مما يتطلب الكثير من التبديلات. بينما إذا كانت المصفوفة مرتبة تنازلياً، فهي قريبة من Max Heap بالفعل (الجذر هو الأكبر)، وسيتطلب بناء الكومة تبديلات أقل. بشكل عام، حالة الترتيب التصاعدي هي من أسوأ الحالات لبناء الكومة."
  },
  {
    "question": "ما هو التحدي الرئيسي في تنفيذ Heap Sort باستخدام فهرسة تبدأ من 0؟",
    "options": [
      "معادلات حساب الأب والأبناء تتغير",
      "لا يمكن تنفيذها",
      "الخوارزمية تصبح أبطأ",
      "يجب إضافة عنصر وهمي في البداية"
    ],
    "correct": 0,
    "explanation": "المعادلات تتغير: الأب لـ i يصبح (i-1)/2، الابن الأيسر يصبح 2*i+1، الابن الأيمن 2*i+2. يجب تعديل كل الشروط التي تستخدم هذه الحسابات في الكود، وأيضاً شروط التوقف مثل `s > 1` تصبح `s > 0` أو ما شابه."
  },
  {
    "question": "في نهاية مرحلة الترتيب، عندما i=2، لماذا نعتبر أن الفرز اكتمل؟",
    "options": [
      "لأن العنصرين المتبقيين (في الفهرس 1 و 2) سيتم ترتيبهم تلقائياً بتبديل بسيط",
      "لأنه لم يتبق سوى عنصر واحد",
      "لأن الحلقة تنتهي عند i=2",
      "لأن الكومة تختفي"
    ],
    "correct": 0,
    "explanation": "عندما i=2، حجم الكومة غير المرتبة هو عنصرين (في الفهرس 1 و 2). في Max Heap، العنصر في الفهرس 1 (الجذر) هو الأكبر بينهما. عملية التبديل (`x[2] = x[1]`) ثم إدراج `lValue` في الجذر ستؤدي إلى أن يصبح العنصر الأكبر في الفهرس 2، والأصغر في الفهرس 1. وهكذا اكتمل الترتيب."
  },
  {
    "question": "ما هو دور الشرط `if (s > 1)` داخل حلقة while في كود البناء (السطور 20-25 في الكود المعطى)؟",
    "options": [
      "للتأكد من أننا لم نصل إلى الجذر بعد قبل حساب أب جديد",
      "لحساب الأب بطريقة مختلفة إذا وصلنا للجذر",
      "لمنع القسمة على صفر",
      "الإجابتان 1 و 2"
    ],
    "correct": 3,
    "explanation": "عندما نصعد ونجد أن `s` أصبحت 1 (أي وصلنا للجذر)، فإن حساب `f = s/2` سيكون 0 (إذا كانت القسمة صحيحة). الفهرس 0 غير صالح (إذا بدأنا من 1). لذلك، نتحقق: إذا `s > 1` نحسب الأب، وإلا (s=1) نضع `f = 1` أو نخرج من الحلقة. في الكود المعطى، يضع `f = 1`، لكن هذا قد يسبب مشكلة لأن حلقة while ستحاول المقارنة مع `x[1]` مجدداً وقد تدور لا نهائياً إذا لم ينكسر شرط آخر (`x[f] < elt`)."
  },
  {
    "question": "إذا كان لدينا كومة عظمى تحتوي على أعداد مكررة، فهل يمكن أن يكون هناك أكثر من كومة عظمى صحيحة تمثل نفس المصفوفة؟",
    "options": [
      "لا، الكومة العظمى فريدة لمصفوفة معينة",
      "نعم، لأن الإخوة يمكن تبديلهم مع الحفاظ على خاصية الكومة",
      "فقط إذا كانت المصفوفة مرتبة",
      "فقط إذا كانت الأعداد كلها متساوية"
    ],
    "correct": 1,
    "explanation": "خاصية الكومة لا تحدد ترتيب الإخوة (الابن الأيسر واليمين). إذا كان لديك أب بقيم أبناء متساوية، يمكن تبديل مواقع الأبناء ولا تزال الخاصية محققة. لذا قد يكون هناك تمثيلات شجرية مختلفة لنفس المصفوفة كـ Max Heap."
  },
  {
    "question": "كيف تؤثر خاصية 'الشجرة الثنائية الكاملة' على كفاءة خوارزمية Heap Sort؟",
    "options": [
      "تضمن أن ارتفاع الشجرة هو ⌊log n⌋، مما يحافظ على تعقيد O(log n) لعمليات الرفع والهبوط",
      "تزيد من التعقيد لأنها تفرض هيكلاً صارماً",
      "تسمح باستخدام مصفوفة بدلاً من مؤشرات، مما يوفر ذاكرة",
      "الإجابتان 1 و 3"
    ],
    "correct": 3,
    "explanation": "1) الشكل الكامل يضمن أن الشجرة مضغوطة وارتفاعها لوغاريتمي، وهذا أساس لضمان أن heapify-up و heapify-down هما O(log n). 2) لأنه شكل كامل، يمكن تمثيله بمصفوفة بسيطة دون الحاجة لمؤشرات (left/right)، باستخدام معادلات حسابية للعلاقات، مما يوفر الذاكرة ويبسط التنفيذ."
  },
  {
    "question": "ما هو الموقف الذي قد تختار فيه Quick Sort على Heap Sort رغم أن تعقيد أسوأ حالة لـ Quick Sort هو O(n²)؟",
    "options": [
      "عندما تكون البيانات كبيرة جداً وتريد أسوأ حالة مضمونة",
      "عندما يكون الذاكرة محدودة للغاية",
      "عندما تكون بياناتك عشوائية وتريد أسرع أداء عملي في المتوسط",
      "عندما تحتاج فرز مستقر (Stable Sort)"
    ],
    "correct": 2,
    "explanation": "في الممارسة العملية، على بيانات عشوائية، Quick Sort أسرع من Heap Sort بسبب ثوابت التنفيذ الأصغر وتوافقها مع ذاكرة التخزين المؤقت. ومع أن أسوأ حالة Quick Sort هي O(n²)، إلا أن هذا نادر مع اختيار محور (pivot) جيد. لذا للبيانات العامة، يفضل Quick Sort للسرعة."
  },
  {
    "question": "خلال عملية heapify-down في مرحلة الترتيب، ماذا يحدث إذا كان للعقدة الحالية ابن واحد فقط (يساري)؟",
    "options": [
      "نقارن معه مباشرة لأنه الابن الوحيد",
      "نبحث عن ابن أيمن ونجد أنه غير موجود، فنخرج",
      "نعتبر أن العقدة ورقة",
      "نستخدم قيمة افتراضية للابن الأيمن"
    ],
    "correct": 0,
    "explanation": "نحسب `s = 2*f` (الابن الأيسر). ثم نتحقق مما إذا كان له ابن أيمن (`s+1 <= i-1`). إذا لم يكن له (أي s+1 > i-1)، فإن `s` يمثل الابن الوحيد (الأيسر). نقارن `lValue` مع `x[s]` مباشرة. لا داعي لمقارنة الإخوة."
  },
  {
    "question": "ما هو معنى القيمة التي نخرج بها من حلقة while في مرحلة الترتيب (القيمة التي نضعها في `s` لنكسر الحلقة)؟",
    "options": [
      "فهرس العقدة الفارغة النهائية التي يجب وضع `lValue` فيها",
      "فهرس أكبر ابن",
      "القيمة صفر فقط للإشارة",
      "فهرس الجذر الجديد"
    ],
    "correct": 0,
    "explanation": "نحن نهبط بـ `lValue` للأسفل. في كل خطوة، ننقل أكبر ابن (`value`) لأعلى إلى العقدة الفارغة (`f`). ثم نجعل العقدة الفارغة الجديدة هي مكان ذلك الابن (`f = s`). نستمر حتى نتوقف. الفهرس `s` النهائي (قبل تعيينه 0) أو الفهرس `f` هو موقع العقدة الفارغة الذي يجب أن نضع فيه `lValue` (`x[f] = lValue`)."
  },
  {
    "question": "لماذا يتم تنفيذ `x[i] = x[1]` في بداية كل تكرار من المرحلة الثانية؟",
    "options": [
      "لنسخ قيمة الجذر (الأكبر) إلى نهاية الكومة الحالية، وهو مكانه النهائي المرتب",
      "لحذف قيمة الجذر",
      "لتهيئة `x[i]`",
      "لجعل `x[1]` فارغاً"
    ],
    "correct": 0,
    "explanation": "هذا هو جوهر عملية الاستخراج. العنصر الأكبر في الكومة غير المرتبة موجود في الجذر `x[1]`. مكانه النهائي في المصفوفة المرتبة هو الموضع الأخير من الجزء غير المرتب (`i`). لذلك ننقله إلى هناك."
  },
  {
    "question": "في الكود المعطى، ما هو دور المقطع التالي؟\n`if (i == 2) { s = 0; } else { s = 2; }`",
    "options": [
      "تهيئة بدائية لمؤشر الابن عند بدء عملية الهبوط لـ `lValue`، مع معالجة خاصة عندما يكون حجم الكومة 2",
      "كسر الحلقة فوراً عندما i==2",
      "تعيين الابن الأيسر للجذر مباشرة",
      "خطأ برمجي محتمل"
    ],
    "correct": 0,
    "explanation": "هذا المقطع يبدو أنه جزء من تهيئة بدء عملية البحث عن أكبر ابن للجذر (العقدة 1) بعد وضع `lValue` فيه. عادة أكبر أبناء الجذر هما العقدة 2 و3. عندما i==2 (أي بقي عنصران فقط)، فإن العقدة 3 خارج الحدود (i-1 =1). لذا، نعين s=0 ربما للإشارة إلى أنه لا يوجد ابن للمقارنة (أو الابن الوحيد هو 2). التهيئة s=2 في الحالة الأخرى تفترض أن الابن الأيسر (2) هو المرشح الابتدائي، وسيتم تعديله لاحقاً إذا كان الابن الأيمن (3) أكبر وأيضاً ضمن الحدود."
  },
  {
    "question": "ما هو العيب الأساسي الذي يمنع Heap Sort من أن تكون الخيار الأول غالباً في المكتبات القياسية للفرز؟",
    "options": [
      "تعقيد الذاكرة الإضافي",
      "عدم الاستقرار (Unstable)",
      "الثوابت العالية التي تجعلها أبطأ عملياً من خوارزميات مثل Quick Sort أو Merge Sort في كثير من الحالات",
      "تعقيد التنفيذ"
    ],
    "correct": 2,
    "explanation": "رغم أن لها تعقيداً زمنياً جيداً O(n log n) وتعمل في المكان، إلا أن عدد العمليات والمقارنات فيها (الثوابت) أعلى من منافسيها. Quick Sort أسرع عملياً في المتوسط، و Merge Sort مستقر ويعطي أداءً متوقعاً. لذا تستخدم Heap Sort في سياقات محددة (مثل أنظمة الوقت الحقيقي حيث أسوأ حالة O(n log n) مهم، أو عند قيود الذاكرة)."
  },
  {
    "question": "إذا قمت بتشغيل Heap Sort على مصفوفة مكونة من عنصر واحد فقط، فكم عدد المرات التي ستدخل فيها الحلقة الرئيسية للبناء؟",
    "options": ["0", "1", "2", "تعتمد على قيمة العنصر"],
    "correct": 0,
    "explanation": "حلقة البناء تبدأ من i=2 إلى n. إذا كان n=1، فإن نطاق الحلقة (2..1) فارغ، ولن تنفذ أي تكرار. الخوارزمية ستعتبر المصفوفة المرتبة من عنصر واحد بمثابة كومة صحيحة (و ترتيبها مكتمل)."
  },
  {
    "question": "ما الفرق بين 'رفع' عنصر (heapify-up) و 'هبوط' عنصر (heapify-down)؟ ومتى نستخدم كل منها؟",
    "options": [
      "الرفع: عند إدخال عنصر جديد في نهاية الكومة. الهبوط: عند استخراج الجذر أو تخفيض قيمة جذر.",
      "الرفع: عند استخراج الجذر. الهبوط: عند إدخال عنصر جديد.",
      "كلاهما نفس الشيء",
      "الرفع: لبناء الكومة. الهبوط: لتفكيكها."
    ],
    "correct": 0,
    "explanation": "الرفع (Heapify-up / Sift-up): نستخدمه عندما نضيف عنصراً في نهاية الكومة (أو نزيد قيمة عقدة). نقارنه مع أبيه ونسحبه لأعلى إذا كان أكبر (في Max Heap). الهبوط (Heapify-down / Sift-down): نستخدمه عندما نستبدل الجذر بقيمة أصغر (مثل بعد استخراج العنصر الأكبر، نضع آخر عنصر في الجذر). نقارنه مع أكبر أبنائه وندفعه للأسفل."
  },
  {
    "question": "كيف يمكنك تعديل Heap Sort لفرز أول k من أكبر العناصر فقط (بدلاً من كل العناصر)؟",
    "options": [
      "ننفذ مرحلة البناء كاملة، ثم نستخرج الجذر k مرات فقط",
      "نفرز الكل ثم نأخذ أول k عنصر",
      "لا يمكن",
      "نبني كومة صغيرة حجم k فقط"
    ],
    "correct": 0,
    "explanation": "هذا أحد الاستخدامات العملية للكومة. نبني Max Heap (O(n)). ثم نستخرج الجذر (الأكبر) ونعيد بناء الكومة (O(log n)). نكرر هذه العملية k مرات. التعقيد الكلي: O(n + k log n). إذا كان k صغيراً مقارنة بـ n، فهذا فعال جداً."
  },
  {
    "question": "في التمثيل بالمصفوفة، لماذا من المهم أن تكون الشجرة 'ممتلئة من اليسار' (Left-complete)؟",
    "options": [
      "لضمان عدم وجود فراغات في منتصف المصفوفة، وبالتالي استخدام الذاكرة بكفاءة",
      "لجعل الشجرة أسرع في البحث",
      "لجعل العلاقات بين الأب والابن تعمل دائماً بنفس المعادلات",
      "الإجابتان 1 و 3"
    ],
    "correct": 3,
    "explanation": "1) الشكل الممتلئ من اليسار يعني أننا نملأ المصفوفة بالتسلسل من الفهرس 1 إلى n بدون فراغات. 2) هذا يضمن أن معادلات (أب لـ i هو i/2، أبناء i هم 2i و 2i+1) تكون صحيحة لجميع العقد التي لها أبناء، دون الحاجة إلى فحص إضافي."
  },
  {
    "question": "إذا أردت تنفيذ قائمة انتظار ذات أولوية (Priority Queue) باستخدام كومة، فما هي العمليات الأساسية وتعقيداتها؟",
    "options": [
      "إدراج (Insert): O(log n)، إزالة الأعلى (Extract-Max): O(log n)، عرض الأعلى (Peek): O(1)",
      "إدراج: O(1)، إزالة: O(n)، عرض: O(1)",
      "إدراج: O(n)، إزالة: O(1)، عرض: O(n)",
      "كل العمليات O(log n)"
    ],
    "correct": 0,
    "explanation": "هذا هو السبب الرئيسي لشعبية بنية الكومة. الإدراج: نضيف في النهاية ثم نرفع (heapify-up) O(log n). إزالة الأعلى: نستبدل الجذر بآخر عنصر ثم نهبط (heapify-down) O(log n). عرض الأعلى (رؤية العنصر ذي الأولوية القصوى دون حذفه): ببساطة ننظر للجذر O(1)."
  },
  {
    "question": "ما هو الخطأ في المنطق التالي: 'بما أن بناء الكومة يأخذ O(n) ومرحلة الترتيب تأخذ O(n log n)، إذاً تعقيد Heap Sort هو O(n log n) لأن الحد الأكبر هو المهيمن'؟",
    "options": [
      "لا يوجد خطأ، هذا صحيح تماماً",
      "الخطأ أن بناء الكومة يأخذ O(n log n) في الطريقة التي نستخدمها",
      "الخطأ أن الحد الأصغر O(n) لا يؤثر على التدوين المقارب",
      "الخطأ أن مرحلة الترتيب هي O(n)"
    ],
    "correct": 0,
    "explanation": "هذا المنطق صحيح. في التحليل المقارب (Big O)، نأخذ الحد الذي ينمو أسرع مع زيادة n. O(n + n log n) = O(n log n) لأن n log n ينمو أسرع من n. العبارة صحيحة سواء كان بناء الكومة O(n) أو O(n log n) (في طريقتنا)."
  },
  {
    "question": "إذا كان لدينا مصفوفة مرتبة تصاعدياً وأردنا تحويلها إلى Max Heap بأقل عدد من التبديلات، ما هي الاستراتيجية؟",
    "options": [
      "نبدأ من أول عنصر ونرفع كل عنصر",
      "نبدأ من آخر عقدة غير ورقية وننفذ heapify-down عليها نحو الأعلى (طريقة Bottom-up)",
      "نعكس المصفوفة أولاً",
      "نستخدم خوارزمية مختلفة"
    ],
    "correct": 1,
    "explanation": "الطريقة الأكثر كفاءة هي البناء من الأسفل إلى الأعلى (Bottom-up). نبدأ من الفهرس n/2 (أول عقدة غير ورقية من الأسفل) ونتجه نحو الجذر (نزل إلى 1). لكل عقدة، ننفذ heapify-down. هذه الطريقة تستغرق O(n) وستكون فعالة حتى لو كانت المصفوفة مرتبة تصاعدياً (وهي حالة صعبة)."
  },
  {
    "question": "لماذا تعتبر خوارزمية Heap Sort مناسبة لأنظمة الوقت الحقيقي (Real-time Systems) أكثر من Quick Sort؟",
    "options": [
      "لأنها أسرع دائماً",
      "لأنها تعطي ضماناً لأسوأ حالة زمنية (O(n log n))، بينما أسوأ حالة Quick Sort O(n²) غير مقبولة في الوقت الحقيقي",
      "لأنها تستخدم ذاكرة أقل",
      "لأنها أسهل في التنفيذ"
    ],
    "correct": 1,
    "explanation": "في الأنظمة التي يجب أن تكون مضمونة الاستجابة في وقت محدد (مثل الأنظمة الطبية، التحكم في الطائرات)، لا يمكن المخاطرة بأسوأ حالة O(n²) لـ Quick Sort (حتى لو نادرة). Heap Sort تضمن أداء O(n log n) في جميع الحالات، مما يجعلها متوقعة وآمنة للاستخدام في مثل هذه السياقات."
  },
  {
    "question": "ما هو سبب تعيين `s = 0` في الفرع else من الشرط `if (s < i)` (السطر 70 تقريباً)؟",
    "options": [
      "لأن الابن المُختار (`s`) خارج حدود الكومة غير المرتبة (>= i)، لذا نريد كسر حلقة while",
      "لتهيئة s لقيمة جديدة",
      "لأنه لا يوجد أبناء",
      "لأن قيمة value غير معروفة"
    ],
    "correct": 0,
    "explanation": "الشرط `if (s < i)` يتحقق من أن الفهرس `s` (الذي يمثل أكبر ابن مرشح) لا يزال ضمن الجزء غير المرتب من المصفوفة (أقل من i). إذا كان `s >= i`، فهذا يعني أن كلا الابنين (أو الابن الوحيد) موجودان في المنطقة التي تم ترتيبها بالفعل (في نهاية المصفوفة). عندها، نكسر حلقة while عن طريق تعيين `s = 0`، لأننا دخلنا 'مرحلة الترتيب' ولا نريد المقارنة مع عناصر مرتبة."
  },
  {
    "question": "كيف تتعامل Heap Sort مع القيم المتساوية (التكرارات) من حيث الأداء؟",
    "options": [
      "تصبح أبطأ لأنها تسبب مزيداً من التبديلات",
      "تصبح أسرع لأن التبديلات تقل",
      "لا يتأثر الأداء بشكل كبير، يبقى O(n log n)",
      "تتوقف الخوارزمية"
    ],
    "correct": 2,
    "explanation": "وجود قيم متساوية لا يغير التعقيد الزمني المقارب. قد يقلل قليلاً من عدد التبديلات الداخلية لأن شرط المقارنة (`<` أو `>`) قد لا يتحقق في بعض الخطوات عند المساواة، ولكنه لا يغير الترتيب العام لـ O(n log n)."
  },
  {
    "question": "ما هو التحدي في محاولة جعل Heap Sort خوارزمية مستقرة (Stable)؟",
    "options": [
      "يمكن جعلها مستقرة بسهولة بإضافة فهرس ثانوي للمقارنة",
      "صعب جداً لأن عمليات التبديل بين الأب والأبناء البعيدة قد تفقد الاستقرار، والحفاظ عليه قد يتطلب ذاكرة إضافية أو يجعل الخوارزمية أبطأ",
      "لا يمكن أبداً لأنها تعتمد على الشجرة",
      "هي بالفعل مستقرة"
    ],
    "correct": 1,
    "explanation": "الاستقرار يعني أن العناصر المتساوية تحافظ على ترتيبها الأصلي. في Heap Sort، عندما تتبادل عقدة في الجذر مع آخر ورقة (وهي قد تكون بعيدة)، أو أثناء heapify-down، قد ينتهي عنصر متساوٍ قبل آخر كان بعده أصلاً. لجعلها مستقرة، قد نحتاج إلى إرفاق مؤشر ترتيب أصلية أو استخدام ذاكرة إضافية، مما يزيد التعقيد."
  }

                    
                ],
                lec3: [
{ question: "في خوارزمية هوفمان، أين توضع الأحرف؟", 
   options: ["في العقد غير الورقية", "في الجذر فقط", "في الأوراق", "في الفروع"], 
   correct: 2,
   explanation: "الأحرف توضع في الأوراق فقط." },

 { question: "ما الهدف الأساسي من خوارزمية هوفمان؟", 
   options: ["ترتيب الأحرف", "ضغط البيانات بأقصر تمثيل ثنائي", "تشفير النص بكلمة سر", "بناء شجرة بحث"], 
   correct: 1,
   explanation: "الهدف هو ضغط البيانات بحيث يكون لكل حرف تمثيل ثنائي أقصر حسب تكراره." },

 { question: "في شجرة هوفمان، الحرف الأكثر تكراراً يكون:", 
   options: ["أبعد عن الجذر", "في المنتصف", "أقرب إلى الجذر", "ليس له علاقة"], 
   correct: 2,
   explanation: "الحروف الأكثر تكراراً توضع أقرب للجذر لتقصير طول الشيفرة." },

 { question: "عدد عقد شجرة هوفمان إذا كان عدد الأحرف n يساوي:", 
   options: ["n", "2n", "2n - 1", "n - 1"], 
   correct: 2,
   explanation: "شجرة هوفمان تحتوي على 2n-1 عقد إذا كان عدد الأحرف n." },

 { question: "لماذا لا يجوز أن تكون شيفرة حرف بداية لشيفرة حرف آخر؟", 
   options: ["لتقليل الذاكرة", "لمنع الغموض عند فك التشفير", "لتسريع البحث", "لأنه شرط شكلي"], 
   correct: 1,
   explanation: "لكي لا يكون هناك غموض عند فك الشيفرة." },


 // ============================
 // المرحلة 2: التكرار والاختيار
 // ============================

 { question: "في كل خطوة من بناء شجرة هوفمان نختار:", 
   options: ["أكبر تكرارين", "أصغر تكرارين غير مستخدمين", "أي عقدتين", "العقد الورقية فقط"], 
   correct: 1,
   explanation: "نختار أصغر عقدتين غير مستخدمتين لدمجهما." },

 { question: "إذا كانت التكرارات: a=5 , b=2 , c=1 , d=1 فما أول عقدتين يتم دمجهما؟", 
   options: ["a و b", "c و d", "a و c", "b و c"], 
   correct: 1,
   explanation: "أصغر تكرارين هما c و d، لذا ندمجهما أولاً." },

 { question: "تكرار العقدة الأب يساوي:", 
   options: ["أكبر تكرار بين الأبناء", "أصغر تكرار", "مجموع تكراري الابنين", "عدد العقد"], 
   correct: 2,
   explanation: "تكرار العقدة الأب يساوي مجموع تكراري الابنين." },

 { question: "العقد التي لها del = true هي:", 
   options: ["العقد المحذوفة", "العقد المستخدمة", "العقد المتاحة للاختيار", "العقد الجذر"], 
   correct: 2,
   explanation: "del = true تعني أن العقدة تم اختيارها أو مستخدمة." },

 { question: "بعد اختيار عقدة بواسطة findminfreq فإن del تصبح:", 
   options: ["true", "false", "null", "1"], 
   correct: 1,
   explanation: "بعد الاختيار تصبح del = false لتمييز أنها مستخدمة." },


 // ============================
 // المرحلة 3: التمثيل بالمصفوفة
 // ============================

 { question: "تمثيل شجرة هوفمان في البرنامج يتم باستخدام:", 
   options: ["مصفوفة عقد", "مصفوفة محارف", "Stack", "Queue"], 
   correct: 0,
   explanation: "يتم تمثيل الشجرة باستخدام مصفوفة العقد." },

 { question: "الحقل father في العقدة يشير إلى:", 
   options: ["عدد الأبناء", "تكرار الأب", "دليل العقدة الأب", "يمين أو يسار"], 
   correct: 2,
   explanation: "father يخزن فهرس العقدة الأب لكل عقدة." },

 { question: "الحقل isLeft يدل على:", 
   options: ["هل العقدة ورقة", "هل العقدة يسارية", "هل العقدة مستخدمة", "هل هي جذر"], 
   correct: 1,
   explanation: "isLeft يحدد إذا كانت العقدة الابنة يسارية أم لا." },

 { question: "الجذر في شجرة هوفمان يكون عند الفهرس:", 
   options: ["0", "n", "2n-2", "2n-1"], 
   correct: 2,
   explanation: "الجذر يكون عند الفهرس 2n-2 في تمثيل المصفوفة." },

 { question: "عدد العقد الورقية في شجرة هوفمان يساوي:", 
   options: ["n", "2n-1", "n-1", "2n"], 
   correct: 0,
   explanation: "عدد العقد الورقية يساوي عدد الأحرف n." },


 // ============================
 // المرحلة 4: الترميز (Code)
 // ============================

 { question: "عند الصعود من ابن يساري إلى الأب نضيف:", 
   options: ["1", "0", "لا شيء", "حسب التكرار"], 
   correct: 1,
   explanation: "نضيف 0 عند الصعود من ابن يساري." },

 { question: "عند الصعود من ابن يميني إلى الأب نضيف:", 
   options: ["0", "1", "حسب العمق", "لا شيء"], 
   correct: 1,
   explanation: "نضيف 1 عند الصعود من ابن يميني." },

 { question: "يتم توليد شيفرة الحرف بالتحرك من:", 
   options: ["الجذر إلى الورقة", "الورقة إلى الجذر", "اليمين إلى اليسار", "اليسار إلى اليمين"], 
   correct: 1,
   explanation: "نبدأ من الورقة إلى الجذر لتوليد الشيفرة." },

 { question: "تخزن الشيفرة في:", 
   options: ["node", "symbol", "CodeType", "alph"], 
   correct: 2,
   explanation: "الشيفرة تخزن في هيكل CodeType." },

 { question: "startPos في CodeType يدل على:", 
   options: ["عدد البتات", "بداية الشيفرة داخل المصفوفة", "نهاية الشيفرة", "طول الرسالة"], 
   correct: 1,
   explanation: "startPos يحدد بداية الشيفرة في مصفوفة البتات." },


 // ============================
 // المرحلة 5: خصائص الشيفرة
 // ============================

 { question: "شيفرة هوفمان هي:", 
   options: ["ثابتة الطول", "متغيرة الطول", "عشوائية", "ثلاثية"], 
   correct: 1,
   explanation: "شيفرة هوفمان متغيرة الطول حسب تكرار الحروف." },

 { question: "الأحرف الأقل تكراراً يكون لها:", 
   options: ["أقصر شيفرة", "أطول شيفرة", "نفس الطول", "بدون شيفرة"], 
   correct: 1,
   explanation: "الأحرف الأقل تكراراً لها أطول شيفرة." },

 { question: "إذا تغيرت التكرارات فإن:", 
   options: ["الشيفرة تبقى نفسها", "الشجرة تتغير", "الجذر فقط يتغير", "لا شيء يتغير"], 
   correct: 1,
   explanation: "تغيير التكرارات يغير الشجرة وبالتالي الشيفرة." },

 { question: "سبب أن شيفرة هوفمان تضغط البيانات هو:", 
   options: ["تستخدم 0 و 1 فقط", "تعطي الأقصر للأكثر تكراراً", "تلغي بعض الأحرف", "تعيد ترتيب النص"], 
   correct: 1,
   explanation: "الشيفرة تعطي رموز أقصر للحروف الأكثر تكراراً." },

 { question: "هل يمكن أن يكون حرفان لهما نفس الشيفرة؟", 
   options: ["نعم", "لا", "أحياناً", "حسب التكرار"], 
   correct: 1,
   explanation: "لا، كل حرف له شيفرة فريدة لتجنب الغموض." }
                ],
                lec4:[
  {
    "question": "ما هو المبدأ الأساسي الذي تستند إليه شجرة البحث الثنائية (Binary Search Tree)؟",
    "options": [
      "كل عقدة لها قيمتان",
      "القيمة في العقدة اليسرى أصغر من القيمة في العقدة الحالية والقيمة في العقدة اليمنى أكبر",
      "كل عقدة لها أكثر من ولدين",
      "جميع الأوراق على نفس المستوى"
    ],
    "correct": 1,
    "explanation": "في شجرة البحث الثنائية، يتم تخزين العناصر بناءً على ترتيبها: القيمة في كل عقدة يسارية أصغر من قيمة العقدة الأصل، والقيمة في كل عقدة يمينية أكبر من قيمة العقدة الأصل."
  },
  {
    "question": "كيف يتم تمثيل العقدة (Node) في تنفيذ شجرة البحث الثنائية باستخدام المؤشرات؟",
    "options": [
      "بمصفوفة تحتوي على القيم والأبناء",
      "باستخدام صف يحتوي على: قيمة (value)، مؤشر للابن اليساري (left)، مؤشر للابن اليميني (right)",
      "بقائمة مرتبطة أحادية الاتجاه",
      "بسجل يحتوي على القيمة فقط"
    ],
    "correct": 1,
    "explanation": "يتم تمثيل كل عقدة في الشجرة الثنائية ببنية تحتوي على حقول: القيمة (value) من نوع int، ومؤشر للابن اليساري (left) وآخر للابن اليميني (right)، وكلاهما من نفس نوع العقدة (Node)."
  },
  {
    "question": "كيف نعرف أننا وصلنا إلى نهاية فرع في شجرة البحث الثنائية؟",
    "options": [
      "عندما تكون قيمة العقدة تساوي صفر",
      "عندما يكون المؤشر left أو right يشير إلى null",
      "عندما تكون قيمة العقدة أكبر من قيمة الأب",
      "عندما تكون العقدة في المستوى الأخير"
    ],
    "correct": 1,
    "explanation": "عندما يكون المؤشر left أو right لـعقدة ما يشير إلى null، فهذا يعني أنه لا يوجد ابن في هذا الاتجاه، وبالتالي نكون وصلنا إلى نهاية الفرع (ورقة أو نهاية المسار)."
  },
  {
    "question": "ما هي الخطوة الأولى عند بناء شجرة بحث ثنائية جديدة؟",
    "options": [
      "إنشاء عقدة وتسميتها كجذر (root) وتعيين قيمتها للرقم الأول",
      "إدخال جميع الأرقام في قائمة ثم بناء الشجرة",
      "إنشاء جميع العقد ثم ربطها ببعض",
      "فرز الأرقام أولاً ثم بناء الشجرة"
    ],
    "correct": 0,
    "explanation": "يبدأ بناء الشجرة بإنشاء أول عقدة وتعتبر جذر (root)، بحيث تكون قيمة الجذر هي أول رقم يدخل، ومؤشرات left و right تكون null."
  },
  {
    "question": "ما هي الطريقة المستخدمة لإدراج رقم جديد في شجرة البحث الثنائية؟",
    "options": [
      "نبدأ من الجذر ونقارن: إذا كان الرقم أكبر نذهب يميناً، إذا كان أصغر نذهب يساراً، حتى نصل إلى null فننشئ عقدة جديدة",
      "نضع الرقم دائماً في أقصى اليسار",
      "نضع الرقم في موقع عشوائي في الشجرة",
      "نقوم بفرز الشجرة أولاً ثم نضع الرقم في المنتصف"
    ],
    "correct": 0,
    "explanation": "يتم إدراج العناصر عن طريق البدء من الجذر ومقارنة القيمة المراد إدخالها مع قيمة العقدة الحالية، ثم التحرك يميناً أو يساراً بناءً على المقارنة حتى الوصول لموضع فارغ (null) حيث تُنشأ العقدة الجديدة."
  },
  {
    "question": "ما هو نوع العبور (Traversal) الذي يُعطي الأرقام مرتبة تصاعدياً في شجرة بحث ثنائية؟",
    "options": [
      "Preorder (جذر-يسار-يمين)",
      "Inorder (يسار-جذر-يمين)",
      "Postorder (يسار-يمين-جذر)",
      "Level-order (حسب المستويات)"
    ],
    "correct": 1,
    "explanation": "العبور من النوع Inorder (الذهاب أقصى اليسار، ثم طباعة الجذر، ثم الذهاب يميناً) في شجرة بحث ثنائية ينتج قائمة مرتبة تصاعدياً بسبب خاصية الشجرة (اليسار < الجذر < اليمين)."
  },
  {
    "question": "ما هو شرط استمرار حلقة البحث عن عنصر في الشجرة؟",
    "options": [
      "أن يكون المؤشر P يساوي null",
      "أن يكون المتغير found يساوي true",
      "أن يكون المؤشر P ليس null وأن يكون found يساوي false",
      "أن يكون Q يساوي P"
    ],
    "correct": 2,
    "explanation": "تستمر عملية البحث طالما أن المؤشر P لم يصل إلى نهاية فرع (ليس null) ولم يتم العثور على العنصر بعد (found == false)."
  },
  {
    "question": "ما هو دور المتغير Q في خوارزمية البحث والحذف؟",
    "options": [
      "يخزن العقدة الجذر",
      "يشير إلى العقدة التي سبقت P (أب العقدة الحالية)",
      "يخزن أصغر عنصر في الشجرة",
      "يحدد نوع العبور المستخدم"
    ],
    "correct": 1,
    "explanation": "يتم استخدام Q لتتبع العقدة الأب للعقدة الحالية P، مما يساعد لاحقاً في عملية إعادة الربط عند حذف العقدة."
  },
  {
    "question": "في خوارزمية البحث، ماذا يعني أن قيمة found أصبحت true؟",
    "options": [
      "أن الشجرة فارغة",
      "أن العقدة الحالية P هي null",
      "أن العنصر المطلوب موجود في الشجرة",
      "أنه يجب الانتقال إلى الابن الأيسر"
    ],
    "correct": 2,
    "explanation": "عندما تصبح found == true فهذا يعني أن قيمة P.value تساوي القيمة المطلوبة (key)، وبالتالي تم العثور على العنصر المطلوب في الشجرة."
  },
  {
    "question": "ما هي الحالات الثلاث الممكنة عند حذف عقدة من شجرة البحث الثنائية؟",
    "options": [
      "العقدة لها أخ واحد، لها عم، لها جد",
      "العقدة تحتوي على رقم زوجي، رقم فردي، رقم سالب",
      "العقدة ليس لها أبناء، لها ابن واحد، لها اثنان من الأبناء",
      "العقدة في أول الشجرة، في وسط الشجرة، في آخر الشجرة"
    ],
    "correct": 2,
    "explanation": "عند حذف عقدة: 1) قد لا يكون لها أبناء (ورقة). 2) قد يكون لها ابن واحد فقط (يساري أو يميني). 3) قد يكون لها ابنان (يساري ويميني). وتختلف الخوارزمية باختلاف الحالة."
  },
  {
    "question": "كيف يتم التعامل مع حذف عقدة ليس لها أبناء (ورقة)؟",
    "options": [
      "نجعل العقدة الأب تؤشر إلى null في الاتجاه المناسب",
      "نستبدلها بالجذر",
      "نربطها بأقرب عقدة مجاورة",
      "نحذف الشجرة كلها"
    ],
    "correct": 0,
    "explanation": "عند حذف عقدة ورقة (لا أبناء لها)، نقوم ببساطة بتعديل المؤشر في العقدة الأب (التي يخزنها Q) ليشير إلى null بدلاً من الإشارة إلى العقدة المحذوفة."
  },
  {
    "question": "كيف نتعامل مع حذف عقدة لها ابن واحد فقط؟",
    "options": [
      "نربط العقدة الأب مباشرة بالابن الوحيد للعقدة المحذوفة",
      "نحذف الابن أيضاً",
      "نستبدل العقدة بأصغر عنصر في الشجرة",
      "نقوم بقلب الشجرة"
    ],
    "correct": 0,
    "explanation": "إذا كان للعقدة المحذوفة ابن واحد فقط (يساري أو يميني)، فإننا نجعل العقدة الأب (Q) تؤشر مباشرة إلى هذا الابن، متجاوزين العقدة المحذوفة."
  },
  {
    "question": "ما هي الاستراتيجية المستخدمة عند حذف عقدة لها اثنان من الأبناء؟",
    "options": [
      "حذف العقدة دون استبدال",
      "استبدال العقدة المحذوفة بأكبر عنصر في الفرع الأيسر، أو بأصغر عنصر في الفرع الأيمن",
      "قلب ترتيب الفرعين",
      "دمج الابن الأيسر واليمين في عقدة واحدة"
    ],
    "correct": 1,
    "explanation": "لضمان بقاء الشجرة بحث ثنائية صحيحة، نستبدل العقدة المحذوفة (ذات الابنيتين) إما بأكبر عقدة في فرعها الأيسر (أقصى اليمين في اليسار) أو بأصغر عقدة في فرعها الأيمن (أقصى اليسار في اليمين)، ثم نحذف العقدة البديلة من موقعها الأصلي."
  },
  {
    "question": "لماذا نبحث عن 'أصغر عنصر في الفرع الأيمن' عند حذف عقدة لها ابنان؟",
    "options": [
      "لأنه الأقرب من حيث القيمة إلى العقدة المحذوفة ويضمن أن جميع العناصر في الفرع الأيمن تبقى أكبر منه",
      "لأنه الأسهل في الوصول إليه",
      "لأن قيمته دائمًا تساوي صفر",
      "لأنه الورقة الأبعد في الشجرة"
    ],
    "correct": 0,
    "explanation": "أصغر عنصر في الفرع الأيمن (الموجود في أقصى اليسار من ذلك الفرع) هو العنصر الذي يأتي مباشرة بعد العقدة المحذوفة في الترتيب التصاعدي. استبدال العقدة به يضمن أن جميع العناصر في اليسار تبقى أصغر منه، وجميع العناصر في اليمين تبقى أكبر منه."
  },
  {
    "question": "ما هو دور المؤشرات V و T و S في حالة حذف عقدة لها ابنان؟",
    "options": [
      "V يشير للخلف (البديل)، T يشير لأب الخلف، S تستخدم للبحث عن الخلف",
      "V يشير للجذر، T يشير للأب، S يشير للابن",
      "جميعها تخزن نسخة من العقدة المحذوفة",
      "V و T و S هي مؤشرات لنفس العقدة"
    ],
    "correct": 0,
    "explanation": "V: يشير إلى العقدة البديلة (الخلف) التي ستأخذ مكان المحذوفة. T: يشير إلى أب العقدة البديلة (V). S: مؤشر مساعد يستخدم في حلقة while للبحث عن العقدة البديلة (أصغر عنصر في الفرع الأيمن)."
  },
  {
    "question": "متى تنتهي حلقة البحث عن العقدة البديلة (الخلف) S؟",
    "options": [
      "عندما تصبح S تساوي null",
      "عندما تصبح قيمة S أصغر من P",
      "عندما تصبح found تساوي true",
      "عندما يصبح T مساوياً لـ P"
    ],
    "correct": 0,
    "explanation": "نستمر في تحريك S نحو اليسار (S = S.left) حتى تصبح S == null. عندها، تكون العقدة السابقة لـ S (والتي يخزنها V) هي أصغر عقدة في الفرع (الخلف المطلوب)."
  },
  {
    "question": "ماذا يعني الشرط (T != P) في حالة حذف عقدة لها ابنان؟",
    "options": [
      "أن العقدة البديلة (V) ليست الابن المباشر الأيمن للعقدة المحذوفة (P)",
      "أن العقدة المحذوفة هي الجذر",
      "أن العقدة البديلة لها ابن أيسر",
      "أن T يشير إلى null"
    ],
    "correct": 0,
    "explanation": "إذا كان T != P، فهذا يعني أننا تحركنا لليسار على الأقل مرة واحدة أثناء البحث عن الخلف. وبالتالي العقدة البديلة (V) ليست الابن الأيمن المباشر لـ P، بل هي في مكان أعمق داخل الفرع الأيمن."
  },
  {
    "question": "ماذا يحدث إذا كانت العقدة المراد حذفها هي الجذر (root)؟",
    "options": [
      "يتم إلغاء عملية الحذف",
      "يتم تعيين العقدة البديلة (V) كجذر جديد للشجرة",
      "تظل الشجرة بدون جذر",
      "نربط الجذر بأقرب عقدة"
    ],
    "correct": 1,
    "explanation": "إذا كان Q == null، فهذا يعني أن العقدة المحذوفة (P) هي الجذر. في هذه الحالة، نقوم بتعيين العقدة البديلة (V) لتكون الجذر الجديد للشجرة (root = V)."
  },
  {
    "question": "كيف يتم ربط العقدة البديلة (V) مكان المحذوفة (P) من ناحية الأبناء؟",
    "options": [
      "V.right = P.right و V.left = P.left",
      "يتم نسخ قيمة P إلى V فقط",
      "يتم عكس أبناء V",
      "لا يتم ربطهم، يتم إنشاء أبناء جدد"
    ],
    "correct": 0,
    "explanation": "لجعل العقدة البديلة V تؤدي دور العقدة المحذوفة P، يجب أن ترث أبناءها. لذلك نقوم بتعيين: V.right = P.right و V.left = P.left، لتحتفظ الشجرة بعلاقاتها."
  },
  {
    "question": "ما هو الشرط الذي يحدد إذا كان يجب ربط الأب (Q) بالخلف (V) من الجهة اليسرى أم اليمنى؟",
    "options": [
      "إذا كانت P == Q.left نربط Q.left = V، وإلا Q.right = V",
      "دائماً نربط Q.left = V",
      "نربط من الجهة التي تحقق أن قيمة V متوسطة",
      "نقرر عشوائياً"
    ],
    "correct": 0,
    "explanation": "يجب الحفاظ على العلاقة الأصلية بين العقدة الأب (Q) والعقدة المحذوفة (P). إذا كانت P هي الابن الأيسر لـ Q، فالخلف V يصبح الابن الأيسر الجديد لـ Q. والعكس صحيح."
  },
  {
    "question": "في المثال بالشرح، عند حذف العقدة ذات القيمة 10، ما هي العقدة التي استُخدمت كبديل (خلف)؟",
    "options": [
      "العقدة 9",
      "العقدة 12",
      "العقدة 14",
      "العقدة 15"
    ],
    "correct": 1,
    "explanation": "لأن العقدة 10 لها ابنان، تم أخذ أصغر عقدة في فرعها الأيمن (الذي جذره 14) كبديل. أصغر عقدة في هذا الفرع هي 12 (الموجودة في أقصى اليسار من الفرع الذي يبدأ بـ14)."
  },
  {
    "question": "ما الفرق الأساسي بين بناء شجرة بحث ثنائية باستخدام المؤشرات مقابل استخدام المصفوفة؟",
    "options": [
      "في المؤشرات نربط العقد ببعضها عبر مراجع، بينما في المصفوفة نعتمد على حسابات الفهرس (2*i, 2*i+1)",
      "المصفوفة أسرع دائماً",
      "لا فرق، فهما نفس الشيء",
      "المؤشرات تستخدم للشجر غير الثنائي فقط"
    ],
    "correct": 0,
    "explanation": "الفرق الجوهري هو في التمثيل: التمثيل بالمصفوفة يكون ضمنياً ويعتمد على مواقع الفهرس، بينما التمثيل بالمؤشرات يكون صريحاً حيث تحتوي كل عقدة على مراجع (مؤشرات) للعقد الأبناء."
  },
  {
    "question": "ما معنى أن عملية الإدراج (build) في الشجرة هي عملية 'تعاودية' (Recursive)؟",
    "options": [
      "أنها تستدعي نفسها بمعاملات مختلفة (مثل nodeP.left أو nodeP.right) حتى تصل للنقطة المنشودة",
      "أنها تدور في حلقة لا نهائية",
      "أنها تعيد ترتيب الشجرة في كل مرة",
      "أنها تحذف العناصر القديمة"
    ],
    "correct": 0,
    "explanation": "الدالة build تستدعي نفسها، ولكن مع تمرير مؤشر إلى ابن (يسار أو يمين) العقدة الحالية كـ 'جذر' جديد للبحث. هذا يستمر بشكل متكرر حتى الوصول إلى موقع فارغ (null) حيث يتم إنشاء العقدة الجديدة."
  },
  {
    "question": "كيف يتم معالجة حالة إدخال رقم مكرر في الدالة build كما ورد في الكود؟",
    "options": [
      "يتم تجاهل الرقم وطباعة رسالة 'DuplicateNumber'",
      "يتم إضافته في نفس المكان",
      "يتم وضعه كابن أيسر دائماً",
      "يتم إعادة بناء الشجرة من جديد"
    ],
    "correct": 0,
    "explanation": "وفقاً للكود، إذا كان الرقم المدخل يساوي قيمة العقدة الحالية (nodeP.value)، فإنه يدخل الفرع else الذي يطبع رسالة 'DuplicateNumber' ولا يقوم بأي إدراج، لأن الأشجار البحث الثنائية في هذا التطبيق لا تسمح بقيم مكررة."
  },
  {
    "question": "ما هو شرط التوقف في حلقة الإدخال الرئيسية (main) لبناء الشجرة؟",
    "options": [
      "عند إدخال القيمة -1",
      "عند إدخال 100 رقم",
      "عندما تمتلئ الذاكرة",
      "عند إدخال قيمة سالبة"
    ],
    "correct": 0,
    "explanation": "تستمر الحلقة في طلب أرقام من المستخدم وإدخالها في الشجرة حتى يقوم المستخدم بإدخال القيمة -1، والتي تعتبر إشارة لإنهاء عملية الإدخال."
  },
  {
    "question": "ما هو نوع القيم المخزنة في شجرة البحث الثنائية في هذا التطبيق؟",
    "options": [
      "نصوص (String)",
      "أرقام صحيحة (int)",
      "أرقام عشرية (double)",
      "قيم منطقية (boolean)"
    ],
    "correct": 1,
    "explanation": "حقل value في بنية Node مُعرّف كنوع int، وبالتالي الشجرة مصممة لتخزين وقارنة الأعداد الصحيحة."
  },
  {
    "question": "ما هو الهدف من استخدام JOptionPane في الكود الرئيسي (Main)؟",
    "options": [
      "لرسم الشجرة بيانياً",
      "لإدخال البيانات من خلال نوافذ حوارية للمستخدم",
      "لطباعة الشجرة في ملف",
      "لتحميل الأرقام من الإنترنت"
    ],
    "correct": 1,
    "explanation": "تُستخدم JOptionPane.showInputDialog لإنشاء نافذة حوارية بسيطة تطلب من المستخدم إدخال رقم، مما يجعل البرنامج تفاعلياً."
  },
  {
    "question": "في دالة print (للعبور)، ماذا يتم طباعته عندما تكون P == null؟",
    "options": [
      "يتم طباعة القيمة 0",
      "يتم طباعة فراغ أو مسافة ' ' للإشارة للنهاية",
      "يتوقف البرنامج عن العمل",
      "يعود للعقدة السابقة دون طباعة"
    ],
    "correct": 1,
    "explanation": "هذا هو الشرط الأساسي للتوقف في الدالة العاودية. عندما تصل الدالة إلى عقدة غير موجودة (null)، تطبع حرف فراغ (أو أي رمز) للإشارة إلى عدم وجود شيء، ثم تعود."
  },
  {
    "question": "لماذا يُفضل استخدام شجرة بحث ثنائية متوازنة؟",
    "options": [
      "لأنها تضمن أن عمليات البحث والإدراج والحذف تكون بكفاءة O(log n) في أسوأ الحالات",
      "لأنها تستخدم ذاكرة أقل",
      "لأن شكلها أجمل",
      "لأنها لا تسمح بالقيم المكررة"
    ],
    "correct": 0,
    "explanation": "إذا كانت الشجرة غير متوازنة (مائلة بشدة)، فقد تتحول إلى ما يشبه القائمة المرتبطة، مما يجعل عمليات البحث بكفاءة O(n). الشجرة المتوازنة تحافظ على ارتفاع يقارب اللوغاريتمي لعدد العقد، مما يحافظ على الكفاءة."
  },
  {
    "question": "في العبور Preorder، ما هو ترتيب زيارة العقد؟",
    "options": [
      "الجذر، ثم الابن الأيسر، ثم الابن الأيمن",
      "الابن الأيسر، ثم الجذر، ثم الابن الأيمن",
      "الابن الأيسر، ثم الابن الأيمن، ثم الجذر",
      "الجذر، ثم الابن الأيمن، ثم الابن الأيسر"
    ],
    "correct": 0,
    "explanation": "Preorder (أو VLR): تبدأ بزيارة الجذر أولاً (V)، ثم تنتقل بشكل عاودي إلى الشجرة اليسرى بأكملها (L)، ثم إلى الشجرة اليمنى بأكملها (R)."
  },
  {
    "question": "في العبور Postorder، ما هو ترتيب زيارة العقد؟",
    "options": [
      "الجذر، ثم الابن الأيسر، ثم الابن الأيمن",
      "الابن الأيسر، ثم الجذر، ثم الابن الأيمن",
      "الابن الأيسر، ثم الابن الأيمن، ثم الجذر",
      "الجذر، ثم الابن الأيمن، ثم الابن الأيسر"
    ],
    "correct": 2,
    "explanation": "Postorder (أو LRV): تزور بشكل عاودي الشجرة اليسرى بأكملها (L)، ثم الشجرة اليمنى بأكملها (R)، ثم تزور الجذر (V) أخيراً."
  },
  {
    "question": "ما هي الحالة التي يكون فيها العبور Inorder مفيداً جداً في شجرة البحث الثنائية؟",
    "options": [
      "عندما نريد نسخ الشجرة",
      "عندما نريد الحصول على العناصر مرتبة تصاعدياً أو تنازلياً",
      "عندما نريد معرفة ارتفاع الشجرة",
      "عندما نريد حساب عدد الأوراق"
    ],
    "correct": 1,
    "explanation": "بسبب خاصية الترتيب في شجرة البحث الثنائية (اليسار < الجذر < اليمين)، فإن العبور Inorder ينتج قائمة مرتبة من العناصر. هذا مفيد للحصول على البيانات بشكل مرتب دون الحاجة لفرضها في بنية أخرى."
  },
  {
    "question": "كيف نبدأ عملية البحث في الدالة search؟",
    "options": [
      "بوضع P على الجذر root، وQ على null، وfound على false",
      "بوضع P على null، وQ على الجذر",
      "بوضع found على true مباشرة",
      "باستدعاء الدالة build أولاً"
    ],
    "correct": 0,
    "explanation": "تهيئة البحث تكون بتعيين المؤشر الحالي P ليشير إلى جذر الشجرة (بداية البحث)، وتعيين Q كـ null (لأن الجذر ليس له أب)، وتعيين found كـ false (لم يتم العثور بعد)."
  },
  {
    "question": "ماذا يحدث إذا حاولنا حذف عنصر غير موجود في الشجرة؟",
    "options": [
      "تطبع رسالة 'This number is not in the tree'",
      "تحذف الجذر عوضاً عنه",
      "تنشئ العقدة ثم تحذفها",
      "لا يحدث شيء وتستمر العملية"
    ],
    "correct": 0,
    "explanation": "إذا انتهت حلقة البحث وخرجنا منها بـ found == false، فهذا يعني أن الرقم المطلوب (key) غير موجود في الشجرة. يتم طباعة رسالة تنبيه للمستخدم."
  },
  {
    "question": "ما هو دور المؤشر P.right في بداية البحث عن الخلف (لحذف عقدة ذات ابنين)؟",
    "options": [
      "ينتقل مباشرة إلى الابن الأيسر للعقدة المحذوفة",
      "ينتقل خطوة واحدة إلى اليمين (الفرع الأيمن) للبدء بالبحث عن أصغر عنصر فيه",
      "يستخدم لحساب ارتفاع الشجرة",
      "يعيد تعيين الجذر"
    ],
    "correct": 1,
    "explanation": "بعد التأكد من أن العقدة P لها ابنان، نبدأ البحث عن الخلف (البديل) في الفرع الأيمن لـ P. لذلك نضع V = P.right كبداية للبحث في ذلك الفرع."
  },
  {
    "question": "ما الفائدة من تعليمة 'T.left = V.right' عند حذف عقدة لها ابنان؟",
    "options": [
      "لربط ابن الخلف الأيمن بوالد الخلف، لأن الخلف (V) سيتم نقله لمكان آخر",
      "لحذف الابن الأيسر للخلف",
      "لقلب اتجاه الفرع الأيمن",
      "لتحديث قيمة الجذر"
    ],
    "correct": 0,
    "explanation": "عندما ننقل العقدة V (الخلف) لتحل محل P، يجب علينا أولاً إزالتها من موقعها الأصلي. V.right (الابن الوحيد لـ V عادةً) يجب أن يصبح الابن الأيسر الجديد لـ T (والد V)، لملء الفراغ الناتج عن نقل V."
  },
  {
    "question": "كيف يمكن أن يؤثر ترتيب إدخال البيانات على شكل شجرة البحث الثنائية الناتجة؟",
    "options": [
      "لا يؤثر، فالشجرة النهائية دائماً نفسها",
      "يؤثر بشكل كبير، فإدخال الأرقام مرتبة (متصاعدة أو تنازلية) ينتج شجرة مائلة تشبه القائمة المرتبطة",
      "يؤثر فقط على لون العقد",
      "يؤثر على نوع القيم التي يمكن إدخالها"
    ],
    "correct": 1,
    "explanation": "إذا أدخلت الأرقام مرتبة (مثل 1,2,3,4...)، ستتحول الشجرة إلى قائمة مرتبة يمينية (كل عقدة لها ابن أيمن فقط). وهذا أسوأ حالة للأداء (O(n)). بينما الإدخال العشوائي يميل لإنتاج شجرة أكثر توازناً."
  },
  {
    "question": "بعد حذف عقدة ناجح، كيف نتأكد أن الشجرة لا تزال تحافظ على خاصية شجرة البحث الثنائية؟",
    "options": [
      "نقوم بطباعتها باستخدام Inorder، فإذا كانت مرتبة، فهي صحيحة",
      "نقوم بحساب عدد العقد",
      "نتأكد من أن كل عقدة لها لونان",
      "لا يمكن التأكد إلا بإعادة بنائها"
    ],
    "correct": 0,
    "explanation": "خاصية شجرة البحث الثنائية هي أن العبور Inorder يعطي تسلسلاً مرتباً. بعد أي عملية حذف، يمكن طباعة الشجرة باستخدام Inorder للتحقق من أن العناصر ما زالت مرتبة، مما يدل على صحة العملية."
  },
  {
    "question": "ما هو الهدف التعليمي الأساسي من خوارزمية البحث والحذف في شجرة البحث الثنائية كما وردت بالمحاضرة؟",
    "options": [
      "فهم كيفية تخزين البيانات في مصفوفة",
      "فهم كيفية تنفيذ بنية بيانات ديناميكية غير خطية واستخدام المؤشرات للتنقل فيها وإجراء عمليات معقدة مع الحفاظ على الخواص",
      "تعلم كيفية رسم الأشجار",
      "فهم كيفية استخدام الحلقات البسيطة فقط"
    ],
    "correct": 1,
    "explanation": "تعتبر شجرة البحث الثنائية بنية بيانات ديناميكية غير خطية أساسية. هذه الخوارزمية تعلم كيفية التعامل مع هذه البنية باستخدام المؤشرات، وإجراء عمليات البحث والإدراج والحذف المعقدة التي تتطلب إعادة ربط دقيق للمؤشرات مع الحفاظ على خواص الشجرة."
  }
                ],
lec5:[
  {
    "question": "ما هو المبدأ الأساسي الذي تعمل عليه خوارزمية Quicksort؟",
    "options": [
      "البرمجة الديناميكية",
      "الفرز بالدمج",
      "التقسيم والتغلب (Divide and Conquer)",
      "الفرز بالتحديد"
    ],
    "correct": 2,
    "explanation": "Quicksort تعتمد على مبدأ التقسيم والتغلب، حيث تقسم المصفوفة إلى جزأين وتطبق نفس الخوارزمية بشكل متكرر."
  },
  {
    "question": "ما الفرق الرئيسي بين Quicksort و Mergesort من حيث مكان التقسيم؟",
    "options": [
      "Mergesort يستخدم التقسيم العشوائي",
      "Quicksort لا يستخدم التقسيم",
      "Quicksort يقسم بناءً على محور (pivot)، بينما Mergesort يقسم منتصف المصفوفة دائماً",
      "لا فرق بينهما"
    ],
    "correct": 2,
    "explanation": "في Quicksort التقسيم يعتمد على اختيار محور (pivot) ويتم ترتيب العناصر حوله، بينما في Mergesort التقسيم يكون دائماً في المنتصف."
  },
  {
    "question": "ما هو دور التابع Partition في خوارزمية Quicksort؟",
    "options": [
      "يدمج جزأين من المصفوفة",
      "يقسم المصفوفة حول محور معين ويعيد موقع التقسيم",
      "يختار المحور عشوائياً فقط",
      "يحدد حجم المصفوفة"
    ],
    "correct": 1,
    "explanation": "يقوم Partition بترتيب العناصر بحيث تكون العناصر الأصغر من المحور على يساره والعناصر الأكبر على يمينه، ويعيد مؤشراً لوضع المحور النهائي."
  },
  {
    "question": "كيف يتم اختيار العنصر المحوري (Partitioning Element) في الكود المعطى؟",
    "options": [
      "يتم اختيار العنصر الأخير دائماً",
      "يتم اختيار العنصر الموجود في منتصف المصفوفة",
      "يتم اختيار عنصر عشوائي",
      "يتم اختيار العنصر الأول دائماً"
    ],
    "correct": 1,
    "explanation": "في الكود المعطى: partitioningElement = arr[(left + right) / 2]، أي العنصر الأوسط بين left و right."
  },
  {
    "question": "ماذا يحدث عندما يكون arr[i] < partitioningElement في حلقة while الداخلية؟",
    "options": [
      "يتم إنهاء الخوارزمية",
      "يتم تقليل j",
      "يتم تبديل العنصر",
      "يتم زيادة i للبحث عن عنصر أكبر أو يساوي المحور"
    ],
    "correct": 3,
    "explanation": "الهدف هو إيجاد أول عنصر من اليسار أكبر أو يساوي المحور ليتم نقله لليمين لاحقاً."
  },
  {
    "question": "ماذا تعني العودة return i في نهاية دالة Partition؟",
    "options": [
      "تعيد قيمة المحور نفسه",
      "تعيد حجم المصفوفة",
      "تعيد المؤشر الذي يشير إلى بداية الجزء الأيمن من التقسيم",
      "تعيد عدد المقارنات"
    ],
    "correct": 2,
    "explanation": "i يشير إلى الموقع الذي انتهى عنده المؤشر اليساري، وهو بداية الجزء الأيمن الذي جميع عناصره أكبر أو تساوي المحور."
  },
  {
    "question": "في Quicksort، متى يتم استدعاء الدالة بشكل متكرر للجزء الأيسر؟",
    "options": [
      "عندما يكون index == left",
      "عندما يكون index > right",
      "عندما يكون left == right",
      "عندما يكون left < index - 1"
    ],
    "correct": 3,
    "explanation": "يتم استدعاء Quicksort للجزء الأيسر إذا كان هناك أكثر من عنصر واحد فيه، أي left < index - 1."
  },
  {
    "question": "ما الشرط الذي يجب تحقيقه لاستدعاء Quicksort على الجزء الأيمن؟",
    "options": [
      "index == left",
      "index < right",
      "right == left",
      "left > right"
    ],
    "correct": 1,
    "explanation": "يتم استدعاء Quicksort للجزء الأيمن إذا كان هناك على الأقل عنصران فيه، أي index < right."
  },
  {
    "question": "ما هي الحالة الأساسية (Base Case) في خوارزمية Quicksort؟",
    "options": [
      "عندما تكون المصفوفة مرتبة بالفعل",
      "عندما يكون left == 0",
      "عندما يكون الجزء المراد فرزه يحتوي على عنصر واحد أو أقل",
      "عندما تكون المصفوفة فارغة"
    ],
    "correct": 2,
    "explanation": "الحالة الأساسية هي عندما لا يحتوي الجزء على أكثر من عنصر واحد، فلا يحتاج إلى مزيد من التقسيم."
  },
  {
    "question": "في مثال المصفوفة {1,12,5,26,7,14,3,7,2}، ما قيمة المحور في الاستدعاء الأول للـ Partition؟",
    "options": [
      "2",
      "26",
      "1",
      "7"
    ],
    "correct": 3,
    "explanation": "المحور هو العنصر الأوسط بين الفهرس 0 و 8، أي الفهرس 4 الذي قيمته 7."
  },
  {
    "question": "بعد تنفيذ Partition على المصفوفة المذكورة، ما هو الفهرس الذي تم إرجاعه؟",
    "options": [
      "6",
      "8",
      "5",
      "4"
    ],
    "correct": 2,
    "explanation": "حسب الشرح، بعد Partition يعاد i = 5، وهو بداية الجزء الأيمن."
  },
  {
    "question": "في الكود البرمجي، ماذا يحدث عند تنفيذ if (i <= j) داخل Partition؟",
    "options": [
      "يتم إرجاع قيمة j",
      "يتم إنهاء الحلقة فوراً",
      "يتم تبديل العناصر arr[i] و arr[j] ثم تحريك المؤشرين",
      "يتم تجاهل التبديل"
    ],
    "correct": 2,
    "explanation": "عندما i <= j، يعني أن هناك عنصراً على اليسار أكبر من المحور وآخر على اليمين أصغر منه، فيتم تبديلهما وتحرك المؤشرين."
  },
  {
    "question": "ما هو تعقيد Quicksort في الحالة المتوسطة (Average Case)?",
    "options": [
      "O(n)",
      "O(log n)",
      "O(n log n)",
      "O(n²)"
    ],
    "correct": 2,
    "explanation": "في الحالة المتوسطة، Quicksort له تعقيد زمني O(n log n)."
  },
  {
    "question": "ما هو أسوأ حالة لتعقيد Quicksort؟",
    "options": [
      "عندما تكون المصفوفة مرتبة بالفعل",
      "عندما تكون المصفوفة مرتبة عكسياً",
      "الإجابات A و B صحيحتان",
      "عندما يكون المحور دائماً أكبر أو أصغر عنصر"
    ],
    "correct": 2,
    "explanation": "أسوأ حالة تحدث عندما يكون التقسيم غير متوازن بشدة، أي عندما يكون المحور هو العنصر الأصغر أو الأكبر دائماً، مما يؤدي إلى تعقيد O(n²)."
  },
  {
    "question": "كيف يمكن تحسين Quicksort لتجنب الأسوأ حالة؟",
    "options": [
      "باستخدام مصفوفة مساعدة",
      "باستخدام Bubble Sort بدلاً منه",
      "باختيار المحور عشوائياً أو باستخدام median-of-three",
      "بعدم استخدام التقسيم"
    ],
    "correct": 2,
    "explanation": "اختيار محور ذكي (مثل عشوائي أو متوسط أول ووسط وآخر عنصر) يقلل فرص حدوث الأسوأ حالة."
  },
  {
    "question": "في Partition، ماذا تفعل الحلقة while (arr[j] > partitioningElement)؟",
    "options": [
      "تقلل j حتى تجد عنصراً أصغر أو يساوي المحور",
      "تزيد j حتى تجد عنصراً أكبر من المحور",
      "تقلل i",
      "توقف التنفيذ"
    ],
    "correct": 0,
    "explanation": "الهدف هو إيجاد أول عنصر من اليمين أصغر أو يساوي المحور ليتم نقله لليسار."
  },
  {
    "question": "ما هي نتيجة تنفيذ Partition إذا كانت جميع العناصر أصغر من المحور؟",
    "options": [
      "سيتم إرجاع left",
      "سيتم إرجاع right",
      "سيتم إرجاع mid",
      "سيتم إرجاع right + 1"
    ],
    "correct": 3,
    "explanation": "سيظل i يتحرك لليمين حتى النهاية، وسيعود i الذي سيكون right + 1 بعد تجاوز الحلقة."
  },
  {
    "question": "ما نوع الخوارزمية التي تنتمي إليها Quicksort من حيث الاستقرار (Stability)?",
    "options": [
      "مستقرة (Stable)",
      "تعتمد على التنفيذ",
      "غير مستقرة (Unstable)",
      "لا ينطبق"
    ],
    "correct": 2,
    "explanation": "Quicksort غير مستقرة بشكل عام لأن التبديلات قد تغير الترتيب النسبي للعناصر المتساوية."
  },
  {
    "question": "في الكود البرمجي، ما هو نوع المتغير tmp?",
    "options": [
      "char",
      "boolean",
      "int",
      "String"
    ],
    "correct": 2,
    "explanation": "يستخدم tmp كمتغير مؤقت لتبديل قيمتين من نوع int في المصفوفة."
  },
  {
    "question": "ما هو الدور الذي تلعبه العبارة (left + right) / 2 في اختيار المحور؟",
    "options": [
      "تحديد حجم المصفوفة",
      "تحديد عدد العناصر",
      "حساب الفهرس الأوسط بين left و right",
      "حساب مجموع المؤشرين"
    ],
    "correct": 2,
    "explanation": "يتم استخدامه لإيجاد الفهرس الأوسط لتحديد العنصر المحوري."
  },
  {
    "question": "بعد استدعاء quicksort(a, 0, 4) في المثال، ما هو الفهرس المعاد من Partition؟",
    "options": [
      "5",
      "2",
      "3",
      "4"
    ],
    "correct": 2,
    "explanation": "حسب الخطوات في الملف: quicksort(a, 0, 4) أعطت index = 3."
  },
  {
    "question": "ماذا يعني أن تكون Quicksort خوارزمية 'في المكان' (In-place)?",
    "options": [
      "تحتاج إلى مصفوفة مساوية في الحجم",
      "لا تحتاج إلى ذاكرة إضافية أبداً",
      "يتم تنفيذها خارج الذاكرة",
      "لا تحتاج إلى مصفوفة إضافية كبيرة (تستخدم مساحة O(1) إضافية)"
    ],
    "correct": 3,
    "explanation": "Quicksort يعتبر in-place لأنه يستخدم كمية ثابتة من الذاكرة الإضافية بغض النظر عن حجم المدخلات."
  },
  {
    "question": "في Partition، لماذا نستخدم while (i <= j) وليس while (i < j)?",
    "options": [
      "لإيقاف التنفيذ مبكراً",
      "للتأكد من معالجة الحالة التي يتساوى فيها i و j أيضاً",
      "لأنه خطأ، يجب أن يكون i < j",
      "لزيادة السرعة"
    ],
    "correct": 1,
    "explanation": "i <= j تضمن أن تتم معالجة الحالة التي يكون فيها i و j متساويين، وهي حالة قد تحتوي على عنصر يحتاج فحصاً."
  },
  {
    "question": "ما هو أول استدعاء متكرر لليسار بعد إيجاد index = 5 في المثال؟",
    "options": [
      "quicksort(a, 1, 4)",
      "quicksort(a, 0, 5)",
      "quicksort(a, 0, 3)",
      "quicksort(a, 0, 4)"
    ],
    "correct": 3,
    "explanation": "بما أن left = 0 و index = 5، فإن الجزء الأيسر يكون من 0 إلى 4."
  },
  {
    "question": "ما هو الهدف من التبديل بين arr[i] و arr[j] داخل Partition؟",
    "options": [
      "لزيادة سرعة التنفيذ",
      "لتحقيق أن العناصر الأصغر من المحور تكون على يساره والأكبر على يمينه",
      "لحفظ ترتيب العناصر المتساوية",
      "لإنهاء الخوارزمية"
    ],
    "correct": 1,
    "explanation": "التبديل هو الآلية الأساسية لترتيب العناصر حول المحور."
  },
  {
    "question": "كيف يتعامل Quicksort مع العناصر المتساوية مع المحور؟",
    "options": [
      "تذهب كلها لليسار",
      "تذهب كلها لليمين",
      "قد تبقى على أي من الجانبين حسب التنفيذ",
      "يتم حذفها"
    ],
    "correct": 2,
    "explanation": "يعتمد على شروط المقارنة في Partition، في الكود المعطى: العناصر المتساوية مع المحور قد تبقى على أي جانب."
  },
  {
    "question": "ما هو الدور الرئيسي للمتغير partitioningElement?",
    "options": [
      "يحدد عدد التكرارات",
      "يستخدم كمعيار للمقارنة أثناء عملية التقسيم",
      "يخزن حجم المصفوفة",
      "يقارن بين left و right"
    ],
    "correct": 1,
    "explanation": "هو العنصر الذي تتم مقارنة بقية العناصر به لتحديد موقعها النسبي (أيسر أم أيمن)."
  },
  {
    "question": "في المثال، عند تنفيذ quicksort(a, 5, 8)، ما هو الفهرس الذي تم إرجاعه؟",
    "options": [
      "7",
      "6",
      "5",
      "8"
    ],
    "correct": 1,
    "explanation": "حسب الخطوات: quicksort(a, 5, 8) نتج عنه index = 6."
  },
  {
    "question": "ما الذي يحدث بعد return i في Partition؟",
    "options": [
      "يتم إعادة تعيين المحور",
      "يتم استخدام القيمة كـ index في استدعاءات quicksort اللاحقة",
      "تنتهي الخوارزمية",
      "يتم طباعة المصفوفة"
    ],
    "correct": 1,
    "explanation": "يتم إرجاع i ليكون نقطة التقسيم التي تفصل بين الجزأين الأيسر والأيمن."
  },
  {
    "question": "لماذا نقوم بتحريك i و j بعد التبديل؟",
    "options": [
      "لأن القيم تغيرت",
      "لإيقاف الحلقة",
      "لمواصلة الفحص للعناصر التالية",
      "لعدم تكرار التبديل على نفس العنصر"
    ],
    "correct": 2,
    "explanation": "بعد التبديل، العناصر في المواقع i و j أصبحت في مكانها الصحيح، لذا نحرك المؤشرين للاستمرار في فحص بقية العناصر."
  },
  {
    "question": "ما هو الشرط الذي يوقف الحلقة الخارجية while (i <= j)?",
    "options": [
      "عندما يكون arr[i] == arr[j]",
      "عندما يكون left == right",
      "عندما يصبح i == j",
      "عندما يصبح i > j"
    ],
    "correct": 3,
    "explanation": "تستمر الحللة طالما i <= j، وتتوقف عندما يتجاوز i قيمة j."
  },
  {
    "question": "في الكود، ماذا يحدث إذا كان arr[i] == partitioningElement?",
    "options": [
      "يتم تبديله فوراً",
      "تستمر الحللة في الزيادة",
      "تتوقف الحللة الداخلية لتحريك i",
      "ينتقل إلى j"
    ],
    "correct": 2,
    "explanation": "الشرط هو while (arr[i] < partitioningElement)، لذا عند التساوي تتوقف وتنتقل للخطوة التالية."
  },
  {
    "question": "كيف يتم تجنب استدعاء لا نهائي (Infinite Recursion) في Quicksort?",
    "options": [
      "باستخدام حلقة لا نهائية",
      "بفحص إذا كان الجزء يحتوي على أكثر من عنصر قبل الاستدعاء",
      "بعدم استخدام التكرار",
      "بعدم استخدام المحور"
    ],
    "correct": 1,
    "explanation": "يتم التحقق من أن هناك فرقاً بين left و right (أي أكثر من عنصر) قبل إجراء الاستدعاءات المتكررة."
  },
  {
    "question": "ما هو ناتج تنفيذ الكود البرمجي المعطى على المصفوفة المثال؟",
    "options": [
      "نفس المصفوفة",
      "مصفوفة مرتبة تصاعدياً",
      "مصفوفة مرتبة تنازلياً",
      "مصفوفة غير مرتبة"
    ],
    "correct": 1,
    "explanation": "الهدف من Quicksort هو ترتيب المصفوفة تصاعدياً."
  },
  {
    "question": "في Partition، ما الذي يضمن أن العناصر على يسار i كلها <= المحور؟",
    "options": [
      "تجاهل العناصر الصغيرة",
      "عملية تحريك i و j والتبديل",
      "استخدام مصفوفة أخرى",
      "عدم تحريك i أبداً"
    ],
    "correct": 1,
    "explanation": "الخوارزمية تضمن من خلال المقارنة والتبديل أن جميع العناصر من left إلى i-1 هي <= المحور."
  },
  {
    "question": "لماذا قد نفضل استخدام Quicksort على Mergesort في بعض التطبيقات؟",
    "options": [
      "لأنه أكثر استقراراً",
      "لأن تعقيده الزمني مضمون O(n log n) دائماً",
      "لأنه غالباً أسرع في الممارسة وفي المكان (in-place)",
      "لأنه يستخدم ذاكرة إضافية أقل بكثير"
    ],
    "correct": 2,
    "explanation": "Quicksort سريع جداً في المتوسط ويستخدم ذاكرة إضافية قليلة (in-place)، مما يجعله عملياً للعديد من التطبيقات."
  },
  {
    "question": "ما هو نوع الدالة quickSort في الكود؟",
    "options": [
      "دالة تكرارية (Iterative)",
      "دالة رياضية",
      "دالة عودية (Recursive)",
      "دالة ثابتة (Static)"
    ],
    "correct": 2,
    "explanation": "يتم تعريف quickSort على أنها تستدعي نفسها بشكل عودي على أجزاء المصفوفة."
  },
  {
    "question": "كيف تبدأ عملية Partition إذا كانت المصفوفة تحتوي على عنصر واحد؟",
    "options": [
      "تبدأ وتعيد نفس الفهرس",
      "تعيد قيمة 0",
      "لا يتم استدعاؤها لأن left == right",
      "تتوقف عن العمل"
    ],
    "correct": 2,
    "explanation": "في Quicksort، إذا كان left >= right (عنصر واحد أو أقل)، فلا يتم استدعاء Partition أصلاً."
  },
  {
    "question": "في المثال، كم مرة تم استدعاء دالة quicksort بشكل كلي؟",
    "options": [
      "10 مرات",
      "5 مرات",
      "4 مرات",
      "8 مرات"
    ],
    "correct": 3,
    "explanation": "حسب الخطوات المرقمة في الملف من 1 إلى 8، تم استدعاؤها 8 مرات (بما فيها الاستدعاء الأولي)."
  },
  {
    "question": "ما هو دور j في خوارزمية Partition؟",
    "options": [
      "يحسب عدد التبديلات",
      "يخزن قيمة المحور",
      "مؤشر يتحرك من اليمين لليسار للبحث عن عنصر <= المحور",
      "مؤشر يحدد نهاية المصفوفة فقط"
    ],
    "correct": 2,
    "explanation": "j يبدأ من right ويتحرك ناحية left حتى يجد عنصراً <= partitioningElement."
  },
  {
    "question": "هل يمكن تنفيذ Quicksort بدون استخدام الدوال العودية؟",
    "options": [
      "لا، مستحيل",
      "نعم، باستخدام مصفوفة إضافية فقط",
      "نعم، باستخدام مكدس (Stack) لمحاكاة الاستدعاءات",
      "لا، إلا إذا كانت المصفوفة صغيرة"
    ],
    "correct": 2,
    "explanation": "يمكن تنفيذ Quicksort بشكل تكرار باستخدام مكدس لتخزين حدود الأجزاء بدلاً من الاستدعاء العودي."
  }
],
lec6:[
  {
    "question": "ما هي المشكلة التي تحاول خوارزمية جوزيف حلها؟",
    "options": [
      "ترتيب عناصر مصفوفة تصاعدياً",
      "اختيار ناجٍ واحد من مجموعة أشخاص يجلسون في دائرة مع حذف دوري",
      "البحث عن أقصر مسار في الرسم البياني",
      "فرز بيانات باستخدام شجرة ثنائية"
    ],
    "correct": 1,
    "explanation": "خوارزمية جوزيف تحاكي مشكلة اختيار ناجٍ واحد من مجموعة أشخاص يجلسون في دائرة، حيث يتم حذف شخص كل عدة خطوات (m) حتى يبقى شخص واحد."
  },
  {
    "question": "كيف يتم تمثيل الجنود في خوارزمية جوزيف باستخدام الأشجار الثنائية؟",
    "options": [
      "كعقد داخلية في الشجرة",
      "كجذور للأشجار الفرعية",
      "كأوراق (عقد طرفية) في الشجرة الثنائية",
      "كمستويات في الشجرة"
    ],
    "correct": 2,
    "explanation": "الجنود يمثلون كعقد طرفية (أوراق) في الشجرة الثنائية، بينما العقد الداخلية تستخدم لتنظيم عملية العد والحذف."
  },
  {
    "question": "ما هو عدد العقد الكلي (size) المطلوب لتمثيل n جندي في الشجرة الثنائية؟",
    "options": [
      "n",
      "2n",
      "2n - 1",
      "n + 1"
    ],
    "correct": 2,
    "explanation": "عدد العقد الكلي في شجرة ثنائية كاملة لتمثيل n ورقة هو 2n - 1 (n ورقة + n-1 عقد داخلية)."
  },
  {
    "question": "ما هو الغرض من الحقل lcount في العقد الداخلية في هذه الخوارزمية؟",
    "options": [
      "يحفظ اسم الجندي",
      "يحسب عدد الأوراق في الجزء الأيسر من الشجرة الفرعية",
      "يحدد مستوى العقدة في الشجرة",
      "يخزن قيمة خطوة العدد m"
    ],
    "correct": 1,
    "explanation": "يستخدم lcount لحساب عدد الأوراق الموجودة في الجزء الأيسر من الشجرة الفرعية، مما يساعد في تحديد موقع الجندي التالي للحذف."
  },
  {
    "question": "في مرحلة بناء الشجرة، ماذا تمثل العقد من n إلى size؟",
    "options": [
      "عقد داخلية تحتوي على lcount",
      "أوراق تحتوي على معلومات الجنود (info)",
      "جذور الأشجار الفرعية",
      "عقد غير مستخدمة"
    ],
    "correct": 1,
    "explanation": "العقد من n إلى size هي العقد الطرفية (الأوراق) التي تحتوي على معلومات الجنود (info) مثل الأسماء."
  },
  {
    "question": "في مرحلة الحذف، ماذا يحدث عندما تكون العقدة المراد حذفها يسارية؟",
    "options": [
      "يتم زيادة lcount للأب",
      "يتم نقل الأخ مكان الأب مباشرة",
      "يتم تقليل lcount للأب بمقدار 1",
      "يتم حذف الأب أيضاً"
    ],
    "correct": 2,
    "explanation": "إذا كانت العقدة يسارية (الابن الأيسر)، يتم تقليل قيمة lcount في العقدة الأب لأن ورقة من الجزء الأيسر ستُحذف."
  },
  {
    "question": "ما هو الشرط الذي يجعل الأخ (الابن الآخر) يحل محل الأب في الشجرة؟",
    "options": [
      "إذا كان الأخ عقدة داخلية",
      "إذا كان الأخ ورقة (عقدة طرفية)",
      "إذا كان الأب غير مستخدم",
      "إذا كانت العقدة المراد حذفها يسارية"
    ],
    "correct": 1,
    "explanation": "إذا كان الأخ (الابن الآخر) ورقة (عقدة طرفية)، فإنه يحل محل العقدة الأب في البنية لضمان استمرارية الشجرة."
  },
  {
    "question": "في المثال المعطى (n=5, m=3)، من هو الجندي الأول الذي يتم حذفه؟",
    "options": [
      "A",
      "B",
      "C",
      "D"
    ],
    "correct": 2,
    "explanation": "يبدأ العد من A، والخطوة m=3، لذا: A=1، B=2، C=3 ← C هو أول جندي يُحذف."
  },
  {
    "question": "كم عدد مراحل الحذف التي تحدث في خوارزمية جوزيف؟",
    "options": [
      "n",
      "n - 1",
      "m",
      "size"
    ],
    "correct": 1,
    "explanation": "يتم حذف الجنود واحداً تلو الآخر حتى يبقى جندي واحد فقط، لذا عدد مرات الحذف هو n-1."
  },
  {
    "question": "ما هو دور الحلقة التي تبدأ من 2 إلى n في مرحلة الحذف؟",
    "options": [
      "لإدخال الجنود الجدد",
      "لحذف جميع الجنود حتى يبقى واحد",
      "لبناء الشجرة من جديد",
      "لتحديث قيمة m"
    ],
    "correct": 1,
    "explanation": "الحلقة من 2 إلى n تؤدي n-1 عملية حذف (لأننا نحذف حتى يبقى جندي واحد فقط)."
  },
  {
    "question": "ما الذي يُميز العقد من 1 إلى n-1 في الشجرة بعد بنائها؟",
    "options": [
      "تحتوي على أسماء الجنود",
      "قيمة used تكون false",
      "تحتوي على حقل lcount",
      "هي أوراق الشجرة"
    ],
    "correct": 2,
    "explanation": "العقد من 1 إلى n-1 هي العقد الداخلية، وتحتوي على حقل lcount لحساب الأوراق في الجزء الأيسر، وتكون used = true."
  },
  {
    "question": "ماذا يعني أن used = false لعقدة في الشجرة؟",
    "options": [
      "أن العقدة تحتوي على جندي ناجٍ",
      "أن العقدة تم حذفها ولم تعد جزءاً من الشجرة الفعالة",
      "أن العقدة هي جذر الشجرة",
      "أن العقدة تحتوي على قيمة lcount عالية"
    ],
    "correct": 1,
    "explanation": "used = false يعني أن العقدة (الجندي) قد تم حذفها ولم تعد مشاركة في عملية العد والبقاء."
  },
  {
    "question": "في خطوة 'إيجاد أب وأخ جديدين'، ماذا يحدث إذا كان الأخ الجديد غير مستخدم؟",
    "options": [
      "يتم تجاهل العقدة الحالية",
      "تنتقل العقدة الحالية لتحل محل الأب",
      "يتم حذف الأب أيضاً",
      "تتوقف الخوارزمية"
    ],
    "correct": 1,
    "explanation": "إذا كان الأخ الجديد غير مستخدم (محذوف) والعقدة الحالية ورقة، فإن العقدة الحالية تحل محل الأب في البنية."
  },
  {
    "question": "لماذا نبدأ العد من الجندي A في المثال بعد كل حذف؟",
    "options": [
      "لأن A هو دائماً الجندي الأول في القائمة",
      "لأن العد يبدأ من الجندي التالي للذي تم حذفه مباشرة",
      "لأنه قاعدة ثابتة في الخوارزمية",
      "لأن A هو الجذر في الشجرة"
    ],
    "correct": 1,
    "explanation": "بعد كل حذف، يبدأ العد من الجندي التالي مباشرة للذي تم حذفه (في المثال: بعد حذف C، يبدأ العد من D)."
  },
  {
    "question": "في نهاية الخوارزمية، ماذا تحتوي العقدة الجذر؟",
    "options": [
      "اسم الجندي الناجي",
      "قيمة lcount تساوي n",
      "used = false",
      "لا شيء، فهي تحذف"
    ],
    "correct": 0,
    "explanation": "في النهاية، تحتوي العقدة الجذر (أو الورقة المتبقية) على اسم الجندي الناجي الوحيد المتبقي."
  },
  {
    "question": "ما هو عدد مستويات الشجرة عندما n=5؟",
    "options": [
      "2",
      "3",
      "4",
      "5"
    ],
    "correct": 1,
    "explanation": "بحساب size = 2*5 - 1 = 9 عقد، والتمثيل الثنائي الكامل يقود إلى 3 مستويات."
  },
  {
    "question": "أي من العبارات التالية تصف بشكل صحيح مرحلة تعديل lcount؟",
    "options": [
      "تتم فقط عند حذف عقدة يسارية",
      "تتم لجميع العقد في كل مرة",
      "تتم فقط عند إدخال عقد جديدة",
      "لا تتم أبداً"
    ],
    "correct": 0,
    "explanation": "يتم تعديل lcount للأب فقط عندما تكون العقدة المحذوفة هي الابن الأيسر (يسارية)."
  },
  {
    "question": "في المثال، بعد حذف C و A، من يبدأ العد عنده؟",
    "options": [
      "B",
      "D",
      "E",
      "C"
    ],
    "correct": 0,
    "explanation": "بعد حذف A، الجندي التالي هو B، فيبدأ العد من B."
  },
  {
    "question": "ما هو الهدف النهائي من خوارزمية جوزيف؟",
    "options": [
      "ترتيب الجنود أبجدياً",
      "حذف جميع الجنود",
      "البحث عن جندي محدد",
      "تحديد جندي ناجٍ واحد"
    ],
    "correct": 3,
    "explanation": "الهدف هو تحديد جندي واحد يبقى على قيد الحياة (الناجي) بعد حذف جميع الآخرين وفق قاعدة العد."
  },
  {
    "question": "ماذا يحدث إذا كانت العقدة الأخ (b) ليست ورقة؟",
    "options": [
      "يتوقف الحذف",
      "يتم حذف الأب مباشرة",
      "يتم البحث عن أب وأخ جديدين والاستمرار",
      "تنتقل العقدة الحالية لتحل محل الأب"
    ],
    "correct": 2,
    "explanation": "إذا لم يكن الأخ ورقة، ننتقل إلى مستوى أعلى (أب وأخ جديدين) ونواصل التعديلات حتى نصل إلى حالة يمكن فيها إعادة الهيكلة."
  },
  {
    "question": "كيف يتم تحديد رقم الجندي المحذوف في كل دورة؟",
    "options": [
      "باستخدام دالة find_num التي تحسب الموقع بناءً على m وموقف البداية",
      "باختيار عشوائي",
      "باختيار أول ورقة في الشجرة",
      "باستخدام قيمة lcount فقط"
    ],
    "correct": 0,
    "explanation": "يتم استخدام دالة find_num (أو منطق مكافئ) لتحديد موقع الجندي التالي للحذف بناءً على خطوة العدد m والموقع الحالي."
  },
  {
    "question": "في مرحلة البناء، لماذا ندخل عقد أوراق في المستوى قبل الأخير أيضاً؟",
    "options": [
      "لأن الشجرة قد لا تكون كاملة تماماً",
      "لأن n قد يكون فردياً",
      "لأنه خطأ في الخوارزمية",
      "لزيادة سرعة التنفيذ"
    ],
    "correct": 0,
    "explanation": "لأن الشجرة الثنائية قد لا تكون كاملة تماماً (كاملة بالمعنى الدقيق)، فقد يكون هناك أوراق في المستوى قبل الأخير إذا كان n ليس قوة للعدد 2."
  },
  {
    "question": "ما هي القيمة الابتدائية لـ used لجميع العند بعد البناء؟",
    "options": [
      "true",
      "false",
      "تعتمد على الموقع",
      "لا يوجد used"
    ],
    "correct": 0,
    "explanation": "بعد مرحلة البناء، جميع العقد تكون مستخدمة، لذا used = true لجميع العقد من 1 إلى size."
  },
  {
    "question": "في المثال، من هو الجندي الناجي؟",
    "options": [
      "A",
      "B",
      "C",
      "D"
    ],
    "correct": 3,
    "explanation": "بعد حذف C, A, E, B، يبقى الجندي D ناجياً."
  },
  {
    "question": "ما هو دور العقد الداخلية (من 1 إلى n-1) أثناء عملية الحذف؟",
    "options": [
      "تخزين أسماء الجنود",
      "توجيه عملية العد وتحديد موقع الحذف عبر lcount",
      "الحذف مباشرة",
      "لا دور لها"
    ],
    "correct": 1,
    "explanation": "العقد الداخلية تستخدم قيم lcount لتوجيه عملية العد وتحديد أي ورقة (جندي) هي التالية في الترتيب للحذف."
  },
  {
    "question": "كيف تؤثر خطوة العدد m على عملية الحذف؟",
    "options": [
      "لا تؤثر",
      "تحدد عدد الجنود الذين يحذفون في كل مرة",
      "تحدد عدد الدورات قبل البدء",
      "تحدد الفاصل بين الجنود الذين يحذفون"
    ],
    "correct": 3,
    "explanation": "m تحدد الفاصل (العد) بين الجنود الذين يتم حذفهم. مثال: m=3 يعني أننا نحذف كل جندي ثالث في التسلسل الحالي."
  },
  {
    "question": "ما هو الغرض من استخدام شجرة ثنائية في خوارزمية جوزيف (بدلاً من قائمة مرتبة بسيطة)؟",
    "options": [
      "لتحسين الكفاءة الزمنية لعملية البحث والحذف",
      "لجعل الكود أكثر تعقيداً",
      "لأنها أسهل في الفهم",
      "لا فرق"
    ],
    "correct": 0,
    "explanation": "استخدام شجرة ثنائية يسمح بإجراء عمليات البحث عن الجندي التالي للحذف وتعديل البنية بكفاءة أفضل (O(log n) في الحالات المتوازنة) مقارنة بالقائمة الخطية (O(n))."
  },
  {
    "question": "ماذا يحدث إذا كانت العقدة المراد حذفها هي أيضاً الأخ (الابن الآخر) في العلاقة الجديدة؟",
    "options": [
      "تتوقف الخوارزمية",
      "يتم حذف الأب أيضاً",
      "تستمر الخوارزمية بالبحث عن أب وأخ جديدين",
      "تنتقل العقدة لتحل محل نفسها"
    ],
    "correct": 2,
    "explanation": "حتى بعد الانتقال إلى أب وأخ جديدين، قد تستمر الحاجة للتعديل، لذا تستمر العملية بشكل متكرر (while loop) حتى تصل إلى حالة مستقرة (كالجذر)."
  },
  {
    "question": "في المثال، كم عدد العقد الداخلية (غير الأوراق)؟",
    "options": [
      "4",
      "5",
      "9",
      "1"
    ],
    "correct": 0,
    "explanation": "عدد العقد الداخلية = n - 1 = 5 - 1 = 4."
  },
  {
    "question": "أي من هذه الخطوات ليست جزءاً من مرحلة بناء الشجرة؟",
    "options": [
      "تحديد size = 2n - 1",
      "حلقة لإدخال العقد الأوراق في المستوى الأخير",
      "حلقة لحذف الجنود بالتسلسل",
      "تعديل lcount للآباء"
    ],
    "correct": 2,
    "explanation": "حلقة حذف الجنود هي جزء من مرحلة الحذف، وليست من مرحلة البناء."
  },
  {
    "question": "بعد حذف جندي، كيف يتم 'العد' للجندي التالي؟",
    "options": [
      "يبدأ من أول جندي في القائمة دائماً",
      "يبدأ من الجندي التالي مباشرة للمحذوف في التسلسل الأصلي",
      "يتم إعادة بناء الشجرة كاملة",
      "يستخدم قيمة lcount فقط"
    ],
    "correct": 1,
    "explanation": "بعد حذف جندي، يبدأ العد للخطوة التالية من الجندي الذي يليه مباشرة في الدائرة (التسلسل الحالي بعد الحذف)."
  },
  {
    "question": "ما هو الشرط الذي ينتهي عنده التكرار في خطوة 'إيجاد أب وأخ جديدين' أثناء الحذف؟",
    "options": [
      "عندما نصل إلى عقدة ورقة",
      "عندما نصل إلى الجذر",
      "عندما يكون lcount = 0",
      "عندما used = false"
    ],
    "correct": 1,
    "explanation": "يستمر التكرار (while loop) حتى تصل العملية إلى الجذر (العقدة 1) أو تتحقق شروط إعادة الهيكلة دون الحاجة لمزيد من الصعود."
  },
  {
    "question": "ما هو نوع البيانات المخزّن في العقد الأوراق؟",
    "options": [
      "lcount",
      "info (مثل اسم الجندي)",
      "used فقط",
      "مؤشر للأب"
    ],
    "correct": 1,
    "explanation": "العقد الأوراق تخزن info (معلومات الجندي، مثل الاسم)، بينما العقد الداخلية تخزن lcount."
  },
  {
    "question": "في المثال، ما هو تسلسل الحذف الكامل؟",
    "options": [
      "C, A, E, B, D",
      "A, B, C, D, E",
      "C, A, B, E, D",
      "C, A, E, B"
    ],
    "correct": 3,
    "explanation": "التسلسل: C أولاً، ثم A، ثم E، ثم B، ويبقى D ناجياً."
  },
  {
    "question": "ماذا يحدث لقيمة lcount عندما يحل الأخ (الورقة) مكان الأب؟",
    "options": [
      "تنتقل قيمة lcount للأخ",
      "تُنسى قيمة lcount",
      "تظل كما هي عند الأب",
      "تُضبط لتعكس الهيكل الجديد"
    ],
    "correct": 1,
    "explanation": "عندما يحل الأخ (الورقة) مكان الأب، فإن العقدة الجديدة (التي كانت الأخ) تصبح عقدة داخلية وقد تحتاج إلى ضبط lcount الخاص بها ليعكس هيكل الشجرة الفرعية تحتها."
  },
  {
    "question": "كم مرة يتم تعديل lcount خلال حذف جندي واحد؟",
    "options": [
      "مرة واحدة دائماً",
      "مرتين دائماً",
      "يعتمد على موقع العقدة وعلاقاتها",
      "أبداً"
    ],
    "correct": 2,
    "explanation": "عدد مرات تعديل lcount يعتمد على الموقف: إذا كانت العقدة يسارية يتم تعديله مرة على الأقل، وقد يتم تعديله مرة أخرى أثناء عملية إعادة الهيكلة اللاحقة."
  },
  {
    "question": "ما الفرق بين 'الأب' و'الأخ' في خطوات الحذف؟",
    "options": [
      "الأب هو العقدة الحالية، والأخ هو الجذر",
      "الأب هو العقدة الأعلى مباشرة، والأخ هو الابن الآخر لنفس الأب",
      "لا فرق، هما نفس العقدة",
      "الأخ هو العقدة الحالية، والأب هو الابن الآخر"
    ],
    "correct": 1,
    "explanation": "في سياق الشجرة الثنائية، 'الأب' هو العقدة الأصل المباشرة للعقدة الحالية، و'الأخ' هو العقدة الأخرى التي تشترك مع العقدة الحالية في نفس الأب (الابن الآخر)."
  },
  {
    "question": "لماذا نحتاج إلى حلقة while في قسم حذف الجندي (الخطوة ج) كما أشارت المعيدة؟",
    "options": [
      "لحذف جميع الجنود دفعة واحدة",
      "لأن تعديل الشجرة بعد الحذف قد يتطلب عدة خطوات متكررة حتى الاستقرار",
      "لإدخال جنود جدد",
      "لأن m قد يتغير"
    ],
    "correct": 1,
    "explanation": "قد تتطلب عملية حذف عقدة وإعادة هيكلة الشجرة (مثل نقل أخ مكان أب، ثم البحث عن أب وأخ جديدين) التكرار عدة مرات حتى نصل إلى هيكل مستقر (مثل الوصول للجذر)."
  },
  {
    "question": "في نهاية الخوارزمية، ماذا تكون قيمة used للجندي الناجي؟",
    "options": [
      "true",
      "false",
      "مجهولة",
      "لا يوجد used"
    ],
    "correct": 0,
    "explanation": "الجندي الناجي هو العقدة الوحيدة المتبقية المستخدمة، لذا used = true."
  },
  {
    "question": "ما هو التمثيل الرياضي لعدد العقد في المستوى الأخير إذا كانت الشجرة ثنائية كاملة؟",
    "options": [
      "n",
      "2^(d-1) حيث d عدد المستويات",
      "size",
      "n-1"
    ],
    "correct": 1,
    "explanation": "في شجرة ثنائية كاملة، عدد العقد في المستوى الأخير (الأوراق) هو 2^(d-1)، حيث d هو عمق (عدد مستويات) الشجرة."
  },
  {
    "question": "هل يمكن استخدام هذه الخوارزمية لقيم كبيرة من n وm؟",
    "options": [
      "نعم، ولكن كفاءتها تعتمد على توازن الشجرة",
      "لا، فهي فقط للقيم الصغيرة",
      "نعم، ولكن فقط إذا كانت m=1",
      "لا، فهي تجريبية فقط"
    ],
    "correct": 0,
    "explanation": "نعم، يمكن استخدامها لقيم كبيرة، وكفاءتها الزمنية تكون O(n log n) في الحالات الجيدة، ولكنها تعتمد على كيفية تنظيم الشجرة وتوازنها."
  }
]
            
            }
        },
        circuits: {
            name: "نظرية المخططات",
            lectures: {
              lec1:[
  {
    "question": "ما هو التعريف الأساسي للمخطط البياني (Graph) في نظرية المخططات؟",
    "options": [
      "مجموعة من الصيغ الرياضية والمعادلات",
      "مجموعة منتهية من العقد ومجموعة منتهية من الحواف تربط بينها",
      "شبكة اتصالات حاسوبية فقط",
      "مخطط انسيابي لخوارزمية"
    ],
    "correct": 1,
    "explanation": "المخطط البياني هو بنية رياضية مجردة تتكون من مجموعة من العقد (Vertices) ومجموعة من الحواف (Edges) التي تربط بين أزواج من هذه العقد."
  },
  {
    "question": "كيف يُرمز للمخطط البياني رياضيًا؟",
    "options": [
      "G(V, E) حيث V مجموعة العقد و E مجموعة الحواف",
      "F(x, y) حيث x و y متغيرات",
      "A[n][n] حيث n عدد العقد",
      "T(n) حيث n حجم الإدخال"
    ],
    "correct": 0,
    "explanation": "يُرمز للمخطط بالشكل G(V, E)، حيث V تمثل مجموعة العقد (Vertices) و E تمثل مجموعة الحواف (Edges)."
  },
  {
    "question": "ما هي درجة العقدة (Degree of a Vertex) في مخطط غير موجه؟",
    "options": [
      "عدد الحواف المرتبطة بتلك العقدة، مع احتساب الحلقة مرتين",
      "عدد العقد المجاورة لها فقط",
      "وزن العقدة في الخوارزمية",
      "عدد المكونات المتصلة التي تنتمي إليها"
    ],
    "correct": 0,
    "explanation": "درجة العقدة في مخطط غير موجه هي عدد الحواف المتصلة بها. إذا كانت هناك حلقة (edge تربط العقدة بنفسها) فإنها تساهم بدرجتين في درجة تلك العقدة."
  },
  {
    "question": "ما هي العقدة المعزولة (Isolated Vertex)؟",
    "options": [
      "عقدة درجة تساوي 1",
      "عقدة ليس لها جيران",
      "عقدة درجة تساوي 0",
      "عقدة تقع على حافة المخطط"
    ],
    "correct": 2,
    "explanation": "العقدة المعزولة هي عقدة لا تتصل بأي حافة أخرى، وبالتالي درجة تساوي 0."
  },
  {
    "question": "ما هي العقدة المعلقة (Pendant Vertex)؟",
    "options": [
      "عقدة درجة تساوي 0",
      "عقدة درجة تساوي 1",
      "عقدة تقع في مركز المخطط",
      "عقدة لها حلقة"
    ],
    "correct": 1,
    "explanation": "العقدة المعلقة (أو الورقية) هي عقدة درجة تساوي 1، أي تتصل بحافة واحدة فقط."
  },
  {
    "question": "ما هي 'الحلقة' (Loop) في المخطط البياني؟",
    "options": [
      "حافة تربط عقدتين متماثلتين في الدرجة",
      "حافة تربط عقدة بنفسها",
      "مسار مغلق يمر بعدة عقد",
      "حافتان لهما نفس العقد الطرفية"
    ],
    "correct": 1,
    "explanation": "الحلقة هي حافة تبدأ وتنتهي عند نفس العقدة. في المصفوفة المجاورة، تظهر على القطر الرئيسي بقيمة (عادة 1 أو 2 حسب الاصطلاح)."
  },
  {
    "question": "ما هي 'الحواف المتوازية' (Parallel Edges)؟",
    "options": [
      "حواف لها نفس الاتجاه في مخطط موجه",
      "حواف لا تتقاطع عند رسمها",
      "حواف متعددة تربط نفس الزوج من العقد",
      "حواف لها نفس الطول أو الوزن"
    ],
    "correct": 2,
    "explanation": "الحواف المتوازية (أو المتعددة) هي حافتان أو أكثر تربط نفس الزوج من العقد. وجودها يعني أن المخطط ليس بسيطاً (Not Simple)."
  },
  {
    "question": "ما هو المخطط البسيط (Simple Graph)؟",
    "options": [
      "مخطط خالٍ من الحلقات والحواف المتوازية",
      "مخطط له عقدتان فقط",
      "مخطط يمكن رسمه دون تقاطع للحواف",
      "مخطط جميع درجات عقدة متساوية"
    ],
    "correct": 0,
    "explanation": "المخطط البسيط هو مخطط غير موجه، لا يحتوي على حلقات (حواف من عقدة إلى نفسها) ولا على حواف متوازية (أكثر من حافة تربط نفس الزوج من العقد)."
  },
  {
    "question": "ما هي العلاقة بين مجموع درجات جميع العقد وعدد الحواف في مخطط غير موجه؟",
    "options": [
      "مجموع الدرجات = عدد الحواف",
      "مجموع الدرجات = عدد العقد",
      "مجموع الدرجات = 2 × عدد الحواف",
      "مجموع الدرجات = عدد العقد × عدد الحواف"
    ],
    "correct": 2,
    "explanation": "تنص نظرية المصافحة (Handshaking Lemma) على أن مجموع درجات جميع العقد في أي مخطط غير موجه يساوي ضعف عدد الحواف. لأن كل حافة تساهم بدرجتين في المجموع الكلي (واحدة لكل طرف)."
  },
  {
    "question": "ما هو المخطط التام (Complete Graph) الذي يرمز له بـ Kn؟",
    "options": [
      "مخطط يكون فيه كل عقدة متصلة بجميع العقد الأخرى بحافة واحدة",
      "مخطط منتظم (Regular) فقط",
      "مخطط يحتوي على أكبر عدد ممكن من الحواف دون حلقات",
      "مخطط يمكن تقسيم عقدة إلى مجموعتين"
    ],
    "correct": 0,
    "explanation": "المخطط التام Kn هو مخطط بسيط غير موجه يحتوي على n عقدة، حيث كل زوج متميز من العقد متصل بحافة واحدة. درجة كل عقدة فيه هي n-1."
  },
  {
    "question": "كم عدد الحواف في المخطط التام K10؟",
    "options": [
      "10",
      "45",
      "90",
      "100"
    ],
    "correct": 1,
    "explanation": "عدد الحواف في المخطط التام Kn هو n(n-1)/2. لذا، لـ K10: 10*9/2 = 45."
  },
  {
    "question": "ما هو المخطط المنتظم (Regular Graph)؟",
    "options": [
      "مخطط جميع عقدة لها نفس الدرجة",
      "مخطط يمكن رسمه بشكل متماثل",
      "مخطط خالٍ من العقد المعلقة",
      "مخطط تام (Complete)"
    ],
    "correct": 0,
    "explanation": "المخطط المنتظم هو مخطط تكون فيه درجة جميع العقد متساوية. إذا كانت الدرجة المشتركة هي r، فيسمى مخططاً منتظماً من الدرجة r."
  },
  {
    "question": "هل كل مخطط تام (Complete) هو مخطط منتظم (Regular)؟",
    "options": [
      "نعم، دائماً",
      "لا، أبداً",
      "فقط إذا كان عدد العقد فردياً",
      "فقط إذا كان عدد العقد زوجياً"
    ],
    "correct": 0,
    "explanation": "نعم، كل مخطط تام Kn هو منتظم، لأن درجة كل عقدة فيه هي n-1 (نفس القيمة لجميع العقد)."
  },
  {
    "question": "ما هو المخطط ذو القسمين (Bipartite Graph)؟",
    "options": [
      "مخطط يمكن تقسيم عقدة إلى مجموعتين بحيث تكون جميع الحواف بين المجموعتين فقط (لا حواف داخل مجموعة)",
      "مخطط يحتوي على قسمين منفصلين غير متصلين",
      "مخطط جميع عقدة في القسم الأول لها نفس الدرجة",
      "مخطط تام"
    ],
    "correct": 0,
    "explanation": "في المخطط ذي القسمين، يمكن تقسيم مجموعة العقد V إلى مجموعتين فرعيتين منفصلتين U و V، بحيث تكون كل حافة في المخطط مربوطة بعقدة من U وأخرى من V. لا توجد حواف تربط بين عقدتين تنتميان لنفس المجموعة."
  },
  {
    "question": "ما هو المخطط ذو القسمين التام (Complete Bipartite Graph) K_{m,n}؟",
    "options": [
      "مخطط جميع عقد القسم الأول متصلة مع بعضها، وجميع عقد القسم الثاني متصلة مع بعضها",
      "مخطط كل عقدة في القسم الأول متصلة بكل عقدة في القسم الثاني، ولا توجد حواف أخرى",
      "مخطط منتظم ذو قسمين",
      "مخطط بسيط ذو قسمين"
    ],
    "correct": 1,
    "explanation": "المخطط ذو القسمين التام K_{m,n} هو مخطط يمكن تقسيم عقدة إلى مجموعتين بحجم m و n، حيث تكون كل عقدة في المجموعة الأولى متصلة بكل عقدة في المجموعة الثانية، ولا توجد حواف داخل أي من المجموعتين."
  },
  {
    "question": "كم عدد الحواف في المخطط K_{2,3}؟",
    "options": [
      "5",
      "6",
      "8",
      "9"
    ],
    "correct": 1,
    "explanation": "عدد الحواف في K_{m,n} هو m * n. لذا، لـ K_{2,3}: 2 * 3 = 6."
  },
  {
    "question": "ما هو المخطط الجزئي (Subgraph)؟",
    "options": [
      "مخطط مشتق من مخطط آخر بحذف بعض الحواف فقط",
      "مخطط مشتق من مخطط آخر بحذف بعض العقد فقط",
      "مخطط تكون مجموعة عقدة مجموعة جزئية من عقد مخطط آخر، ومجموعة حوافه مجموعة جزئية من حوافه، مع الحفاظ على اتصال الحواف بالعقد المتبقية",
      "مخطط أصغر حجمًا ولكن له نفس شكل المخطط الأصلي"
    ],
    "correct": 2,
    "explanation": "المخطط الجزئي G' لمخطط G هو مخطط تكون مجموعة عقدة V' مجموعة فرعية من V، ومجموعة حوافه E' مجموعة فرعية من E، مع شرط أن تكون نهايات كل حافة في E' موجودة في V'."
  },
  {
    "question": "أي مما يلي يمثل مخططًا فارغًا (Empty Graph)؟",
    "options": [
      "مخطط لا يحتوي على عقد ولا حواف",
      "مخطط يحتوي على عقد ولكن لا حواف",
      "مخطط يحتوي على عقدة واحدة فقط",
      "مخطط يحتوي على حواف ولكن لا عقد"
    ],
    "correct": 1,
    "explanation": "المخطط الفارغ (Empty Graph) هو مخطط يحتوي على عقد (واحدة أو أكثر) ولكن لا يحتوي على أي حواف. يُسمى أحياناً مخططاً منفصلاً (Discrete Graph)."
  },
  {
    "question": "ما هو المخطط التافه (Trivial Graph)؟",
    "options": [
      "مخطط لا يحتوي على عقد ولا حواف",
      "مخطط يحتوي على عقدة واحدة فقط (وقد يكون لها حلقات أم لا)",
      "مخطط بسيط",
      "مخطط منتظم من الدرجة 1"
    ],
    "correct": 1,
    "explanation": "المخطط التافه هو أبسط مخطط ممكن، ويتكون من عقدة واحدة فقط (وقد تحتوي على حلقات أو لا)."
  },
  {
    "question": "في مصفوفة الجوار (Adjacency Matrix) لمخطط غير موجه وبسيط، ماذا نلاحظ عن القطر الرئيسي؟",
    "options": [
      "جميع قيمه تساوي 1",
      "جميع قيمه تساوي 0",
      "قيمه تمثل درجة كل عقدة",
      "قيمه تمثل وزن الحواف"
    ],
    "correct": 1,
    "explanation": "في المخطط البسيط (لا حلقات)، لا توجد حواف من عقدة إلى نفسها، لذلك تكون جميع الإدخالات على القطر الرئيسي لمصفوفة الجوار تساوي 0."
  },
  {
    "question": "في مصفوفة الجوار، كيف نعرف درجة العقدة i في مخطط غير موجه؟",
    "options": [
      "بجمع عناصر الصف i",
      "بجمع عناصر العمود i",
      "بعد الأصفار في الصف i",
      "الإجابتان 1 و 2 صحيحتان"
    ],
    "correct": 3,
    "explanation": "في مصفوفة الجوار لمخطط غير موجه (وهي مصفوفة متماثلة)، درجة العقدة i تساوي مجموع عناصر الصف i، أو مجموع عناصر العمود i."
  },
  {
    "question": "في مصفوفة الجوار، ماذا يعني أن العنصر A[i][j] = 2 (حيث i ≠ j)؟",
    "options": [
      "أن هناك حافتين متوازيتين تربطان العقدتين i و j",
      "أن هناك حافة واحدة بوزن 2",
      "أن العقدتين i و j غير متصلتين",
      "أن العقدة i درجة 2"
    ],
    "correct": 0,
    "explanation": "في مخطط غير موجه، القيمة A[i][j] تمثل عدد الحواف بين العقدتين i و j. إذا كانت القيمة 2 (أو أكثر)، فهذا يدل على وجود حواف متوازية، وبالتالي المخطط ليس بسيطاً."
  },
  {
    "question": "ما هي مصفوفة الوقوع (Incidence Matrix)؟",
    "options": [
      "مصفوفة مربعة عدد صفوفها وأعمدتها يساوي عدد العقد",
      "مصفوفة غير مربعة، عدد صفوفها هو عدد العقد وعدد أعمدتها هو عدد الحواف",
      "مصفوفة تمثل أوزان الحواف",
      "مصفوفة متماثلة"
    ],
    "correct": 1,
    "explanation": "مصفوفة الوقوع هي تمثيل للمخطط حيث الصفوف تمثل العقد والأعمدة تمثل الحواف. الإدخال يكون 1 إذا كانت العقدة طرفاً للحافة، و0 إذا لم تكن. في المخطط غير الموجه، مجموع أي عمود هو 2."
  },
  {
    "question": "في مصفوفة الوقوع، ماذا يعني وجود الرقم 2 في إدخال ما؟",
    "options": [
      "وجود حافتين متوازيتين",
      "وجود حافة موجهة",
      "وجود حلقة (Loop)",
      "وجود عقدة معزولة"
    ],
    "correct": 2,
    "explanation": "في مصفوفة الوقوع، إذا كانت الحافة تمثل حلقة (تربط العقدة بنفسها)، فإن الإدخال المقابل لتلك العقدة وذلك العمود يكون 2 (أو 1 حسب الاصطلاح، لكن الرقم 2 شائع للإشارة إلى أن العقدة هي الطرفان للحلقة)."
  },
  {
    "question": "ما هي قائمة الجوار (Adjacency List)؟",
    "options": [
      "مصفوفة ثنائية الأبعاد",
      "مصفوفة وقوع",
      "قائمة مرتبطة (أو مصفوفة ديناميكية) لكل عقدة، تحتوي على العقد المجاورة لها",
      "قائمة مرتبة تصاعدياً لدرجات العقد"
    ],
    "correct": 2,
    "explanation": "قائمة الجوار هي تمثيل للمخطط حيث لكل عقدة، نخزن قائمة (مصفوفة ديناميكية، قائمة مرتبطة، إلخ) تحتوي على جميع العقد المجاورة لها. هذا التمثيل فعال للمخططات المتناثرة (قليلة الحواف)."
  },
  {
    "question": "ما هو المخطط الموجّه (Directed Graph)؟",
    "options": [
      "مخطط تكون حوافه عبارة عن خطوط مستقيمة",
      "مخطط تكون حوافه لها اتجاه، ممثلة بأسهم من عقدة مصدر إلى عقدة هدف",
      "مخطط يمكن رسمه في مستوى دون تقاطع للحواف",
      "مخطط جميع عقدة لها نفس عدد الحواف الداخلة والخارجة"
    ],
    "correct": 1,
    "explanation": "في المخطط الموجه (Digraph)، لكل حافة اتجاه محدد، تذهب من عقدة مصدر (Tail) إلى عقدة هدف (Head). العلاقة غير متماثلة بالضرورة."
  },
  {
    "question": "في المخطط الموجه، ما الفرق بين درجة الدخول (In-degree) ودرجة الخروج (Out-degree) للعقدة؟",
    "options": [
      "درجة الدخول: عدد الحواف الخارجة منها، درجة الخروج: عدد الحواف الداخلة إليها",
      "درجة الدخول: عدد الحواف الداخلة إليها، درجة الخروج: عدد الحواف الخارجة منها",
      "هما نفس المفهوم، ويساويان درجة العقدة",
      "لا يوجد فرق، كلاهما يحسب جميع الحواف المتصلة بها"
    ],
    "correct": 1,
    "explanation": "في المخطط الموجه: درجة الدخول (In-degree) للعقدة v هي عدد الحواف التي تنتهي عندها (تأتي إليها). درجة الخروج (Out-degree) للعقدة v هي عدد الحواف التي تبدأ منها (تخرج منها)."
  },
  {
    "question": "ما هي مشكلة البائع المتجول (TSP) المذكورة كتطبيق لنظرية المخططات؟",
    "options": [
      "إيجاد أقصر مسار يزور كل عقدة مرة واحدة بالضبط ويعود إلى نقطة البداية",
      "إيجاد أي مسار بين عقدتين",
      "تلوين عقد المخطط بحيث لا تتشابه ألوان العقد المتجاورة",
      "إيجاد أكبر مجموعة عقد غير متجاورة"
    ],
    "correct": 0,
    "explanation": "مشكلة البائع المتجول (Traveling Salesman Problem - TSP) هي مشكلة شهيرة في التحسين: إيجاد أقصر مسار ممكن (أو أقل تكلفة) يزور مجموعة من المدن (العقد) مرة واحدة بالضبط ويعود إلى المدينة التي بدأ منها."
  },
  {
    "question": "ما هي فائدة تمثيل المسائل على شكل مخططات؟",
    "options": [
      "لجعلها أكثر تعقيداً",
      "لتوفير وجهة نظر مجردة وأدوات رياضية وخوارزمية مناسبة للحل",
      "لأن جميع المسائل هي مخططات بالأصل",
      "لتحويلها إلى مشاكل هندسية فقط"
    ],
    "correct": 1,
    "explanation": "تمثيل المسألة كمخطط يسمح لنا بتجريد التفاصيل غير الضرورية والتركيز على العلاقات (الحواف) بين الكيانات (العقد). هذا يفتح الباب لتطبيق مجموعة واسعة من النظريات والخوارزميات المعروفة في نظرية المخططات لحل المسألة بكفاءة."
  },
  {
    "question": "ماذا نستنتج من مصفوفة جوار جميع إدخالاتها (عدا القطر) هي 1؟",
    "options": [
      "المخطط منتظم (Regular)",
      "المخطط تام (Complete)",
      "المخطط ذو قسمين (Bipartite)",
      "المخطط شجرة (Tree)"
    ],
    "correct": 1,
    "explanation": "إذا كانت جميع الإدخالات خارج القطر الرئيسي في مصفوفة الجوار (لمخطط غير موجه) تساوي 1، فهذا يعني أن كل زوج من العقد المتميزة متصل بحافة واحدة بالضبط. هذا هو تعريف المخطط التام (Complete Graph)."
  },
  {
    "question": "إذا كان لدينا مخطط منتظم من الدرجة 3 وبه 6 عقد، فما عدد حوافه؟",
    "options": [
      "9",
      "10",
      "12",
      "18"
    ],
    "correct": 0,
    "explanation": "باستخدام نظرية المصافحة: مجموع الدرجات = عدد العقد × الدرجة المشتركة = 6 × 3 = 18. وبما أن مجموع الدرجات = 2 × عدد الحواف، فإن عدد الحواف = 18 / 2 = 9."
  },
  {
    "question": "أي من التمثيلات التالية يكون الأفضل للمخططات الكثيفة جداً (ذات عدد حواف قريب من الحد الأقصى)؟",
    "options": [
      "قائمة الجوار (Adjacency List)",
      "مصفوفة الجوار (Adjacency Matrix)",
      "قائمة الحواف (Edge List)",
      "مصفوفة الوقوع (Incidence Matrix)"
    ],
    "correct": 1,
    "explanation": "لمخططات الكثيفة (حيث عدد الحواف E قريب من V^2)، تكون مصفوفة الجوار فعالة من حيث سرعة الوصول (O(1) للتحقق من وجود حافة) والمساحة الإضافية قليلة نسبياً لأن المصفوفة ستكون ممتلئة إلى حد كبير."
  },
  {
    "question": "أي من التمثيلات التالية يكون الأفضل للمخططات المتناثرة (قليلة الحواف)؟",
    "options": [
      "قائمة الجوار (Adjacency List)",
      "مصفوفة الجوار (Adjacency Matrix)",
      "قائمة الجوار والمصفوفة لهما نفس الكفاءة",
      "مصفوفة الوقوع"
    ],
    "correct": 0,
    "explanation": "لمخططات المتناثرة (حيث E << V^2)، فإن قائمة الجوار توفر مساحة ذاكرة أفضل بكثير (O(V+E)) مقارنة بمصفوفة الجوار (O(V^2))."
  },
  {
    "question": "ما الشرط الذي يجب أن يتحقق في مصفوفة الجوار لمخطط غير موجه؟",
    "options": [
      "يجب أن تكون متماثلة حول القطر الرئيسي",
      "يجب أن تكون جميع عناصر القطر الرئيسي 1",
      "يجب أن يكون مجموع كل صف مساوياً لعدد العقد",
      "يجب أن تكون مربعة وقيمتها المحددة لا تساوي الصفر"
    ],
    "correct": 0,
    "explanation": "بما أن الحافة في المخطط غير الموجه تربط عقدتين بشكل متماثل، فإن وجود حافة بين i و j يعني أيضًا وجودها بين j و i. لذلك، تكون مصفوفة الجوار متماثلة: A[i][j] = A[j][i] لجميع i, j."
  },
  {
    "question": "كيف يمكن التعرف على العقدة المعلقة (Pendant) من خلال مصفوفة الجوار؟",
    "options": [
      "عندما يكون مجموع صفها يساوي 0",
      "عندما يكون مجموع صفها يساوي 1",
      "عندما يكون هناك عنصر واحد فقط في صفها قيمته 1 والباقي 0",
      "عندما تكون مرتبطة فقط بالعقدة التي لها أعلى درجة"
    ],
    "correct": 1,
    "explanation": "العقدة المعلقة درجة تساوي 1. في مصفوفة الجوار لمخطط غير موجه، هذا يعني أن مجموع عناصر الصف (أو العمود) الخاص بتلك العقدة يساوي 1."
  },
  {
    "question": "إذا كان مجموع درجات جميع العقد في مخطط ما هو 24، فما عدد حواف هذا المخطط؟",
    "options": [
      "6",
      "12",
      "24",
      "48"
    ],
    "correct": 1,
    "explanation": "طبقاً لنظرية المصافحة: مجموع الدرجات = 2 * عدد الحواف. إذن، عدد الحواف = مجموع الدرجات / 2 = 24 / 2 = 12."
  },
  {
    "question": "ماذا يسمى المخطط الذي لا يحتوي على أي عقد أو حواف؟",
    "options": [
      "المخطط التافه (Trivial)",
      "المخطط الفارغ (Empty)",
      "المخطط المعدوم (Null)",
      "المخطط البسيط (Simple)"
    ],
    "correct": 2,
    "explanation": "المخطط المعدوم (Null Graph) هو المخطط الذي تكون مجموعتي V و E فارغتين. وهو حالة خاصة نادراً ما يتم دراستها."
  },
  {
    "question": "هل يمكن أن يكون عدد العقد ذات الدرجة الفردية في مخطط غير موجه عدداً فردياً؟",
    "options": [
      "نعم، يمكن",
      "لا، مستحيل. يجب أن يكون عددها زوجياً دائماً",
      "يمكن فقط إذا كان المخطط غير متصل",
      "يمكن فقط إذا كان المخطط منتظماً"
    ],
    "correct": 1,
    "explanation": "هذه نتيجة مباشرة لنظرية المصافحة. بما أن مجموع جميع الدرجات عدد زوجي (2E)، فإن مجموع الدرجات الفردية يجب أن يكون زوجياً أيضاً. والطريقة الوحيدة لذلك هي أن يكون عدد العقد ذات الدرجة الفردية عدداً زوجياً."
  }
          ],
              lec2:[
  {
    "question": "ما هو الشرط الأساسي لاعتبار المخطط البياني غير الموجه (Undirected Graph) متصلاً (Connected)؟",
    "options": [
      "يحتوي على عدد زوجي من العقد",
      "يوجد مسار (Path) من أي عقدة إلى جميع العقد الأخرى",
      "جميع العقد لها نفس الدرجة (Degree)",
      "لا يحتوي على أي دوائر (Cycles)"
    ],
    "correct": 1,
    "explanation": "المخطط البياني غير الموجه يعتبر متصلاً إذا كان هناك مسار بين كل زوج من العقد، مما يعني أنه يمكن البدء من أي عقدة والوصول إلى أي عقدة أخرى."
  },
  {
    "question": "ما الفرق بين المخطط المتصل بقوة (Strongly Connected) والمخطط المتصل ضعيفاً (Weakly Connected) في المخططات الموجهة (Directed Graphs)؟",
    "options": [
      "المتصل بقوة يتطلب وجود مسار في كلا الاتجاهين بين كل عقدتين، بينما المتصل ضعيفاً يتطلب وجود مسار في اتجاه واحد فقط",
      "لا فرق بينهما",
      "المتصل ضعيفاً يتطلب مساراً في كلا الاتجاهين، بينما المتصل بقوة يتطلب مساراً في اتجاه واحد",
      "المتصل بقوة يكون غير دوري بينما المتصل ضعيفاً دوري"
    ],
    "correct": 0,
    "explanation": "المخطط الموجه يعتبر متصلاً بقوة إذا كان هناك مسار موجه من كل عقدة إلى كل عقدة أخرى. إذا كان متصلاً عند تجاهل اتجاهات الحواف (أي معاملته كمخطط غير موجه) ولكنه ليس متصلاً بقوة، فيسمى متصلاً ضعيفاً."
  },
  {
    "question": "في سياق المخططات البيانية، ماذا يمثل 'المكون المتصل' (Connected Component)؟",
    "options": [
      "أكبر دائرة في المخطط",
      "مجموعة فرعية من العقد حيث يمكن الوصول من كل عقدة فيها إلى أي عقدة أخرى في نفس المجموعة، ولا توجد حواف تربطها مع عقد خارج المجموعة",
      "مجموعة من الحواف التي تشكل شجرة",
      "عدد العقد التي لها درجة أكبر من 2"
    ],
    "correct": 1,
    "explanation": "المكون المتصل هو مجموعة عظمى من العقد بحيث يوجد مسار بين كل زوج من العقد داخل المجموعة، ولا يوجد مسار بين أي عقدة داخل المجموعة وأي عقدة خارجها."
  },
  {
    "question": "إذا قمنا بتطبيق خوارزمية BFS على مخطط بياني بدءاً من عقدة معينة وحصلنا في النهاية على قائمة 'final' تحتوي على جميع عقد المخطط، ماذا يعني هذا؟",
    "options": [
      "المخطط يحتوي على دائرة",
      "المخطط غير متصل",
      "المخطط متصل",
      "المخطط شجرة"
    ],
    "correct": 2,
    "explanation": "إذا شملت قائمة العقد التي تمت زيارتها في BFS جميع عقد المخطط، فهذا يعني أنه يمكن الوصول إلى كل العقد من عقدة البداية، وبالتالي فإن المخطط متصل (على الأقل في المكون الذي بدأنا منه؛ وإذا كان المخطط غير موجه فهذا يعني أنه متصل تماماً)."
  },
  {
    "question": "ما هو الهيكل البياناتي (Data Structure) الأساسي المستخدم في تنفيذ خوارزمية البحث بالعمق أولاً (DFS)؟",
    "options": [
      "الطابور (Queue) بنظام FIFO",
      "المكدس (Stack) بنظام LIFO",
      "القائمة المرتبطة (Linked List)",
      "الشجرة الثنائية (Binary Tree)"
    ],
    "correct": 1,
    "explanation": "تستخدم خوارزمية DFS المكدس (Stack) الذي يتبع مبدأ Last-In-First-Out (LIFO)، مما يسمح بالاستكشاف لأقصى عمق ممكن قبل العودة والاستكشاف في فروع أخرى."
  },
  {
    "question": "ما الهدف الرئيسي من استخدام خوارزمية البحث بالعرض أولاً (BFS) في سياق المخططات؟",
    "options": [
      "فرز قائمة العقد أبجدياً",
      "إيجاد الشجرة الممتدة ذات التكلفة الدنيا",
      "إيجاد المسار الأقصر (من حيث عدد الحواف) من عقدة المصدر إلى جميع العقد الأخرى في مخطط غير موزون",
      "اكتشاف جميع الدوائر في المخطط"
    ],
    "correct": 2,
    "explanation": "BFS تستكشف المخطط مستوى تلو الآخر (Level by Level). هذا يجعلها مناسبة لإيجاد أقصر مسار (من حيث عدد الخطوات أو الحواف) من عقدة المصدر إلى أي عقدة أخرى في مخطط غير موزون."
  },
  {
    "question": "في شجرة (Tree) مبنية من مخطط باستخدام BFS، ماذا يمثل 'عمق' (Depth) العقدة؟",
    "options": [
      "عدد أبناء العقدة المباشرين",
      "عدد الحواف في المسار من الجذر (Root) إلى تلك العقدة",
      "عدد العقد في المستوى الذي توجد به العقدة",
      "درجة العقدة في المخطط الأصلي"
    ],
    "correct": 1,
    "explanation": "في سياق الأشجار (خاصة شجرة BFS)، عمق العقدة هو المسافة (عدد الحواف) على المسار الفريد من عقدة الجذر إلى تلك العقدة."
  },
  {
    "question": "كيف يمكن استخدام خوارزمية BFS لتحديد إذا ما كان المخطط البياني 'ثنائي القسم' (Bipartite)؟",
    "options": [
      "إذا تمت زيارة جميع العقد دون وجود حواف بين عقد في نفس المستوى من شجرة BFS، فهو ثنائي القسم",
      "إذا كانت الشجرة الناتجة عن BFS تحتوي على عدد فردي من المستويات",
      "إذا وجدت دائرة في المخطط الأصلي",
      "إذا كان عدد العقد زوجياً"
    ],
    "correct": 0,
    "explanation": "خلال BFS، نخصص لوناً لكل مستوى. إذا اكتشفنا حافة في المخطط الأصلي تربط عقدتين لهما نفس اللون (أي في نفس المستوى من شجرة BFS)، فهذا يعني وجود دائرة فردية الطول، والمخطط ليس ثنائي القسم. إذا لم يحدث ذلك، فهو ثنائي القسم."
  },
  {
    "question": "ما هو تعريف 'ارتفاع' (Height) الشجرة؟",
    "options": [
      "عدد العقد في الشجرة",
      "أكبر مسافة (عدد حواف) من الجذر إلى أي ورقة (Leaf)",
      "متوسط عمق جميع العقد",
      "عدد المستويات في الشجرة"
    ],
    "correct": 1,
    "explanation": "ارتفاع الشجرة هو قياس لأقصى امتداد رأسي لها، ويُعرّف بأنه أكبر عدد من الحواف على المسار من الجذر إلى أي عقدة طرفية (ورقة)."
  },
  {
    "question": "لنفترض مخططاً غير موجه به 8 عقد. عند تطبيق DFS بدءاً من عقدة، تمت زيارة 5 عود فقط وانتهت الخوارزمية. ماذا نستنتج؟",
    "options": [
      "المخطط متصل",
      "المخطط يحتوي على 3 مكونات متصلة على الأقل",
      "خوارزمية DFS نفذت بشكل خاطئ",
      "المخطط هو شجرة"
    ],
    "correct": 1,
    "explanation": "إذا استكشفت DFS فقط 5 من أصل 8 عود، فهذا يعني أن عقدة البداية تنتمي إلى مكون متصل يحتوي على 5 عقد. العقد الثلاث المتبقية غير قابلة للوصول من عقدة البداية، لذا فهي تنتمي إلى مكون متصل واحد أو أكثر منفصل عن الأول."
  },
  {
    "question": "عند تنفيذ خوارزمية DFS بشكل تعاودي (Recursive)، ما هي الحالة الأساسية (Base Case) التي توقف الاستدعاءات؟",
    "options": [
      "عندما تكون العقدة الحالية هي العقدة الهدف",
      "عندما نصل إلى عقدة ليس لها جيران",
      "عندما تكون جميع جيران العقدة الحالية قد تمت زيارتها (موسومة بـ visited)",
      "عندما يصبح المكدس فارغاً"
    ],
    "correct": 2,
    "explanation": "في DFS التعاودي، الوظيفة تستدعي نفسها لكل جار غير مزار للعقدة الحالية. الحالة الأساسية تحدث ضمنياً عندما لا يكون للعقدة الحالية أي جيران غير مزارين، فتتوقف سلسلة الاستدعاءات وترجع إلى المستوى السابق."
  },
  {
    "question": "ما الفرق الأساسي في سلوك الاستكشاف بين BFS و DFS؟",
    "options": [
      "BFS تستكشف أقرب الجيران أولاً ثم تبتعد، بينما DFS تغوص في اتجاه واحد بعيداً قدر الإمكان قبل العودة",
      "DFS أسرع دائماً من BFS",
      "BFS تستخدم التعاودية بينما DFS تستخدم التكرار",
      "لا فرق، كلاهما يعطي نفس النتيجة"
    ],
    "correct": 0,
    "explanation": "BFS تتبع إستراتيجية 'العرض أولاً'، فتستكشف جميع الجيران على المسافة الحالية قبل التقدم إلى المسافة التالية. بينما DFS تتبع إستراتيجية 'العمق أولاً'، فتتابع مساراً واحداً إلى أبعد حد ممكن قبل العودة واستكشاف مسارات بديلة."
  },
  {
    "question": "في مخطط غير موجه، إذا كانت درجات جميع العود (عدد الحواف المتصلة بكل عقدة) أعداداً زوجية، فماذا يمكن أن نستنتج عن إمكانية تطبيق BFS أو DFS؟",
    "options": [
      "سيجد BFS دائرة بالتأكيد",
      "سيجد DFS المسار الأقصر",
      "لا يؤثر على سلوك أو نتيجة BFS وDFS فيما يخص الاتصال أو عدد المكونات",
      "المخطط حتماً متصل"
    ],
    "correct": 2,
    "explanation": "درجة العقدة (زوجية أو فردية) لا تحدد اتصال المخطط. خوارزميتا BFS وDFS ستستكشفان المخطط بغض النظر عن توزيع الدرجات. ما يهم هو بنية الحواف نفسها وليس عددها عند كل عقدة."
  },
  {
    "question": "ما هي فائدة 'شجرة الامتداد' (Spanning Tree) التي نحصل عليها من تطبيق BFS أو DFS على مخطط متصل؟",
    "options": [
      "هي دائماً أصغر شجرة ممتدة من حيث التكلفة",
      "تمثل هيكلاً فرعياً للمخطط يحافظ على اتصاله ويحتوي على جميع عوده لكن بعدد أقل من الحواف (بدون دوائر)",
      "تحتوي على جميع دوائر المخطط الأصلي",
      "هي أسرع طريقة لتمثيل المخطط في الذاكرة"
    ],
    "correct": 1,
    "explanation": "شجرة الامتداد الناتجة عن BFS أو DFS هي مجموعة فرعية من حواف المخطط الأصلي التي تربط جميع العقد دون إنشاء أي دوائر. هي تحافظ على خاصية الاتصال ولكن بعدد حواف يساوي (عدد العقد - 1)."
  },
  {
    "question": "لنفترض أنك طُلب منك إيجاد أقصر مسار من عقدة 'X' إلى عقدة 'Y' في مخطط غير موجه وغير موزون. أي خوارزمية ستكون الخيار الأنسب ولماذا؟",
    "options": [
      "DFS، لأنها ستجد أي مسار بسرعة",
      "BFS، لأنها تضمن العثور على المسار الذي يحتوي على أقل عدد من الحواف",
      "الفرز السريع (Quicksort)",
      "خوارزمية ديكسترا (Dijkstra)، لأن المخطط غير موزون"
    ],
    "correct": 1,
    "explanation": "في المخططات غير الموزونة، تكون تكلفة كل حافة متساوية. BFS تستكشف المخطط حسب المستويات (الطبقات)، وبالتالي فإن أول مرة تصل فيها إلى العقدة الهدف تكون عبر المسار الذي يحتوي على أقل عدد من الحواف (أي أقصر مسار)."
  },
  {
    "question": "خلال تنفيذ BFS باستخدام طابور (Queue)، ماذا يحدث للعقدة عند إزالتها من مقدمة الطابور؟",
    "options": [
      "يتم حذفها من المخطط نهائياً",
      "يتم وضعها في قائمة 'final' أو تمييزها كمزارة، ثم تتم إضافة جميع جيرانها غير المزارين إلى نهاية الطابور",
      "يتم تجاهلها نهائياً",
      "يتم وضعها في مكدس منفصل"
    ],
    "correct": 1,
    "explanation": "الخطوة الأساسية في BFS هي: 1) إخراج العقدة من مقدمة الطابور. 2) اعتبارها 'مزارة' (تسجيلها في قائمة النتيجة). 3) إدخال جميع جيرانها الذين لم تتم زيارتهم بعد إلى نهاية الطابور."
  },
  {
    "question": "كيف يمكن تحديد عدد 'المكونات المتصلة' (Connected Components) في مخطط غير موجه باستخدام DFS؟",
    "options": [
      "بحساب عدد المرات التي نضطر فيها لبدء تشغيل DFS من عقدة جديدة غير مزارة بعد انتهاء استكشاف المكون السابق",
      "بحساب عدد العقد التي لها درجة صفر",
      "بحساب عدد الحواف في المخطط وقسمته على 2",
      "بحساب عدد الدوائر في المخطط"
    ],
    "correct": 0,
    "explanation": "يتم ذلك بتكرار تطبيق DFS. نبدأ من أي عقدة غير مزارة ونطبق DFS لزيارة جميع العقد في مكونها المتصل. ثم نبحث عن أي عقدة غير مزارة المتبقية، ونبدأ DFS جديدة منها. عدد مرات تشغيل DFS يساوي عدد المكونات المتصلة."
  },
  {
    "question": "ما هو الخطأ في العبارة التالية: 'خوارزمية DFS تناسب إيجاد أقصر مسار في مخطط غير موزون لأنها سريعة'؟",
    "options": [
      "لا يوجد خطأ، العبارة صحيحة",
      "DFS لا تضمن إيجاد أقصر مسار، بل تجد أي مسار متاح",
      "DFS أبطأ من BFS لإيجاد المسار",
      "المخطط غير الموزون لا يمكن أن يكون له أقصر مسار"
    ],
    "correct": 1,
    "explanation": "بينما قد تجد DFS مساراً، فهي لا تضمن أن يكون هذا المسار هو الأقصر (من حيث عدد الحواف)، لأنها قد تتجه في مسار طويل جداً قبل أن تجد الهدف. BFS هي المناسبة لهذه المهمة في المخططات غير الموزونة."
  },
  {
    "question": "في رسم توضيحي لمخطط به العقد {A, B, C, D, E, F, G}. تطبيق BFS بدءاً من العقدة A أعطى ترتيب الزيارة التالي: A, D, E, B, C, F, G. ماذا يمكن أن نستنتج عن شجرة BFS؟",
    "options": [
      "العقدة B هي ابن للعقدة A في الشجرة",
      "العقدة D و E و B هم جميعاً أبناء للعقدة A في المستوى الأول من الشجرة",
      "العقدة G هي ابن للعقدة C في الشجرة",
      "جميع ما سبق محتمل، ويعتمد على ترتيب إضافة الجيران إلى الطابور والمخطط الأصلي"
    ],
    "correct": 3,
    "explanation": "ترتيب الزيارة في BFS يعتمد على ترتيب إدخال الجيران إلى الطابور وبنية المخطط الأصلي. A ستكون الجذر. العقد التي زُرعت مباشرة بعد A (مثل D, E, B) من المحتمل أن تكون أبناءها المباشرين في مستوى 1. العقد التي زُرعت لاحقاً (مثل C, F, G) من المحتمل أن تكون على مستويات أعمق وأبناء لعقد زُرعت سابقاً."
  },
  {
    "question": "إذا كان لدينا مخطط موجه (Directed Graph) ونريد معرفة إذا كان متصلاً بقوة (Strongly Connected)، ما هي الطريقة المناسبة؟",
    "options": [
      "تطبيق BFS مرة واحدة من أي عقدة",
      "تطبيق DFS مرة واحدة من أي عقدة",
      "تطبيق BFS أو DFS من كل عقدة على حدة والتحقق من زيارة جميع العقد في كل مرة",
      "عد عدد الحواف وقارنته بعدد العقد"
    ],
    "correct": 2,
    "explanation": "للتحقق من أن المخطط موصل بقوة، يجب التأكد من وجود مسار موجه من كل عقدة إلى كل عقدة أخرى. أبسط طريقة نظرياً هي تشغيل خوارزمية استكشاف (مثل BFS أو DFS) من كل عقدة كبداية، والتحقق في كل مرة من زيارة جميع العقد الأخرى."
  },
  {
    "question": "ما هي الصفة التي تميز 'الشجرة' (Tree) عن المخطط البياني العام؟",
    "options": [
      "أنها تحتوي دائماً على عدد زوجي من العقد",
      "أنها متصلة ولا تحتوي على أي دوائر (Acyclic)",
      "أن كل عقدة فيها لها درجة 2 على الأكثر",
      "أنها موجهة بالكامل"
    ],
    "correct": 1,
    "explanation": "الشجرة هي حالة خاصة من المخططات البيانية غير الموجهة. تعريفها الأساسي: مخطط متصل (Connected) وخالٍ من الدوائر (Acyclic). هذا يعني أن هناك مساراً وحيداً بين أي عقدتين."
  },
  {
    "question": "خلال DFS التكرارية باستخدام مكدس، ماذا يمثل محتويات المكدس في أي لحظة؟",
    "options": [
      "العقد التي تمت زيارتها للتو",
      "مسار الاستكشاف الحالي من الجذر إلى العقدة الحالية التي يجري استكشاف جيرانها",
      "جميع العقد التي تمت زيارتها",
      "العقد التي تمت زيارتها أولاً ستكون في أسفل المكدس"
    ],
    "correct": 1,
    "explanation": "المكدس في DFS التكرارية يحتفظ بمسار الاستكشاف. العنصر في أعلى المكدس هو العقدة الحالية. عند الدفع، ننتقل إلى ابن. عند إخراج العنصر، نعود إلى الأب لاستكشاف الأبناء الآخرين."
  },
  {
    "question": "في مخطط غير متصل (Disconnected) بعدد عقد 10، كم مرة على الأقل سيتم استدعاء دالة DFS التعاودية الرئيسية (من دالة التهيئة) لإكمال استكشاف جميع المكونات؟",
    "options": [
      "مرة واحدة",
      "10 مرات (مرة لكل عقدة)",
      "مرتين",
      "عدد مرات يساوي عدد المكونات المتصلة في المخطط"
    ],
    "correct": 3,
    "explanation": "دالة التهيئة (Init) تمر على جميع العقد. لكل عقدة غير مزارة، تستدعي DFS. كل استدعاء لـ DFS يستكشف مكوناً متصلاً كاملاً. لذلك، عدد مرات استدعاء DFS من دالة التهيئة يساوي عدد المكونات المتصلة."
  },
  {
    "question": "لماذا نستخدم مصفوفة أو قائمة 'مزارة' (visited) في كل من BFS و DFS؟",
    "options": [
      "لتسريع الخوارزمية فقط",
      "لمنع الخوارزمية من الدخول في حلقة لا نهائية عند وجود دوائر في المخطط",
      "لحساب درجة كل عقدة",
      "لتحديد إذا كان المخطط موجهًا أم لا"
    ],
    "correct": 1,
    "explanation": "الغرض الأساسي من علامة 'visited' هو تتبع العقد التي تمت معالجتها بالفعل. بدونها، في مخطط يحتوي على دائرة، قد تقوم الخوارزمية بالدوران إلى ما لا نهاية بين العقد في تلك الدائرة."
  },
  {
    "question": "عند تطبيق BFS على مخطط متصل، أي من العبارات التالية صحيحة بشأن شجرة BFS الناتجة؟",
    "options": [
      "قد تحتوي على حواف غير موجودة في المخطط الأصلي",
      "ارتفاعها (Height) يساوي دائماً قطر المخطط (Diameter)",
      "هي واحدة من الأشجار الممتدة المحتملة للمخطط",
      "عدد أبناء أي عقدة فيها يساوي درجة تلك العقدة في المخطط الأصلي"
    ],
    "correct": 2,
    "explanation": "شجرة BFS هي شجرة ممتدة (Spanning Tree) لأنها: 1) تشمل جميع عقد المخطط المتصل. 2) حوافها هي مجموعة فرعية من حواف المخطط الأصلي. 3) لا تحتوي على دوائر. هناك عادة العديد من الأشجار الممتدة الممكنة لأي مخطط، وشجرة BFS هي إحداها."
  },
  {
    "question": "في DFS، ما معنى 'التراجع' (Backtracking)؟",
    "options": [
      "حذف العقدة الحالية من الذاكرة",
      "الانتقال من عقدة حالية ليس لديها جيران غير مزارين للعودة إلى العقدة السابقة في مسار الاستكشاف",
      "إلغاء زيارة جميع العقد والبدء من جديد",
      "تغيير اتجاه الحواف في المخطط الموجه"
    ],
    "correct": 1,
    "explanation": "التراجع هو سمة أساسية في DFS. يحدث عندما تصل الخوارزمية إلى 'نهاية طريق مسدود'، أي عقدة ليس لها جيران غير مزارين. عندها، تعود (تراجع) إلى العقدة السابقة في مسار الاستكشاف (والتي يتم استرجاعها من المكدس) لمحاولة استكشاف فروع أخرى لم تزُر بعد."
  },
  {
    "question": "ما هو 'مستوى' (Level) العقدة في شجرة BFS؟",
    "options": [
      "عمقها (Depth)",
      "عدد إخوتها (Siblings)",
      "درجتها في المخطط الأصلي",
      "ترتيب زيارتها في BFS"
    ],
    "correct": 0,
    "explanation": "في سياق شجرة BFS، مستوى العقدة و عمقها هما نفس المفهوم: عدد الحواف في المسار من الجذر إلى تلك العقدة. المستوى 0 للجذر، المستوى 1 لأبناء الجذر، وهكذا."
  },
  {
    "question": "إذا طُبقت BFS على مخطط ثنائي القسم (Bipartite) بدءاً من عقدة، كيف ستبدو شجرة BFS من حيث تلوين العقد؟",
    "options": [
      "جميع العقد سيكون لها نفس اللون",
      "العقد في المستويات الزوجية بلون، والعقد في المستويات الفردية بلون آخر",
      "سيكون هناك 3 ألوان على الأقل",
      "لن يكون هناك نمط محدد للتلوين"
    ],
    "correct": 1,
    "explanation": "المخطط الثنائي القسم يعني إمكانية تقسيم عقدة إلى مجموعتين بحيث تكون جميع الحواف بين المجموعتين فقط. في شجرة BFS، الجذر (المستوى 0) بلون، أبناؤه (المستوى 1) بلون ثان، أبناء الأبناء (المستوى 2) يرثون لون الجذر، وهكذا. وبالتالي، المستويات الزوجية بلون والمستويات الفردية بلون آخر."
  },
  {
    "question": "متى نقول أن خوارزمية استكشاف المخطط (Graph Exploration) قد اكتملت؟",
    "options": [
      "عندما تتم زيارة نصف العقد",
      "عندما لا توجد عقد غير مزارة يمكن الوصول إليها من عقدة البداية (في حالة مخطط متصل) أو من أي عقدة بداية استخدمناها (في حالة غير متصل)",
      "عندما يصبح الطابور أو المكدس فارغاً",
      "الإجابتان 2 و 3 صحيحتان"
    ],
    "correct": 3,
    "explanation": "اكتمال الاستكشاف يعني عدم وجود عود جديدة قابلة للوصول. من الناحية العملية للخوارزمية، هذا يتحقق عندما يصبح هيكل البيانات المساعد (الطابور في BFS أو المكدس في DFS) فارغاً، مما يشير إلى أنه لم يعد هناك عقد تنتظر المعالجة أو العودة إليها لاستكشاف المزيد."
  },
  {
    "question": "ما هو القاسم المشترك بين جميع الأشجار الممتدة (Spanning Trees) لمخطط متصل معين بعدد عقد n؟",
    "options": [
      "لها نفس ارتفاع (Height)",
      "لها نفس شكل الشجرة",
      "لها نفس عدد الحواف، وهو n-1",
      "تنتج من نفس خوارزمية الاستكشاف (BFS أو DFS)"
    ],
    "correct": 2,
    "explanation": "أي شجرة ممتدة لمخطط متصل تحتوي على جميع العقد n، ولأنها شجرة (لا تحتوي على دوائر)، يجب أن يكون عدد حوافها بالضبط n-1."
  },
  {
    "question": "في مخطط غير موجه، إذا كان قطر المخطط (أطول أقصر مسار بين أي عقدتين) كبيراً جداً، أي خوارزمية استكشاف قد تعاني من مشكلة في استهلاك الذاكرة عند تطبيقها بشكل تعاودي، ولماذا؟",
    "options": [
      "BFS، لأن الطابور سيصبح كبيراً",
      "DFS التعاودية، لأن عمق مكدس الاستدعاء (Call Stack) قد يصبح كبيراً جداً",
      "كلا الخوارزميتين ستعانيان بالمقدار نفسه",
      "لا تعاني أي منهما"
    ],
    "correct": 1,
    "explanation": "إذا كان المخطط طويلاً وضيقاً (مثل مسار طويل)، فإن DFS التعاودية ستغوص إلى العمق الكامل للمسار قبل أن تبدأ في التراجع. هذا سيؤدي إلى عمق استدعاء تعاودي يساوي تقريباً قطر المخطط، مما قد يتسبب في تجاوز سعة مكدس الاستدعاء (Stack Overflow) إذا كان القطر كبيراً جداً."
  },
  {
    "question": "كيف يمكن لخوارزمية BFS أن تساعد في العثور على العقد التي هي على مسافة معينة (مثلاً 3 حواف) من عقدة المصدر؟",
    "options": [
      "لا يمكنها ذلك",
      "عن طريق تسجيل 'المستوى' أو 'المسافة' لكل عقدة عند زيارتها لأول مرة. العقد في المستوى 3 هي المطلوبة",
      "عن طريق حساب درجة كل عقدة بعد انتهاء BFS",
      "عن طريق تطبيق DFS بعد BFS"
    ],
    "correct": 1,
    "explanation": "أثناء تنفيذ BFS، يمكننا تخصيص مصفوفة distance أو level. عند زيارة جار غير مزار، نعين له level = level[current] + 1. بعد انتهاء BFS، العقد التي لها level = 3 تكون على مسافة 3 حواف من المصدر."
  },
  {
    "question": "ما هو التحدي الرئيسي في تطبيق BFS أو DFS على مخططات ضخمة جداً (مثل شبكات التواصل الاجتماعي)؟",
    "options": [
      "صعوبة كتابة الكود",
      "استهلاك الذاكرة لتخزين حالة 'مزارة' لجميع العقد، واستهلاك الوقت لزيارة جميع العقد والحواف",
      "عدم وجود دوائر في مثل هذه المخططات",
      "أنها تكون دائمًا غير متصلة"
    ],
    "correct": 1,
    "explanation": "التحدي الحسابي (Computational Complexity) لكل من BFS و DFS هو O(V+E) من حيث الوقت و O(V) من حيث الذاكرة (للمصفوفات المساعدة). في المخططات الضخمة (مليارات العقد والحواف)، يصبح هذا الحساب مستهلكاً للغاية للوقت والذاكرة، مما يتطلب خوارزميات متوازية أو تقنيات معالجة خاصة."
  },
  {
    "question": "إذا بدأنا BFS من عقدتين مختلفتين في نفس المخطط المتصل، هل سنحصل على نفس شجرة BFS؟",
    "options": [
      "نعم، دائماً",
      "لا، أبداً",
      "ليس بالضرورة، فقد نحصل على أشجار مختلفة اعتماداً على عقدة البداية وترتيب معالجة الجيران",
      "نحصل على نفس الشجرة فقط إذا كان المخطط نفسه شجرة"
    ],
    "correct": 2,
    "explanation": "شجرة BFS تعتمد على: 1) عقدة الجذر (البداية). 2) ترتيب إضافة جيران كل عقدة إلى الطابور. تغيير أي من هذين العاملين قد ينتج شجرة BFS مختلفة، حتى لو كان المخطط الأصلي واحداً."
  },
  {
    "question": "ماذا يحدث إذا حاولنا تطبيق DFS على مخطط غير متصل دون وجود آلية للبحث عن عقد غير مزارة بعد انتهاء الاستكشاف الأول؟",
    "options": [
      "سيستكشف جميع المكونات المتصلة تلقائياً",
      "سيستكشف فقط المكون المتصل الذي يحتوي على عقدة البداية",
      "سيتوقف فوراً",
      "سيؤدي إلى خطأ في الذاكرة"
    ],
    "correct": 1,
    "explanation": "خوارزمية DFS (أو BFS) القياسية التي تبدأ من عقدة معينة ستستكشف فقط ذلك الجزء من المخطط المتصل بعقدة البداية (أي المكون المتصل الخاص بها). للعثور على جميع المكونات، يجب أن نغلف الخوارزمية بحلقة تبحث عن عقد غير مزارة وتعيد تشغيل الاستكشاف منها."
  },
  {
    "question": "في الكود التكراري لـ DFS، لماذا ندفع 'الأبناء الجدد' (newchildren) إلى يسار المكدس (أو أعلى المكدس) بدلاً من اليمين؟",
    "options": [
      "إنها مجرد اتفاقية، لا فرق",
      "لضمان معالجة أحدث عقدة تمت إضافتها أولاً (مبدأ LIFO)، وهو جوهر DFS",
      "لجعل الخوارزمية أبطأ",
      "لتقليد سلوك الطابور (Queue)"
    ],
    "correct": 1,
    "explanation": "دفع العقد الجديدة إلى 'رأس' أو 'قمة' المكدس (المكان الذي نزيل منه) يضمن أن الخوارزمية ستستمر في استكشاف الفرع الذي دخلت إليه للتو (الابن الأحدث)، وهو بالضبط سلوك 'العمق أولاً'. إضافتها إلى 'الذيل' سيجعلها تتصرف مثل BFS."
  },
  {
    "question": "بماذا تختلف 'المسافة' (Distance) عن 'العمق' (Depth) في سياق أشجار BFS؟",
    "options": [
      "هما مصطلحان لنفس المفهوم",
      "المسافة تقاس بين أي عقدتين، بينما العمق يقاس من الجذر فقط",
      "العمق خاص بالأشجار الثنائية فقط",
      "المسافة تعتمد على وزن الحواف، بينما العمق لا يعتمد"
    ],
    "correct": 1,
    "explanation": "في شجرة BFS: 'العمق' خاص بالشجرة وهو المسافة من الجذر المحدد لتلك الشجرة. 'المسافة' يمكن أن تشير إلى المسافة بين أي زوج من العقد في الشجرة (أو المخطط الأصلي). في شجرة BFS، عمق العقدة يساوي مسافتها من جذر BFS."
  },
  {
    "question": "لماذا لا نستخدم BFS للعثور على وجود دائرة في مخطط؟",
    "options": [
      "لأن BFS لا يمكنها اكتشاف الدوائر",
      "لأن DFS أكثر كفاءة لاكتشاف الدوائر",
      "يمكن استخدام BFS لاكتشاف الدوائر عن طريق فحص إذا ما أدت عملية الاستكشاف إلى زيارة عقدة سبق زيارتها وكانت ليست أصل العقدة الحالية",
      "الدوائر لا تهم في نظرية المخططات"
    ],
    "correct": 2,
    "explanation": "يمكن استخدام كل من BFS وDFS للكشف عن الدوائر في المخطط غير الموجه. الفكرة هي: أثناء الاستكشاف، إذا صادفنا حافة تربط العقدة الحالية بعقدة سبق زيارتها (موسومة بـ visited) وهذه العقدة ليست الأب المباشر للعقدة الحالية في شجرة الاستكشاف، فهذا يدل على وجود دائرة."
  },
  {
    "question": "ما هي العلاقة بين مفهوم 'المكون المتصل' في المخطط غير الموجه ونتيجة تشغيل خوارزمية استكشاف واحدة (مثل DFS)؟",
    "options": [
      "خوارزمية استكشاف واحدة تحسب عدد المكونات",
      "مجموعة العقد التي تمت زيارتها بواسطة خوارزمية استكشاف واحدة بدءاً من عقدة تشكل بالضبط أحد المكونات المتصلة",
      "لا توجد علاقة",
      "خوارزمية الاستكشاف تحذف المكونات المتصلة"
    ],
    "correct": 1,
    "explanation": "عند تشغيل DFS (أو BFS) من عقدة ما، فإنها ستزور جميع العقد التي يمكن الوصول إليها من تلك العقدة، ولا شيء غيرها. هذه المجموعة من العود هي بالتعريف 'المكون المتصل' الذي تنتمي إليه عقدة البداية."
  },
  {
    "question": "إذا أردنا معرفة ما إذا كان بإمكان شخص في شبكة اجتماعية الوصول إلى صفحة شخص آخر (عبر روابط الصداقة)، وأهملنا المسافة، أي خوارزمية ستكون كافية؟",
    "options": [
      "BFS فقط، لأنها تجد أقصر مسار",
      "DFS فقط، لأنها أسرع",
      "أي منهما، BFS أو DFS، لأن كليهما يمكنه تحديد إذا كان هناك مسار أم لا (الاتصال)",
      "لا يمكن استخدام أي منهما في الشبكات الاجتماعية"
    ],
    "correct": 2,
    "explanation": "كلتا الخوارزميتين، BFS وDFS، هما خوارزميات استكشاف للمخططات. مهمتهما الأساسية هي زيارة العقد التي يمكن الوصول إليها من نقطة بداية. لذلك، أي منهما يمكن أن تجيب على سؤال 'هل هناك مسار من A إلى B؟' بنعم أو لا."
  },
  {
    "question": "في التمثيل البرمجي، ما هو الهيكل البياناتي الأكثر شيوعاً لتمثيل المخطط حتى نتمكن من تطبيق BFS أو DFS بكفاءة؟",
    "options": [
      "المصفوفة الثنائية (Adjacency Matrix)",
      "قائمة الجوار (Adjacency List)",
      "مصفوفة الحواف (Edge List)",
      "المصفوفة الثنائية هي الأفضل دائماً"
    ],
    "correct": 1,
    "explanation": "قائمة الجوار (Adjacency List) هي التمثيل الأكثر كفاءة من حيث المساحة والوقت لمعظم خوارزميات المخططات التي تتطلب تكراراً على جيران كل عقدة (مثل BFS وDFS). تعقيد زيارة جميع الجيران يصبح O(V+E) بدلاً من O(V^2) في مصفوفة الجوار إذا كان المخطط متناثراً (Sparse)."
  }
          ],
              lec3:[

       
  {
    "question": "ما هو الفرق الأساسي بين المخطط الموزون (Weighted Graph) والمخطط غير الموزون (Unweighted Graph)؟",
    "options": [
      "المخطط غير الموزون لا يمكن تطبيق Dijkstra عليه",
      "المخطط الموزون يكون دائمًا موجهًا",
      "المخطط الموزون يحتوي على عقد أكثر",
      "المخطط الموزون له أوزان على الحواف تمثل كلفة أو زمن أو مسافة"
    ],
    "correct": 3,
    "explanation": "الفرق الأساسي هو أن المخطط الموزون يحتوي على أوزان على الحواف تمثل قيمًا مثل الكلفة أو الزمن أو المسافة، بينما في المخطط غير الموزون تعتبر جميع الحواف متساوية الوزن."
  },
  {
    "question": "ما هي القيمة التي تمثل طول المسار في المخطط الموزون؟",
    "options": [
      "عدد الحواف في المسار",
      "عدد العقد في المسار",
      "مجموع أوزان الحواف في المسار",
      "متوسط أوزان الحواف في المسار"
    ],
    "correct": 2,
    "explanation": "في المخطط الموزون، طول المسار يساوي مجموع أوزان جميع الحواف التي يمر عليها، وليس مجرد عدد الحواف."
  },
  {
    "question": "ما هي الخوارزمية المناسبة لإيجاد أقصر مسار في مخطط موزون بأوزان موجبة؟",
    "options": [
      "خوارزمية BFS",
      "خوارزمية Dijkstra",
      "خوارزمية DFS",
      "خوارزمية Prim"
    ],
    "correct": 1,
    "explanation": "خوارزمية Dijkstra هي الخوارزمية المناسبة لإيجاد أقصر مسار في مخطط موزون بأوزان موجبة، بينما BFS مناسبة للمخططات غير الموزونة."
  },
  {
    "question": "ما هو الشرط الأساسي لأوزان الحواف في خوارزمية Dijkstra؟",
    "options": [
      "يمكن أن تكون الأوزان سالبة",
      "يجب أن تكون جميع الأوزان متساوية",
      "يجب أن تكون جميع الأوزان موجبة",
      "يجب أن تكون الأوزان أعدادًا صحيحة فقط"
    ],
    "correct": 2,
    "explanation": "خوارزمية Dijkstra تتطلب أن تكون جميع الأوزان موجبة، لأن الأوزان السالبة قد تؤدي إلى حلول لا نهائية أو نتائج غير صحيحة."
  },
  {
    "question": "ما هو دور المتغير d[u] في خوارزمية Dijkstra؟",
    "options": [
      "يمثل اللون الحالي للعقدة u",
      "يمثل عدد الحواف من العقدة المصدر إلى العقدة u",
      "يمثل أقصر مسافة معروفة من العقدة المصدر إلى العقدة u",
      "يمثل السلف المباشر للعقدة u"
    ],
    "correct": 2,
    "explanation": "d[u] يمثل أقصر مسافة معروفة حالياً من عقدة المصدر (source) إلى العقدة u، ويتم تحديث هذه القيمة أثناء تنفيذ الخوارزمية."
  },
  {
    "question": "ما هو دور المصفوفة pred[v] في خوارزمية Dijkstra؟",
    "options": [
      "تشير إلى لون العقدة v",
      "تشير إلى وزن الحواف المرتبطة بالعقدة v",
      "تشير إلى عدد جوارات العقدة v",
      "تشير إلى العقدة السابقة للعقدة v في أقصر مسار"
    ],
    "correct": 3,
    "explanation": "pred[v] تخزن العقدة السابقة للعقدة v في أقصر مسار معروف من المصدر إلى v، مما يسمح بإعادة بناء المسار لاحقاً."
  },
  {
    "question": "ما هي العقدة التي يتم اختيارها أولاً في خوارزمية Dijkstra؟",
    "options": [
      "العقدة ذات أكبر عدد من الجوارات",
      "أي عقدة عشوائية",
      "العقدة ذات الوزن الأكبر",
      "عقدة المصدر (source)"
    ],
    "correct": 3,
    "explanation": "تبدأ الخوارزمية من عقدة المصدر (source) التي نريد إيجاد أقصر المسارات منها إلى جميع العقد الأخرى."
  },
  {
    "question": "كيف يتم اختيار العقدة التالية للمعالجة في خوارزمية Dijkstra؟",
    "options": [
      "العقدة الأقرب جغرافياً",
      "العقدة ذات أكبر عدد من الجوارات",
      "العقدة ذات أقل قيمة d[u] من بين العقد غير المعالجة",
      "العقدة الأولى في القائمة"
    ],
    "correct": 2,
    "explanation": "في كل خطوة، يتم اختيار العقدة ذات أقل مسافة معروفة (d[u]) من بين العقد التي لم تتم معالجتها بعد."
  },
  {
    "question": "ما هو الشرط الذي يتم اختباره عند فحص حافة بين العقدة u والعقدة v؟",
    "options": [
      "إذا كانت w(u,v) < d[v]",
      "إذا كانت d[u] = d[v]",
      "إذا كانت d[u] < d[v]",
      "إذا كانت d[u] + w(u,v) < d[v]"
    ],
    "correct": 3,
    "explanation": "يتم اختبار إذا كان المرور عبر العقدة u يوفر مساراً أقصر إلى v، أي إذا كانت المسافة من المصدر إلى u زائد وزن الحافة (u,v) أقل من المسافة الحالية إلى v."
  },
  {
    "question": "ماذا يحدث إذا تم اختبار الشرط d[u] + w(u,v) < d[v] وكان محققاً؟",
    "options": [
      "يتم حذف العقدة v من المخطط",
      "لا يحدث أي تغيير",
      "يتم تغيير لون العقدة v إلى أحمر",
      "يتم تحديث d[v] = d[u] + w(u,v) و pred[v] = u"
    ],
    "correct": 3,
    "explanation": "إذا وجدنا مساراً أقصر إلى v عبر u، نحدث المسافة d[v] لتكون المسافة الجديدة الأقصر، ونعين u كسلف لـ v في هذا المسار."
  },
  {
    "question": "ما هو الشرط اللازم حول اتصال المخطط لتطبيق خوارزمية Dijkstra؟",
    "options": [
      "يجب أن يكون المخطط غير متصل",
      "يجب أن يكون المخطط شجراً",
      "يجب أن يكون المخطط متصلاً (connected)",
      "لا يشترط اتصال المخطط"
    ],
    "correct": 2,
    "explanation": "يجب أن يكون المخطط متصلاً حتى يمكن الوصول من عقدة المصدر إلى جميع العقد الأخرى، وإلا ستكون بعض المسافات لا نهائية."
  },
  {
    "question": "ما هو نوع المخططات التي يمكن تطبيق Dijkstra عليها؟",
    "options": [
      "دائرية فقط",
      "موجهة فقط",
      "غير موجهة فقط",
      "موجهة أو غير موجهة"
    ],
    "correct": 3,
    "explanation": "يمكن تطبيق خوارزمية Dijkstra على كل من المخططات الموجهة (Directed) وغير الموجهة (Undirected)، طالما كانت الأوزان موجبة."
  },
  {
    "question": "ماذا تمثل القيمة ∞ في تهيئة خوارزمية Dijkstra؟",
    "options": [
      "مسافة صفر",
      "مسافة قصوى محددة",
      "مسافة لا نهائية (غير معروفة بعد)",
      "مسافة سالبة"
    ],
    "correct": 2,
    "explanation": "يتم تهيئة مسافات جميع العقد (ما عدا المصدر) بالقيمة ∞ التي تمثل مسافة غير معروفة أو لا نهائية، لأننا لم نكتشف بعد طريقاً إليها."
  },
  {
    "question": "ماذا يحدث للعقدة بعد معالجتها في خوارزمية Dijkstra؟",
    "options": [
      "يتم حذفها من المخطط",
      "يتم تعليمها كمعالجة وإزالتها من قائمة الانتظار",
      "يتم تغيير وزن حوافها",
      "تظل في قائمة الانتظار للمعالجة مرة أخرى"
    ],
    "correct": 1,
    "explanation": "بعد معالجة جميع جوارات العقدة، يتم تعليمها على أنها معالجة (مثلاً بتغيير لونها إلى أسود) وإزالتها من قائمة العقد المطلوب معالجتها (Q)."
  },
  {
    "question": "ما هو الشرط الأساسي للتأكد من صحة خوارزمية Dijkstra؟",
    "options": [
      "جميع الأوزان يجب أن تكون أعداداً صحيحة",
      "يجب أن يكون هناك مسار واحد فقط بين أي عقدتين",
      "جميع الأوزان يجب أن تكون غير سالبة",
      "يجب أن يكون المخطط شجراً"
    ],
    "correct": 2,
    "explanation": "الشرط الأساسي هو أن تكون جميع الأوزان غير سالبة (موجبة أو صفر)، لأن الأوزان السالبة قد تؤدي إلى حلول غير صحيحة أو دوائر لا نهائية."
  },
  {
    "question": "كيف يمكن إيجاد المسار الفعلي (ليس فقط طوله) بين المصدر والعقدة v؟",
    "options": [
      "باستخدام مصفوفة d فقط",
      "بإعادة تشغيل الخوارزمية",
      "بحساب متوسط الأوزان",
      "باستخدام مصفوفة pred للعودة إلى الوراء من v إلى المصدر"
    ],
    "correct": 3,
    "explanation": "باستخدام مصفوفة pred، يمكننا البدء من العقدة v والعودة عبر السلف pred[v] مراراً حتى نصل إلى المصدر، مما يعطينا المسار العكسي."
  },
  {
    "question": "ما هو التعقيد الزمني لخوارزمية Dijkstra باستخدام مصفوفة مجاورة؟",
    "options": [
      "O(V + E) حيث E عدد الحواف",
      "O(V²) حيث V عدد العقد",
      "O(E log V)",
      "O(V log V)"
    ],
    "correct": 1,
    "explanation": "باستخدام مصفوفة مجاورة، التعقيد الزمني لخوارزمية Dijkstra هو O(V²)، حيث V عدد العقد، لأننا نحتاج لفحص جميع العقد في كل خطوة."
  },
  {
    "question": "ماذا يعني أن d[v] = 5 بعد تنفيذ خوارزمية Dijkstra؟",
    "options": [
      "عدد الحواف من المصدر إلى v هو 5",
      "متوسط وزن الحواف إلى v هو 5",
      "v هي العقدة الخامسة في المخطط",
      "أقصر مسافة من المصدر إلى v هي 5"
    ],
    "correct": 3,
    "explanation": "d[v] = 5 يعني أن أقصر مسافة معروفة من عقدة المصدر إلى العقدة v هي 5 وحدات (بناءً على أوزان الحواف)."
  },
  {
    "question": "ما هو دور قائمة الانتظار Q في خوارزمية Dijkstra؟",
    "options": [
      "تخزين المسارات النهائية",
      "تخزين العقد المعالجة",
      "تخزين العقد التي لم تتم معالجتها بعد",
      "تخزين أوزان الحواف"
    ],
    "correct": 2,
    "explanation": "Q هي قائمة الانتظار (أو المجموعة) التي تحتوي على جميع العقد التي لم تتم معالجتها بعد، ويتم إزالة العقد منها واحدة تلو الأخرى بعد معالجتها."
  },
  {
    "question": "لماذا لا يمكن استخدام خوارزمية BFS لإيجاد أقصر مسار في مخطط موزون؟",
    "options": [
      "لأن BFS أبطأ من Dijkstra",
      "لأن BFS لا تتعامل مع العقد المتصلة",
      "لأن BFS تعمل فقط على المخططات الموجهة",
      "لأن BFS تعد الحواف فقط وليس الأوزان"
    ],
    "correct": 3,
    "explanation": "خوارزمية BFS تعتبر جميع الحواف متساوية الوزن (وزن 1 لكل حافة)، لذلك لا يمكنها التعامل مع الأوزان المختلفة في المخطط الموزون."
  },
  {
    "question": "ما هو الشرط الذي يجب تحقيقه عند معالجة جوارات العقدة u؟",
    "options": [
      "يجب أن تكون العقدة المجاورة v معالجة مسبقاً",
      "يجب أن تكون العقدة المجاورة v غير معالجة بعد",
      "يجب أن يكون وزن الحافة سالباً",
      "يجب أن تكون v أبعد من u"
    ],
    "correct": 1,
    "explanation": "عند معالجة جوارات العقدة u، نفحص فقط العقد المجاورة التي لم تتم معالجتها بعد، لأن العقد المعالجة لها بالفعل أقصر مسار معروف."
  },
  {
    "question": "ماذا يحدث إذا كانت هناك حافة ذات وزن سالب في المخطط؟",
    "options": [
      "تصبح الخوارزمية أسرع",
      "يتم تجاهل الوزن السالب",
      "خوارزمية Dijkstra قد تعطي نتائج غير صحيحة",
      "تتحول الأوزان السالبة إلى موجبة تلقائياً"
    ],
    "correct": 2,
    "explanation": "وجود أوزان سالبة يجعل خوارزمية Dijkstra غير مناسبة، وقد تعطي نتائج غير صحيحة، ويجب استخدام خوارزميات أخرى مثل Bellman-Ford."
  },
  {
    "question": "ما هي قيمة d[s] في بداية خوارزمية Dijkstra؟",
    "options": [
      "∞",
      "0",
      "1",
      "-1"
    ],
    "correct": 1,
    "explanation": "d[s] = 0 حيث s هي عقدة المصدر، لأن المسافة من المصدر إلى نفسها تساوي صفر."
  },
  {
    "question": "ما هي قيمة pred[s] في بداية خوارزمية Dijkstra؟",
    "options": [
      "s",
      "null",
      "∞",
      "0"
    ],
    "correct": 1,
    "explanation": "pred[s] = null لأن عقدة المصدر ليس لها سلف في المسار، فهي نقطة البداية."
  },
  {
    "question": "ما هو الشرط الذي يجعلنا نوقف خوارزمية Dijkstra؟",
    "options": [
      "عندما نصل إلى عقدة محددة مسبقاً",
      "عندما تصبح Q فارغة (جميع العقد معالجة)",
      "عندما نمر بعدد محدد من الخطوات",
      "عندما تصبح جميع المسافات سالبة"
    ],
    "correct": 1,
    "explanation": "تستمر الخوارزمية في التنفيذ طالما أن هناك عقداً لم تتم معالجتها في Q، وعندما تصبح Q فارغة، تكون جميع العقد قد عولجت."
  },
  {
    "question": "لماذا نستخدم extract-min(Q) في خوارزمية Dijkstra؟",
    "options": [
      "لاستخراج العقدة ذات أكبر مسافة معروفة",
      "لاستخراج العقدة الأولى في Q",
      "لاستخراج عقدة عشوائية من Q",
      "لاستخراج العقدة ذات أقل مسافة معروفة من Q"
    ],
    "correct": 3,
    "explanation": "يجب اختيار العقدة ذات أقل مسافة معروفة (d[u]) في كل خطوة لضمان أننا نجد المسار الأقصر أولاً (مبدأ الجشعية)."
  },
  {
    "question": "ما هو المبدأ الأساسي الذي تعتمد عليه خوارزمية Dijkstra؟",
    "options": [
      "مبدأ التقسيم والتغلب (Divide and Conquer)",
      "مبدأ البرمجة الديناميكية (Dynamic Programming)",
      "مبدأ الجشعية (Greedy)",
      "مبدأ البحث الشامل (Brute Force)"
    ],
    "correct": 2,
    "explanation": "تعتمد خوارزمية Dijkstra على مبدأ الجشعية، حيث تختار في كل خطوة العقدة ذات المسافة الأقل معتقدة أن هذا سيؤدي إلى الحل الأمثل."
  },
  {
    "question": "ما هو الفرق بين Dijkstra وBFS في حساب طول المسار؟",
    "options": [
      "كلاهما يجمع أوزان الحواف",
      "BFS تجمع أوزان الحواف، Dijkstra تعد الحواف",
      "Dijkstra تجمع أوزان الحواف، BFS تعد الحواف",
      "كلاهما يعد الحواف فقط"
    ],
    "correct": 2,
    "explanation": "Dijkstra تحسب طول المسار كمجموع أوزان الحواف، بينما BFS تحسبه كعدد الحواف (بافتراض وزن 1 لكل حافة)."
  },
  {
    "question": "ما هو أول إجراء في خوارزمية Dijkstra؟",
    "options": [
      "فرز الحواف حسب الوزن",
      "تهيئة جميع d[u] = ∞ و d[s] = 0",
      "اختيار عقدة عشوائية لبدء الخوارزمية",
      "حساب جميع المسارات الممكنة"
    ],
    "correct": 1,
    "explanation": "أول إجراء هو التهيئة: تعيين مسافة لا نهائية لجميع العدد (∞) وتعيين مسافة صفر لعقدة المصدر."
  },
  {
    "question": "ما هو التطبيق العملي الشهير لخوارزمية Dijkstra؟",
    "options": [
      "ضغط البيانات",
      "فرز الملفات حسب الحجم",
      "أنظمة الملاحة مثل خرائط جوجل",
      "التشفير والأمان"
    ],
    "correct": 2,
    "explanation": "تستخدم خوارزمية Dijkstra بشكل واسع في أنظمة الملاحة والخرائط الرقمية (مثل Google Maps) لإيجاد أقصر طريق بين موقعين."
  },
  {
    "question": "ماذا يحدث إذا أردنا إيجاد أقصر مسار بين عقدتين غير المصدر؟",
    "options": [
      "نستخدم نفس النتائج مع عقدة المصدر الأصلية",
      "نعيد تشغيل الخوارزمية مع جعل إحدى العقدتين مصدراً",
      "نقوم بقلب اتجاه جميع الحواف",
      "نضيف العقدتين فقط إلى المخطط"
    ],
    "correct": 1,
    "explanation": "للحصول على أقصر مسار بين عقدتين A وB، نطبق Dijkstra مع جعل A كعقدة مصدر، ثم ننظر إلى d[B] وpred[B]."
  },
  {
    "question": "ما هو الشرط الذي يضمن أن العقدة قد وجدت أقصر مسار لها؟",
    "options": [
      "عندما تكون أول عقدة في Q",
      "عندما يتم معالجتها وإزالتها من Q",
      "عندما يكون d[u] = 0",
      "عندما يكون pred[u] = null"
    ],
    "correct": 1,
    "explanation": "عندما يتم استخراج عقدة من Q ومعالجتها، نكون قد وجدنا أقصر مسار إليها (بسبب مبدأ الجشعية وافتراض الأوزان الموجبة)."
  },
  {
    "question": "كيف يتم تمثيل حالة العقدة في خوارزمية Dijkstra؟",
    "options": [
      "باستخدام الحرف الأول من اسم العقدة",
      "باستخدام رقم عشوائي",
      "باستخدام متغير لون (مثلاً: أبيض، أسود)",
      "باستخدام وزن العقدة"
    ],
    "correct": 2,
    "explanation": "غالباً ما تستخدم الألوان لتمثيل حالة العقدة: أبيض (لم تتم زيارتها)، رمادي (قيد المعالجة)، أسود (تمت معالجتها)."
  },
  {
    "question": "ما هو الخطأ الشائع في فهم خوارزمية Dijkstra؟",
    "options": [
      "أنها أسرع خوارزمية لإيجاد أقصر مسار",
      "أنها تعمل فقط مع المخططات غير الموجهة",
      "أنها تعمل مع الأوزان السالبة",
      "أنها تحتاج إلى مصفوفة كبيرة"
    ],
    "correct": 2,
    "explanation": "الخطأ الشائع هو الاعتقاد أن Dijkstra تعمل مع الأوزان السالبة، بينما في الواقع تتطلب جميع الأوزان أن تكون غير سالبة."
  },
  {
    "question": "لماذا تعتبر خوارزمية Dijkstra كفؤة؟",
    "options": [
      "لأنها تستخدم ذاكرة قليلة جداً",
      "لأنها لا تحتاج إلى مقارنات",
      "لأنها تعمل بسرعة ثابتة",
      "لأنها لا تفحص جميع المسارات الممكنة"
    ],
    "correct": 3,
    "explanation": "تعتبر كفؤة لأنها تستخدم مبدأ الجشعية لتجنب فحص جميع المسارات الممكنة، مما يقلل من عدد العمليات المطلوبة."
  },
  {
    "question": "ماذا يعني أن المخطط 'متصل' (connected)؟",
    "options": [
      "جميع الحواف لها نفس الوزن",
      "يوجد مسار بين أي عقدتين في المخطط",
      "جميع العدد لها نفس عدد الجوارات",
      "لا توجد دوائر في المخطط"
    ],
    "correct": 1,
    "explanation": "المخطط المتصل هو الذي يوجد فيه مسار بين أي عقدتين، مما يضمن إمكانية الوصول من المصدر إلى جميع العقد الأخرى."
  },
  {
    "question": "كيف يمكن تحسين أداء خوارزمية Dijkstra؟",
    "options": [
      "بتجاهل بعض العقد",
      "باستخدام مصفوفة أكبر",
      "باستخدام كومة (Heap) بدلاً من قائمة بسيطة",
      "باستخدام أوزان عشوائية"
    ],
    "correct": 2,
    "explanation": "يمكن تحسين الأداء باستخدام بنية بيانات فعالة مثل كومة الأولوية (Priority Queue/Heap) لتخزين العقد، مما يقلل التعقيد إلى O(E log V)."
  },
  {
    "question": "ما هي المعلومة التي لا توفرها خوارزمية Dijkstra؟",
    "options": [
      "طول أقصر مسار من المصدر إلى كل عقدة",
      "أقصر مسارات من مصدر واحد إلى جميع العقد",
      "أقصر مسارات بين جميع أزواج العقد",
      "مسار أقصر من المصدر إلى كل عقدة"
    ],
    "correct": 2,
    "explanation": "Dijkstra توفر أقصر مسارات من عقدة مصدر واحدة إلى جميع العقد الأخرى، وليس أقصر مسارات بين جميع أزواج العقد (مما يتطلب خوارزميات أخرى مثل Floyd-Warshall)."
  },
  {
    "question": "ماذا يحدث إذا كان هناك عدة مسارات بنفس الطول الأقصر؟",
    "options": [
      "تدمج جميع المسارات",
      "توقف الخوارزمية عن العمل",
      "تختار أطول مسار منهم",
      "قد تختار الخوارزمية أي منهم اعتماداً على الترتيب"
    ],
    "correct": 3,
    "explanation": "إذا كان هناك عدة مسارات بنفس الطول الأقصر، فقد تختار الخوارزمية أي منهم حسب ترتيب المعالجة، وعادةً ما يظهر الأول الذي تم اكتشافه."
  },
  {
    "question": "ما هو الشرط الذي يضمن أن خوارزمية Dijkstra ستعمل بشكل صحيح؟",
    "options": [
      "جميع الأوزان أعداد صحيحة",
      "المخطط غير موجه",
      "عدد العقد أقل من 100",
      "جميع الأوزان غير سالبة والمخطط متصل"
    ],
    "correct": 3,
    "explanation": "الشرطين الأساسيين هما: 1) جميع أوزان الحواف غير سالبة (≥ 0)، 2) المخطط متصل (أو على الأقل يمكن الوصول من المصدر إلى جميع العقد المطلوبة)."
  },
  {
    "question": "ما هو الغرض من color[u] في تنفيذ خوارزمية Dijkstra؟",
    "options": [
      "لتحديد لون العرض للعقدة",
      "لتتبع حالة العقدة (معالجة/غير معالجة)",
      "لتحديد اتجاه العقدة",
      "لتخزين وزن العقدة"
    ],
    "correct": 1,
    "explanation": "يستخدم color[u] لتتبع حالة العقدة: عادةً أبيض (غير مزار)، رمادي (قيد المعالجة)، أسود (تمت معالجتها)."
  },
  {
    "question": "كيف نعرف أن العقدة قد وصلت إلى أقصر مسار ممكن؟",
    "options": [
      "عندما يكون d[u] = 0",
      "عندما تكون العقدة الأولى في المخطط",
      "عندما يتم استخراجها من Q باستخدام extract-min",
      "عندما يكون pred[u] = u"
    ],
    "correct": 2,
    "explanation": "عند استخراج عقدة من Q باستخدام extract-min (أي أنها الأقرب بين العقد غير المعالجة)، نكون قد وجدنا أقصر مسار إليها بسبب مبدأ الجشعية."
  }



          ],
          lec4:[
  {
    "question": "ما هو التعريف الدقيق للمسار (Walk) في نظرية المخططات؟",
    "options": [
      "تسلسل من العقد حيث لا تتكرر أي عقدة",
      "تسلسل من العقد والحواف حيث يمكن تكرار العقد والحواف، ويمكن أن يكون مفتوحاً أو مغلقاً",
      "تسلسل من الحواف حيث لا تتكرر أي حافة",
      "تسلسل من العقد حيث تبدأ وتنتهي بنفس العقدة دون تكرار عقد أخرى"
    ],
    "correct": 1,
    "explanation": "المسار (Walk) هو أبسط تسلسل في المخطط، حيث يمكن تكرار العقد والحواف، ويمكن أن يبدأ وينتهي بعقدتين مختلفتين (مفتوح) أو بنفس العقدة (مغلق)."
  },
  {
    "question": "كيف يختلف المسار الحقيقي (Trail) عن المسار العادي (Walk)؟",
    "options": [
      "لا يسمح بتكرار العقد",
      "لا يسمح بتكرار الحواف، لكن يسمح بتكرار العقد",
      "يجب أن يبدأ وينتهي بنفس العقدة",
      "يجب أن يكون جميع العقد بدرجة زوجية"
    ],
    "correct": 1,
    "explanation": "المسار الحقيقي (Trail) هو مسار (Walk) لا تُكرر فيه أي حافة، لكن يُسمح بتكرار العقد. يمكن أن يكون مفتوحاً أو مغلقاً."
  },
  {
    "question": "ما هو الشرط الأساسي لوجود دائرة أويلر (Euler Circuit) في مخطط غير موجه؟",
    "options": [
      "أن يكون المخطط متصلاً وأن تكون جميع درجات العقد فردية",
      "أن يكون المخطط متصلاً وأن تكون جميع درجات العقد زوجية",
      "أن يكون المخطط غير متصل وأن تكون درجات العقد زوجية",
      "أن يحتوي المخطط على عقدتين بالضبط بدرجة فردية"
    ],
    "correct": 1,
    "explanation": "نظرية أويلر تنص على أن المخطط غير الموجه المتصل يحتوي على دائرة أويلر (Euler Circuit) إذا وفقط إذا كانت درجة كل عقدة في المخطط عدداً زوجياً."
  },
  {
    "question": "متى يكون للمخطط مسار أويلر (Euler Path) ولكن ليس دائرة أويلر (Euler Circuit)؟",
    "options": [
      "عندما يكون المخطط غير متصل",
      "عندما تكون جميع درجات العقد زوجية",
      "عندما يكون المخطط متصلاً ويكون له بالضبط عقدتان درجتهما فردية",
      "عندما يكون المخطط متصلاً ويكون له أكثر من عقدتين درجتهما فردية"
    ],
    "correct": 2,
    "explanation": "المخطط المتصل يكون له مسار أويلر (Euler Path) إذا وفقط إذا كان له بالضبط عقدتان درجتهما فردية. مسار أويلر يبدأ بإحدى هاتين العقدتين وينتهي بالأخرى."
  },
  {
    "question": "ما الفرق بين المسار (Path) والدائرة (Cycle) في المخططات؟",
    "options": [
      "المسار لا يتكرر فيه العقد، والدائرة هي مسار مغلق (تبدأ وتنتهي بنفس العقدة)",
      "المسار يتكرر فيه العقد، والدائرة لا تتكرر فيها العقد",
      "كلاهما يسمح بتكرار العقد",
      "الدائرة يجب أن تحتوي على جميع عقد المخطط"
    ],
    "correct": 0,
    "explanation": "المسار (Path) هو تسلسل عقد لا يتكرر فيه أي عقدة. الدائرة (Cycle) هي مسار مغلق، أي مسار يبدأ وينتهي بنفس العقدة ولا يحتوي على أي عقدة مكررة غير نقطة البداية/النهاية."
  },
  {
    "question": "في مخطط متصل، إذا كانت درجات العقد: A=2, B=3, C=3, D=2، فماذا يمكن أن نستنتج حول وجود مسار أويلر؟",
    "options": [
      "يحتوي على دائرة أويلر لأن جميع الدرجات زوجية",
      "يحتوي على مسار أويلر لأنه يحتوي على عقدتين درجتهما فردية (B و C)",
      "لا يحتوي على مسار أويلر لأنه يحتوي على أكثر من عقدتين درجتهما فردية",
      "يحتوي على مسار أويلر لأن جميع الدرجات فردية"
    ],
    "correct": 2,
    "explanation": "المخطط يحتوي على عقدتين (B و C) درجتهما فردية. شرط وجود مسار أويلر هو أن يكون للمخطط بالضبط عقدتان درجتهما فردية. هنا العدد هو 2، لذا يوجد مسار أويلر يبدأ من إحداهما وينتهي بالأخرى."
  },
  {
    "question": "ما هو الهدف الأساسي من خوارزمية هيرهولزر (Hierholzer's Algorithm)؟",
    "options": [
      "إيجاد أقصر مسار بين عقدتين",
      "إيجاد شجرة الامتداد الدنيا",
      "إيجاد دائرة أويلر (Euler Circuit) في مخطط أويلري",
      "تحديد إذا ما كان المخطط متصلاً"
    ],
    "correct": 2,
    "explanation": "خوارزمية هيرهولزر هي خوارزمية فعالة لإيجاد دائرة أويلر (أو مسار أويلر) في المخطط الأويلري (المتصل وذو درجات عقد مناسبة). تعتمد على فكرة دمج الدوائر البسيطة."
  },
  {
    "question": "أثناء تنفيذ خوارزمية هيرهولزر، ماذا نفعله عندما تكون العقدة الحالية (location) ليس لها جوارات غير مزارة؟",
    "options": [
      "نختار عقدة بداية جديدة عشوائياً",
      "نضيف العقدة الحالية إلى الدائرة (circuit)، ثم نسحب عقدة من قمة المكدس (stack) لتصبح العقدة الحالية الجديدة",
      "ننهي الخوارزمية ونعلن فشلها",
      "نحذف العقدة الحالية من المخطط"
    ],
    "correct": 1,
    "explanation": "عندما تصل إلى عقدة ليس لها جوارات غير مزارة (أي أن جميع حوافها قد استُخدمت)، تضيف هذه العقدة إلى قائمة الدائرة النهائية (circuit). ثم تعيد العودة بالتراجع: تسحب العقدة من أعلى المكدس (stack) لتصبح العقدة الحالية الجديدة، وتستمر من هناك."
  },
  {
    "question": "ما هو 'الجسر' (Bridge) في نظرية المخططات؟",
    "options": [
      "أقصر مسار بين عقدتين",
      "حافة إذا حذفناها أصبح المخطط غير متصل",
      "أعلى عقدة في الشجرة",
      "حافة تربط بين عقدتين بدرجة فردية"
    ],
    "correct": 1,
    "explanation": "الجسر (أو الحافة القاطعة - Cut Edge) هي حافة في مخطط متصل إذا أزلناها، يصبح المخطط غير متصل. وجودها مهم في خوارزمية فلوري (Fleury's Algorithm) لتجنب عزل أجزاء من المخطط أثناء بناء مسار أويلر."
  },
  {
    "question": "ما هي القاعدة الذهبية في خوارزمية فلوري (Fleury's Algorithm) عند اختيار الحافة التالية للسير عليها؟",
    "options": [
      "اختر دائماً أقصر حافة",
      "اختر أي حافة غير مزارة",
      "لا تسير على حافة جسر (bridge) إذا كان هناك خيار آخر (حافة غير جسر)",
      "اسرع دائماً على الحواف المتصلة بالعقد ذات الدرجة الفردية أولاً"
    ],
    "correct": 2,
    "explanation": "خوارزمية فلوري تحذر من السير على جسر (حافة قاطعة) إلا إذا لم يكن هناك خيار آخر. السير على جسر مبكراً قد يعزل جزءاً من المخطط ويجعله غير قابل للوصول لاحقاً، مما يفشل في إكمال مسار أويلر."
  },
  {
    "question": "في مخطط متصل، إذا كانت جميع درجات العقد زوجية، فماذا نستطيع القول عن المخطط؟",
    "options": [
      "يحتوي على دائرة أويلر (Euler Circuit)",
      "يحتوي على مسار أويلر (Euler Path) فقط",
      "لا يحتوي على أي من مسار أو دائرة أويلر",
      "يحتوي على دائرة هاميلتونية (Hamiltonian Cycle)"
    ],
    "correct": 0,
    "explanation": "طبقاً لنظرية أويلر، المخطط المتصل الذي جميع درجات عقدة زوجية يسمى مخططاً أويلياً (Eulerian) ويحتوي على دائرة أويلر (Euler Circuit) - وهي دائرة تمر بكل حافة مرة واحدة بالضبط وتعود لنقطة البداية."
  },
  {
    "question": "خلال تطبيق خوارزمية هيرهولزر، ما هو دور المكدس (Stack)؟",
    "options": [
      "لتخزين العقد التي تمت زيارتها بشكل نهائي",
      "لتخزين تسلسل العقد التي بدأنا بها ولكن لم نكمل بناء الدائرة منها بعد (مسار مؤقت)",
      "لحساب درجات العقد",
      "لتحديد العقد التي هي جسور"
    ],
    "correct": 1,
    "explanation": "المكدس (Stack) في خوارزمية هيرهولزر يُستخدم لتخزين العقد التي مررنا بها أثناء بناء مسار فرعي، ولكننا اضطررنا لتركها مؤقتاً لأنها قد تؤدي لاحقاً إلى دمج دوائر أخرى. عند التراجع، نأخذ العقد من المكدس لدمج هذه المسارات الفرعية في الدائرة النهائية."
  },
  {
    "question": "لنفترض مخططاً به 6 عقد. ما هو الحد الأدنى لعدد الحواف التي يجب أن يمر بها أي مسار أويلر (Euler Path) فيه؟",
    "options": [
      "5",
      "6",
      "يساوي عدد حواف المخطط",
      "لا يمكن معرفته دون معرفة درجات العقد"
    ],
    "correct": 2,
    "explanation": "تعريف مسار أويلر (أو دائرة أويلر) هو أنه مسار يمر بكل حافة في المخطط مرة واحدة بالضبط. لذلك، طول المسار (بعدد الحواف) يساوي حتماً العدد الكلي للحواف في المخطط، بغض النظر عن عدد العقد."
  },
  {
    "question": "إذا كان المخطط غير متصل، فهل يمكن أن يحتوي على دائرة أويلر؟",
    "options": [
      "نعم، إذا كان كل مكون متصل على حدة يحقق شروط أويلر",
      "نعم، إذا كان يحتوي على عقدتين درجتهما فردية",
      "لا، لأن شرط الاتصال هو شرط أساسي في نظريات أويلر",
      "لا، إلا إذا كان المخطط شجرة"
    ],
    "correct": 2,
    "explanation": "الشرط الأساسي الأول في نظريات أويلر للمسار والدائرة هو أن يكون المخطط متصلاً. إذا كان المخطط غير متصل، فلا يمكن وجود مسار واحد يمر بجميع حواف المكونات المتصلة المختلفة دون رفع القلم (أو القفز بينها)."
  },
  {
    "question": "في خوارزمية فلوري، كيف نتحقق مما إذا كانت حافة ما هي جسر (Bridge)؟",
    "options": [
      "نحسب درجة العقدة عند طرفي الحافة",
      "نحذف الحافة مؤقتاً ونفحص إذا بقي المخطط متصلاً باستخدام DFS أو BFS",
      "نرى إذا كانت الحافة هي الأخيرة المتبقية للعقدة",
      "نرى إذا كانت العقدة طرفيها لهما درجة فردية"
    ],
    "correct": 1,
    "explanation": "للتحقق مما إذا كانت حافة ما هي جسر، نحذفها مؤقتاً من المخطط (أو نعتبرها مزارة)، ثم نستخدم خوارزمية استكشاف (مثل DFS أو BFS) لفحص ما إذا كان المخطط يبقى متصلاً. إذا أصبح غير متصل، فإن الحافة هي جسر."
  },
  {
    "question": "ما هي نتيجة خوارزمية هيرهولزر إذا بدأنا من عقدة درجتها فردية في مخطط له مسار أويلر؟",
    "options": [
      "ستفشل الخوارزمية",
      "ستنتج دائرة أويلر",
      "ستنتج مسار أويلر يبدأ من تلك العقدة وينتهي بالعقدة الفردية الأخرى",
      "ستنتج مساراً يمر ببعض الحواف فقط"
    ],
    "correct": 2,
    "explanation": "إذا كان للمخطط مسار أويلر (عقدتان درجتهما فردية)، وخوارزمية هيرهولزر تبدأ بإحدى هاتين العقدتين، فإنها ستنتج مسار أويلر ينتهي بالعقدة الفردية الأخرى. إذا كانت جميع الدرجات زوجية وبدأنا من أي عقدة، ستنتج دائرة أويلر."
  },
  {
    "question": "كم عدد العقد ذات الدرجة الفردية يمكن أن يوجد في مخطط له دائرة أويلر؟",
    "options": [
      "0",
      "1",
      "2",
      "أي عدد، المهم أن يكون المخطط متصلاً"
    ],
    "correct": 0,
    "explanation": "من تعريف دائرة أويلر (Euler Circuit)، يجب أن تكون جميع درجات العقد في المخطط المتصل أعداداً زوجية. لذلك، عدد العقد ذات الدرجة الفردية هو صفر."
  },
  {
    "question": "ما هو التسلسل الصحيح من الأكثر عمومية إلى الأكثر تقييداً فيما يلي؟",
    "options": [
      "Walk → Trail → Path → Cycle",
      "Trail → Walk → Path → Cycle",
      "Cycle → Path → Trail → Walk",
      "Path → Cycle → Trail → Walk"
    ],
    "correct": 0,
    "explanation": "Walk هو الأعم (يمكن تكرار العقد والحواف). Trail أكثر تقييداً (لا تكرار للحواف). Path أكثر تقييداً (لا تكرار للعقد). Cycle هو الأكثر تقييداً (Path مغلق)."
  },
  {
    "question": "في مخطط عليه تطبيق خوارزمية فلوري، وصلنا إلى عقدة ولها عدة حواف غير مزارة، إحداها جسر والبقية ليست جسوراً. ماذا نختار؟",
    "options": [
      "نختار أي حافة عشوائياً",
      "نختار الحافة الأقصر",
      "نختار حافة غير الجسر (Not a Bridge)",
      "نختار الجسر (Bridge) لأنها قد تقودنا إلى عقدة مهمة"
    ],
    "correct": 2,
    "explanation": "القاعدة في خوارزمية فلوري هي: تجنب السير على جسر ما دام هناك بديل. نختار أي حافة غير جسر من بين الحواف المتاحة. هذا يمنع عزل أجزاء من الرسم البياني قبل زيارتها."
  },
  {
    "question": "لنفترض مخططاً متصلاً درجات عقدة هي: 2, 2, 4, 2, 2. ما نوع مسار أويلر الموجود فيه؟",
    "options": [
      "دائرة أويلر (Euler Circuit)",
      "مسار أويلر (Euler Path)",
      "لا يوجد مسار أويلر",
      "يحتوي على كليهما"
    ],
    "correct": 0,
    "explanation": "جميع درجات العقد زوجية (2, 2, 4, 2, 2) والمخطط متصل. وفقاً لنظرية أويلر، يحتوي على دائرة أويلر (Euler Circuit)."
  },
  {
    "question": "خلال خوارزمية هيرهولزر، عندما نضيف عقدة إلى 'الدائرة' (circuit)، في أي ترتيب تضاف عادةً؟",
    "options": [
      "بترتيب عكسي لترتيب زيارتها (التراجع)",
      "بنفس ترتيب زيارتها (من البداية للنهاية)",
      "بترتيب عشوائي",
      "بترتيب تصاعدي لدرجة العقدة"
    ],
    "correct": 0,
    "explanation": "في خوارزمية هيرهولزر، تُضاف العقد إلى قائمة الدائرة النهائية (circuit) أثناء التراجع، عندما لا يكون للعقدة الحالية جوارات غير مزارة. لذلك، تُسجل العقد بترتيب معكوس لمسار الاستكشاف العميق الأول، مما يؤدي في النهاية إلى الترتيب الصحيح للدائرة عند عكس القائمة أو قراءتها من النهاية."
  },
  {
    "question": "إذا طُلب منك رسم مخطط بدون رفع القلم عن الورقة وبدون رسم أي خط أكثر من مرة، فأي مفهوم نظري تبحث عنه؟",
    "options": [
      "المخطط الثنائي (Bipartite Graph)",
      "المخطط الهاملتوني (Hamiltonian Graph)",
      "المخطط الأويلري (Eulerian Graph) أو وجود مسار أويلر",
      "شجرة الامتداد (Spanning Tree)"
    ],
    "correct": 2,
    "explanation": "مشكلة 'رسم مخطط دون رفع القلم' تُترجم مباشرة إلى مشكلة إيجاد مسار أويلر (Euler Path) أو دائرة أويلر (Euler Circuit) في المخطط. المسار/الدائرة الأويلرية تمر بكل حافة مرة واحدة بالضبط."
  },
  {
    "question": "ما هي الحالة التي يجبرنا فيها تطبيق خوارزمية فلوري على السير على جسر (Bridge)؟",
    "options": [
      "عندما تكون الحافة الوحيدة غير المزارة من العقدة الحالية",
      "عندما نكون في بداية الخوارزمية",
      "عندما تكون العقدة الحالية بدرجة زوجية",
      "عندما نكون في منتصف الطريق"
    ],
    "correct": 0,
    "explanation": "في خوارزمية فلوري، القاعدة هي تجنب الجسور. الاستثناء الوحيد هو عندما تكون الحافة الوحيدة المتاحة (غير المزارة) للخروج من العقدة الحالية هي جسراً. في هذه الحالة، ليس لدينا خيار آخر، فيجب السير عليها."
  },
  {
    "question": "أي من العبارات التالية تصف بشكل صحيح دائرة أويلر (Euler Circuit)؟",
    "options": [
      "دائرة تزور كل عقدة مرة واحدة بالضبط",
      "مسار يبدأ وينتهي بعقدتين مختلفتين ويمر بكل الحواف مرة واحدة",
      "دائرة تزور كل حافة في المخطط مرة واحدة بالضبط",
      "مسار يمر بكل عقدة مرة واحدة على الأقل"
    ],
    "correct": 2,
    "explanation": "دائرة أويلر (Euler Circuit) هي دائرة (مسار مغلق) في مخطط متصل تمر عبر كل حافة في المخطط مرة واحدة بالضبط. قد تزور العقد أكثر من مرة. (المسار الذي يزور كل عقدة مرة واحدة يسمى دائرة هاملتونية)."
  },
  {
    "question": "كيف نحسب عدد الحواف التي مررنا بها من خلال تسلسل عقد مثل A-B-C-D-E؟",
    "options": [
      "نعد عدد العقد (هنا 5)",
      "نعد عدد الفراغات بين العقد في التسلسل (هنا 4)",
      "نعد عدد العقد الفريدة (هنا 5 أيضاً)",
      "نعد عدد العقد ذات الدرجة الفردية"
    ],
    "correct": 1,
    "explanation": "في تسلسل العقد لمسار، يمثل الانتقال بين عقدتين متتاليتين حافة. لذلك، عدد الحواف يساوي عدد الفراغات أو الأسهم بين العقد في التسلسل المكتوب. للتسلسل A-B-C-D-E، الحواف هي: (A,B), (B,C), (C,D), (D,E) أي 4 حواف."
  },
  {
    "question": "ماذا نسمي المخطط الذي يحتوي على دائرة أويلر؟",
    "options": [
      "مخطط هاميلتوني (Hamiltonian Graph)",
      "مخطط أويلري (Eulerian Graph)",
      "مخطط شجري (Tree)",
      "مخطط ثنائي (Bipartite Graph)"
    ],
    "correct": 1,
    "explanation": "المخطط الذي يحتوي على دائرة أويلر (أي متصل وجميع درجات عقدة زوجية) يسمى مخططاً أويلياً (Eulerian Graph)."
  },
  {
    "question": "إذا كان مخطط متصل يحتوي على 4 عقد درجاتها فردية، فماذا نستنتج عن إمكانية وجود مسار أويلر؟",
    "options": [
      "يحتوي على مسار أويلر",
      "يحتوي على دائرة أويلر",
      "لا يحتوي على مسار أو دائرة أويلر",
      "يحتوي على مسارين منفصلين لأويلر"
    ],
    "correct": 2,
    "explanation": "شرط وجود مسار أويلر (Euler Path) هو أن يكون عدد العقد فردية الدرجة هو 0 أو 2. إذا كان 4 (أو أي عدد زوجي أكبر من 2)، فلا يوجد مسار أويلر ولا دائرة أويلر (التي تتطلب 0 عقد فردية)."
  },
  {
    "question": "في بداية خوارزمية هيرهولزر، إذا كان المخطط له عقدتان درجتهما فردية، فأي عقدة نختار لبدء الخوارزمية؟",
    "options": [
      "أي عقدة عشوائية",
      "يجب أن نبدأ بأحدى العقدتين ذوات الدرجة الفردية",
      "يجب أن نبدأ بالعقدة ذات الدرجة الأعلى",
      "يجب أن نبدأ بالعقدة ذات الدرجة الزوجية"
    ],
    "correct": 1,
    "explanation": "إذا كان المخطط يحتوي على عقدتين درجتهما فردية (شرط مسار أويلر)، فيجب أن نبدأ الخوارزمية بإحدى هاتين العقدتين. الناتج سيكون مسار أويلر يبدأ بهذه العقدة وينتهي بالأخرى."
  },
  {
    "question": "ما هو الفرق الأساسي بين نهج خوارزمية هيرهولزر وخوارزمية فلوري؟",
    "options": [
      "هيرهولزر تعمل فقط على المخططات غير المتصلة",
      "فلوري تتطلب تحققاً مستمراً من الجسور أثناء التنفيذ، بينما هيرهولزر لا تفعل ذلك",
      "هيرهولزر أبطأ من فلوري",
      "فلوري فقط لإيجاد دوائر أويلر وليس مسارات"
    ],
    "correct": 1,
    "explanation": "الفرق الجوهري هو أن خوارزمية فلوري حذرة وتتطلب التحقق في كل خطوة مما إذا كانت الحافة المراد استخدامها هي جسر (Bridge)، وتتجنبها إن أمكن. خوارزمية هيرهولزر لا تهتم بالجسور بشكل صريح؛ فهي تتبع نهجاً تراكمياً لدمج الدوائر وهو آلي أكثر."
  },
  {
    "question": "إذا أردنا تحويل مخطط له مسار أويلر (عقدتان فرديتان) إلى مخطط له دائرة أويلر، فماذا نفعل؟",
    "options": [
      "نحذف إحدى العقد الفردية",
      "نضيف حافة تربط بين العقدتين الفرديتين",
      "نحذف حافة تربط بين عقدتين زوجيتين",
      "نقسم المخطط إلى قسمين"
    ],
    "correct": 1,
    "explanation": "المخطط الذي له مسار أويلر (عقدتان درجتهما فردية) يمكن تحويله إلى مخطط أويلري (له دائرة أويلر) بإضافة حافة جديدة تربط بين هاتين العقدتين الفرديتين. هذه الحافة الجديدة ستجعل درجة كلتيهما زوجية، وبالتالي يتحقق شرط دائرة أويلر (شريطة أن يبقى المخطط متصلاً)."
  },
  {
    "question": "خلال خوارزمية هيرهولزر، ماذا يمثل متغير 'الموقع' (location)؟",
    "options": [
      "العقدة التي بدأنا منها",
      "العقدة التي انتهينا إليها في الدائرة النهائية",
      "العقدة الحالية التي نستكشف جواراتها",
      "مؤشر إلى قمة المكدس"
    ],
    "correct": 2,
    "explanation": "متغير 'الموقع' (location) في خوارزمية هيرهولزر يحتفظ بالعقدة الحالية التي نوجد فيها ونبحث عن جوار غير مزار للانتقال إليه. هو بمثابة مؤشر التحرك خلال الخوارزمية."
  },
  {
    "question": "لماذا يُعتبر اختبار 'رسم مخطط دون رفع القلم' ممتعاً من الناحية النظرية؟",
    "options": [
      "لأنه يتحدى الذكاء المكاني فقط",
      "لأنه يختبر فهم المفاهيم المجردة مثل درجة العقدة واتصال المخطط",
      "لأنه يحتاج إلى أداة رسم خاصة",
      "لأنه مستحيل في معظم الحالات"
    ],
    "correct": 1,
    "explanation": "هذا الاختبار البسيط هو تطبيق عملي لنظرية أويلر في نظرية المخططات. الإجابة عليه لا تعتمد على المحاولة والخطأ، بل على التحليل النظري: حساب درجات العقد والتحقق من اتصال المخطط، مما يربط بين الحدس البصري والأساس الرياضي."
  },
  {
    "question": "في أي مرحلة من خوارزمية هيرهولزر نعتبر أن الخوارزمية قد انتهت بنجاح؟",
    "options": [
      "عندما تصبح 'الموقع' (location) عقدة ليس لها جوارات",
      "عندما يصبح المكدس (stack) فارغاً والموقع (location) غير معرّف (فارغ)",
      "عندما نضيف أول عقدة إلى الدائرة (circuit)",
      "عندما نحذف جميع الحواف"
    ],
    "correct": 1,
    "explanation": "تنتهي خوارزمية هيرهولزر بنجاح عندما يصبح هيكلا البيانات الرئيسيان فارغين: المكدس (stack) فارغ، ولا توجد عقدة حالية (location) نعالجها. هذا يعني أننا أضفنا جميع العقد إلى الدائرة النهائية ودمجنا جميع المسارات الفرعية."
  },
  {
    "question": "إذا كان مخطط ما متصلاً وله عقدة واحدة فقط درجة فردية، هل هذا ممكن وفقاً لنظرية المصافحة (Handshaking Lemma)؟",
    "options": [
      "نعم، وهذا يعني أنه يحتوي على دائرة أويلر",
      "نعم، وهذا يعني أنه يحتوي على مسار أويلر",
      "لا، مستحيل. مجموع الدرجات في أي مخطط هو عدد زوجي، لذا لا يمكن أن يكون عدد العقد فردية الدرجة فردياً",
      "نعم، ولكن هذا نادر جداً"
    ],
    "correct": 2,
    "explanation": "نظرية المصافحة تنص على أن مجموع درجات جميع العقد في أي مخطط يساوي ضعف عدد الحواف (وهو عدد زوجي). لذلك، يجب أن يكون عدد العقد ذات الدرجة الفردية عدداً زوجياً. وجود عقدة واحدة بدرجة فردية مستحيل."
  },
  {
    "question": "أي من التسلسلات التالية يمكن أن يمثل 'مساراً' (Path) صالحاً في مخطط؟",
    "options": [
      "A-B-C-A-D",
      "A-B-C-D",
      "A-B-A-C",
      "A-B-C-B-D"
    ],
    "correct": 1,
    "explanation": "المسار (Path) لا يتكرر فيه أي عقدة. في الخيارات: A-B-C-A-D تكررت A. A-B-A-C تكررت A و B. A-B-C-B-D تكررت B. فقط A-B-C-D لا يتكرر فيه أي حرف، لذا هو مسار محتمل."
  },
  {
    "question": "ما الخطوة الأولى التي يجب القيام بها قبل تطبيق أي خوارزمية للعثور على مسار أويلر؟",
    "options": [
      "فرز العقد أبجدياً",
      "التحقق من اتصال المخطط",
      "حساب وزن كل حافة",
      "إيجاد أقصر مسار بين عقدتين"
    ],
    "correct": 1,
    "explanation": "الشرط الأساسي لوجود مسار أو دائرة أويلر هو أن يكون المخطط متصلاً. لذلك، الخطوة الأولى والأهم هي التحقق من اتصال المخطط باستخدام BFS أو DFS."
  }
          ],
          lec5:[
  {
    "question": "ما هو المسار الهاملتوني (Hamilton Path) في نظرية المخططات؟",
    "options": [
      "مسار يزور كل حافة مرة واحدة فقط",
      "مسار مغلق يزور كل عقدة مرة واحدة فقط",
      "مسار مفتوح يزور كل عقدة مرة واحدة فقط",
      "مسار يزور العقد المتجاورة فقط"
    ],
    "correct": 2,
    "explanation": "المسار الهاملتوني هو مسار مفتوح (يبدأ وينتهي بعقدتين مختلفتين) يمر عبر كل عقدة في المخطط مرة واحدة بالضبط."
  },
  {
    "question": "ما هي الدورة الهاملتونية (Hamilton Cycle)؟",
    "options": [
      "دورة تزور كل حافة مرة واحدة فقط",
      "دورة تحتوي على جميع العقد المتجاورة",
      "مسار مفتوح يزور كل العقد",
      "دورة تزور كل عقدة مرة واحدة فقط"
    ],
    "correct": 3,
    "explanation": "الدورة الهاملتونية هي دورة مغلقة تمر عبر كل عقدة في المخطط مرة واحدة بالضبط."
  },
  {
    "question": "ما هي خاصية Ore الكافية لوجود دورة هاملتونية؟",
    "options": [
      "درجة كل عقدة ≥ n/2",
      "عدد الحواف ≥ n(n-1)/2",
      "المخطط متصل بالكامل",
      "مجموع درجتي أي عقدتين غير متجاورتين ≥ n"
    ],
    "correct": 3,
    "explanation": "شرط Ore: إذا كان مجموع درجتي أي عقدتين غير متجاورتين في مخطط متصل ذي n عقدة يساوي على الأقل n، فإن المخطط يحوي دورة هاملتونية."
  },
  {
    "question": "ما هو شرط Dirac الكافي لوجود دورة هاملتونية؟",
    "options": [
      "المخطط ثنائي التفرع",
      "درجة كل عقدة ≥ n/2",
      "مجموع درجتي أي عقدتين ≥ n",
      "المخطط مستو"
    ],
    "correct": 1,
    "explanation": "شرط Dirac: إذا كانت درجة كل عقدة في مخطط متصل ذي n عقدة (n ≥ 3) تساوي على الأقل n/2، فإن المخطط هاملتوني."
  },
  {
    "question": "هل تحقيق شرط Ore أو Dirac يضمن أن المخطط ليس هاملتونيًا إذا لم يتحقق؟",
    "options": [
      "نعم، إذا لم يتحقق الشرط يكون المخطط غير هاملتوني",
      "نعم، يثبت عدم وجود دورة هاملتونية",
      "لا، فهو شرط كافٍ وليس شرطًا لازمًا",
      "يعتمد على عدد الحواف"
    ],
    "correct": 2,
    "explanation": "شرطا Ore وDirac هما شروط كافية وليست ضرورية. تحقيقهما يضمن وجود دورة هاملتونية، ولكن عدم تحقيقهما لا يعني عدم وجودها."
  },
  {
    "question": "ما هو النوعان الرئيسيان للخوارزميات المستخدمة لإيجاد دورة هاملتونية؟",
    "options": [
      "الجشعة (Greedy) والحيوية (Dynamic)",
      "القسمة والتغلب (Divide and Conquer) والفرز (Sorting)",
      "التراجعية (Backtracking) والاستكشافية (Heuristic)",
      "العشوائية (Randomized) والحتمية (Deterministic)"
    ],
    "correct": 2,
    "explanation": "يتم استخدام خوارزميات التراجع (Backtracking) للبحث الشامل، والخوارزميات الاستكشافية (Heuristic) للبحث التقريبي، لإيجاد دورات هاملتونية."
  },
  {
    "question": "ما هي فكرة خوارزمية التراجع (Backtracking) لإيجاد دورة هاملتونية؟",
    "options": [
      "تعتمد على القيام بخطوة ثم التراجع عنها إذا لم تنجح",
      "تستخدم خوارزميات جينية للبحث",
      "تقوم بتوزيع العناصر في صناديق",
      "تستخدم طريقة فرق تسد"
    ],
    "correct": 0,
    "explanation": "تقوم خوارزمية التراجع بتجربة مسارات مختلفة، وإذا وصلت إلى طريق مسدود (dead-end)، ترجع إلى الخطوة السابقة وتجرب خيارًا آخر."
  },
  {
    "question": "ما هي مشكلة تعقيد خوارزمية التراجع (Backtracking) لإيجاد دورة هاملتونية؟",
    "options": [
      "تعقيدها من رتبة O(n²)",
      "تعقيدها من رتبة O(n!)",
      "تعقيدها من رتبة O(log n)",
      "تعقيدها من رتبة O(2ⁿ)"
    ],
    "correct": 1,
    "explanation": "خوارزمية التراجع لإيجاد دورة هاملتونية ذات تعقيد عالٍ جدًا، من الرتبة العامليّة (O(n!))، لأنها قد تحتاج لفحص جميع ترتيبات العقد."
  },
  {
    "question": "ما هي الخوارزمية الاستكشافية (Heuristic) المستخدمة في إيجاد دورة هاملتونية؟",
    "options": [
      "خوارزمية تعتمد على الفرز السريع",
      "فرع من الخوارزميات الجينية والتقريبية",
      "خوارزمية تعتمد على البحث الثنائي",
      "خوارزمية تعتمد على البرمجة الخطية"
    ],
    "correct": 1,
    "explanation": "الخوارزميات الاستكشافية هي خوارزميات تقريبية تنتمي إلى عائلة الخوارزميات الجينية، تستخدم في الذكاء الاصطناعي للبحث عن حلول تقريبية."
  },
  {
    "question": "في خوارزمية التراجع، ماذا يعني 'dead-end'؟",
    "options": [
      "نقطة بداية الخوارزمية",
      "عقدة لا يمكن الوصول إليها",
      "مسار لا يمكن الاستمرار فيه لإكمال الدورة",
      "حافة زائدة عن الحاجة"
    ],
    "correct": 2,
    "explanation": "الـ dead-end في خوارزمية التراجع يعني أن المسار الحالي لا يمكن أن يؤدي إلى دورة هاملتونية كاملة، مما يتطلب التراجع."
  },
  {
    "question": "ماذا يحدث عندما تصل خوارزمية التراجع إلى 'dead-end'؟",
    "options": [
      "تتوقف الخوارزمية فورًا",
      "تستمر في البحث عشوائيًا",
      "ترجع إلى الخطوة السابقة وتجرب خيارًا آخر",
      "تغير البداية إلى عقدة أخرى"
    ],
    "correct": 2,
    "explanation": "عند الوصول إلى طريق مسدود، تقوم الخوارزمية بالتراجع إلى العقدة السابقة وتحاول حافة أخرى غير مجربة."
  },
  {
    "question": "ما هو الشرط الأول في خوارزمية التراجع لإيجاد دورة هاملتونية؟",
    "options": [
      "إذا كان طول المسار يساوي n",
      "إذا كانت هناك حافة بين أول وآخر عقدة",
      "إذا وجدت حافة غير مزارة",
      "إذا كانت جميع العقد مزارة"
    ],
    "correct": 1,
    "explanation": "الشرط الأول هو التحقق من وجود حافة بين آخر عقدة في المسار والعقدة الأولى، بالإضافة إلى أن المسار يحتوي على جميع العقد."
  },
  {
    "question": "ما هو الشرط الثاني في خوارزمية التراجع لإيجاد دورة هاملتونية؟",
    "options": [
      "إذا كان طول المسار يساوي n",
      "إذا كانت هناك حافة غير مزارة",
      "إذا كانت العقدة الجديدة غير موجودة في المسار",
      "إذا كانت جميع الحواف مزارة"
    ],
    "correct": 0,
    "explanation": "الشرط الثاني هو التحقق مما إذا كان طول المسار يساوي عدد العقد n، مما يعني أننا وجدنا مسارًا هاملتونيًا."
  },
  {
    "question": "في كود الخوارزمية التراجعية، ماذا يحدث بعد الاستدعاء العودي؟",
    "options": [
      "تضاف عقدة جديدة إلى المسار",
      "تحدد العقدة التالية عشوائيًا",
      "تتم إزالة آخر عقدة من المسار وإعادة تعليم الحافة",
      "تتوقف الخوارزمية"
    ],
    "correct": 2,
    "explanation": "بعد العودة من الاستدعاء العودي، تقوم الخوارزمية بحذف آخر عقدة من المسار وإعادة تعليم الحافة على أنها غير مزارة (التراجع)."
  },
  {
    "question": "ما هو الهدف من تعليم الحواف بأنها 'مزارة' أو 'غير مزارة'؟",
    "options": [
      "لتحديد اتجاه المخطط",
      "لتجنب تكرار زيارة نفس الحافة في نفس المسار",
      "لحساب درجة كل عقدة",
      "لتحديد إذا كان المخطط متصلاً"
    ],
    "correct": 1,
    "explanation": "يتم تعليم الحواف لتجنب استخدام نفس الحافة أكثر من مرة في نفس المسار أثناء البحث عن دورة هاملتونية."
  },
  {
    "question": "ما الذي يميز الدورة الهاملتونية عن الدورة العادية؟",
    "options": [
      "تزور كل حافة مرة واحدة",
      "تزور كل عقدة مرة واحدة فقط",
      "تكون دائماً مغلقة",
      "تكون دائماً مفتوحة"
    ],
    "correct": 1,
    "explanation": "الدورة الهاملتونية تزور كل عقدة في المخطط مرة واحدة بالضبط، بينما الدورة العادية قد تزور بعض العقد أكثر من مرة."
  },
  {
    "question": "كم عدد العقد التي يجب أن يزورها المسار الهاملتوني؟",
    "options": [
      "نصف عدد العقد",
      "جميع العقد",
      "عدد الحواف فقط",
      "العقد ذات الدرجة العالية فقط"
    ],
    "correct": 1,
    "explanation": "يجب أن يزور المسار الهاملتوني جميع عقد المغراف مرة واحدة بالضبط."
  },
  {
    "question": "إذا كان المخطط يحتوي على 10 عقد، ما هو الحد الأدنى لدرجة كل عقدة لتحقيق شرط Dirac؟",
    "options": [
      "2",
      "5",
      "10",
      "20"
    ],
    "correct": 1,
    "explanation": "وفقًا لشرط Dirac، يجب أن تكون درجة كل عقدة ≥ n/2 = 10/2 = 5."
  },
  {
    "question": "ما هو المثال الشهير لمشكلة هاملتونية عملية؟",
    "options": [
      "مشكلة البائع المتجول (TSP)",
      "مشكلة أقصر مسار",
      "مشكلة التدفق الأقصى",
      "مشكلة التلوين"
    ],
    "correct": 0,
    "explanation": "مشكلة البائع المتجول (Traveling Salesman Problem) هي أشهر تطبيق لمشكلة الدورة الهاملتونية، حيث يبحث البائع عن أقصر طريق يزور كل مدينة مرة واحدة."
  },
  {
    "question": "ما هو الفرق بين المسار الهاملتوني والدورة الهاملتونية؟",
    "options": [
      "المسار مغلق والدورة مفتوحة",
      "الدورة تزور كل الحواف والمسار يزور كل العقد",
      "المسار مفتوح والدورة مغلقة",
      "لا يوجد فرق"
    ],
    "correct": 2,
    "explanation": "المسار الهاملتوني مفتوح (يبدأ وينتهي بعقدتين مختلفتين)، بينما الدورة الهاملتونية مغلقة (تبدأ وتنتهي بنفس العقدة)."
  },
  {
    "question": "لماذا تُعتبر مشكلة إيجاد دورة هاملتونية صعبة؟",
    "options": [
      "لأنها تحتاج إلى معادلات رياضية معقدة",
      "لأنها تنتمي إلى فئة NP-complete",
      "لأنها تتطلب ذاكرة كبيرة فقط",
      "لأنها لا تحتوي على خوارزمية معروفة"
    ],
    "correct": 1,
    "explanation": "مشكلة الدورة الهاملتونية تنتمي إلى فئة NP-complete، مما يعني أنه لا توجد خوارزمية معروفة ذات تعقيد زمني متعدد الحدود لحلها في الحالة العامة."
  },
  {
    "question": "ما هو الهدف الأساسي من استخدام الخوارزميات الاستكشافية (Heuristic)؟",
    "options": [
      "إيجاد الحل الأمثل دائماً",
      "إيجاد حل تقريبي في وقت معقول",
      "تقليل استخدام الذاكرة",
      "تبسيط كتابة الكود"
    ],
    "correct": 1,
    "explanation": "الخوارزميات الاستكشافية تهدف إلى إيجاد حلول تقريبية جيدة (وليست بالضرورة مثالية) في وقت معقول للمشكلات الصعبة حسابيًا."
  },
  {
    "question": "في خوارزمية التراجع، ماذا يعني 'التراجع' (Backtracking)؟",
    "options": [
      "حذف جميع البيانات والبدء من جديد",
      "الانتقال إلى عقدة عشوائية",
      "العودة إلى خطوة سابقة وتجريب خيار آخر",
      "تخطي بعض العقد"
    ],
    "correct": 2,
    "explanation": "التراجع يعني العودة إلى حالة سابقة في البحث عندما لا يمكن المضي قدمًا، وتجريب مسار مختلف."
  },
  {
    "question": "ما هو دور المتغير 'path' في خوارزمية التراجع؟",
    "options": [
      "يخزن درجات العقد",
      "يخزن تسلسل العقد المزارة",
      "يحدد اتجاه الحواف",
      "يحسب عدد الحواف"
    ],
    "correct": 1,
    "explanation": "المتغير 'path' يخزن تسلسل العقد التي تمت زيارتها في المسار الحالي أثناء البحث عن دورة هاملتونية."
  },
  {
    "question": "كيف يتم تحديد ما إذا كانت عقدة ما 'موجودة في المسار'؟",
    "options": [
      "بمقارنة درجتها مع العقد الأخرى",
      "بالتحقق مما إذا كانت في قائمة 'path'",
      "بالتحقق من وجود حواف متصلة بها",
      "بحساب بعدها عن العقدة الأولى"
    ],
    "correct": 1,
    "explanation": "يتم التحقق مما إذا كانت العقدة موجودة بالفعل في قائمة 'path' لتجنب زيارة نفس العقدة أكثر من مرة."
  },
  {
    "question": "ما هو الشرط الذي يجعل العقدة مرشحة للإضافة إلى المسار؟",
    "options": [
      "أن تكون درجة العقدة عالية",
      "أن تكون غير موجودة في المسار ويوجد حافة غير مزارة لها",
      "أن تكون قريبة من العقدة الأولى",
      "أن تكون متصلة بجميع العقد الأخرى"
    ],
    "correct": 1,
    "explanation": "يجب أن تكون العقدة غير موجودة في المسار الحالي، ويجب أن تكون متصلة بالعقدة الحالية بحافة لم تُزر بعد."
  },
  {
    "question": "لماذا نستخدم الاستدعاء الذاتي (Recursion) في خوارزمية التراجع؟",
    "options": [
      "لتحسين سرعة التنفيذ",
      "لتبسيط عملية التراجع واستكشاف المسارات",
      "لتقليل استخدام الذاكرة",
      "لجعل الكود أقصر فقط"
    ],
    "correct": 1,
    "explanation": "الاستدعاء الذاتي يبسط تنفيذ خوارزمية التراجع، حيث يسمح بالعودة تلقائيًا إلى الحالات السابقة عند التراجع."
  },
  {
    "question": "ما الذي يحدث عندما يتحقق الشرط الأول في الخوارزمية؟",
    "options": [
      "يتم إضافة عقدة جديدة",
      "يتم التراجع",
      "يتم الإعلان عن وجود دورة هاملتونية",
      "يتم تغيير العقدة الأولى"
    ],
    "correct": 2,
    "explanation": "عندما يتحقق الشرط الأول (وجود حافة بين آخر عقدة وأول عقدة، وطول المسار = n)، يتم الإعلان عن وجود دورة هاملتونية."
  },
  {
    "question": "ما هو الفرق بين الشروط الكافية والضرورية؟",
    "options": [
      "الكافية تكفي لإثبات الشيء، والضرورية لازمة لوجوده",
      "الكافية لازمة لوجوده، والضرورية تكفي لإثباته",
      "لا فرق بينهما",
      "الكافية تعني أن الشيء ممكن، والضرورية تعني أنه مؤكد"
    ],
    "correct": 0,
    "explanation": "الشرط الكافي: إذا تحقق، فإن الشيء محقق (ولكن قد يتحقق الشيء بدونه). الشرط الضروري: إذا لم يتحقق، فإن الشيء غير محقق (ولكن تحققه لا يضمن تحقق الشيء)."
  },
  {
    "question": "لماذا لا نستطيع الاعتماد فقط على شروط Ore وDirac؟",
    "options": [
      "لأنها معقدة جدًا في التطبيق",
      "لأنها شروط كافية وليست ضرورية",
      "لأنها تعمل فقط على المخططات الصغيرة",
      "لأنها تحتاج إلى حواف كثيرة"
    ],
    "correct": 1,
    "explanation": "لأن شروط Ore وDirac هي شروط كافية فقط - إذا تحققت، نعرف أن المخطط هاملتوني، ولكن إذا لم تتحقق، قد يكون المخطط هاملتونيًا مع ذلك."
  },
  {
    "question": "ما هو مثال على مخطط قد يكون هاملتونيًا رغم عدم تحقيق شروط Ore وDirac؟",
    "options": [
      "المخطط الكامل (Complete Graph)",
      "المخطط ذو الحلقة الواحدة",
      "بعض المخططات الخاصة مثل Petersen Graph",
      "المخطط الشجري (Tree)"
    ],
    "correct": 2,
    "explanation": "هناك مخططات مثل Petersen Graph التي تكون هاملتونية رغم أنها لا تحقق شروط Ore وDirac."
  },
  {
    "question": "ما الذي يميز خوارزميات Heuristic عن Backtracking؟",
    "options": [
      "هي أبطأ ولكن أكثر دقة",
      "هي أسرع ولكن قد لا تجد الحل الأمثل",
      "هي تستخدم في المخططات الصغيرة فقط",
      "هي لا تحتاج إلى برمجة"
    ],
    "correct": 1,
    "explanation": "الخوارزميات الاستكشافية أسرع عمومًا وتجد حلولًا تقريبية في وقت معقول، ولكنها لا تضمن إيجاد الحل الأمثل دائمًا."
  },
  {
    "question": "ما هو تطبيق عملي للدورة الهاملتونية؟",
    "options": [
      "تلوين الخرائط",
      "توجيه حركة المرور",
      "تخطيط رحلة تزور كل مدينة مرة واحدة",
      "ربط شبكات الحاسوب"
    ],
    "correct": 2,
    "explanation": "تخطيط رحلة تزور كل مدينة مرة واحدة فقط ثم تعود إلى نقطة البداية هو تطبيق عملي لمشكلة الدورة الهاملتونية."
  },
  {
    "question": "كيف نبدأ خوارزمية التراجع عمليًا؟",
    "options": [
      "من العقدة ذات الدرجة الأعلى",
      "من أي عقدة نختارها",
      "من العقدة المركزية",
      "من العقدة المعزولة"
    ],
    "correct": 1,
    "explanation": "يمكن بدء خوارزمية التراجع من أي عقدة في المخطط، حيث أن الدورة الهاملتونية يجب أن تمر بجميع العقد."
  },
  {
    "question": "ما هي الحالة التي يعيد فيها البرنامج 'Hamilton Path' بدلاً من 'Hamilton Cycle'؟",
    "options": [
      "عندما يكون طول المسار = n",
      "عندما يكون هناك حافة بين أول وآخر عقدة",
      "عندما تزور كل العقد ولكن لا يمكن العودة للبداية",
      "عندما يكون المخطط غير متصل"
    ],
    "correct": 0,
    "explanation": "عندما يزور المسار جميع العقد (طول المسار = n) ولكن لا توجد حافة تربط آخر عقدة بأول عقدة، يكون لدينا مسار هاملتوني وليس دورة."
  },
  {
    "question": "ماذا يحدث بعد إضافة عقدة جديدة إلى المسار في الخوارزمية؟",
    "options": [
      "تتوقف الخوارزمية",
      "يتم تعليم الحافة كمزارة ويستدعى التابع للعقدة الجديدة",
      "يتم حذف العقدة السابقة",
      "يتم تغيير العقدة الأولى"
    ],
    "correct": 1,
    "explanation": "بعد إضافة عقدة جديدة إلى المسار، يتم تعليم الحافة بين العقدة الحالية والجديدة كمزارة، ثم يتم استدعاء التابع بشكل عودي للعقدة الجديدة."
  },
  {
    "question": "ما هو الهدف من 'إعادة تعليم الحافة كغير مزارة' في قسم التراجع؟",
    "options": [
      "لجعل الخوارزمية أسرع",
      "للسماح باستخدام نفس الحافة في مسارات أخرى",
      "لحساب درجة العقدة بدقة",
      "لتحديد إذا كانت الحافة ضرورية"
    ],
    "correct": 1,
    "explanation": "إعادة تعليم الحافة كغير مزارة تسمح باستخدامها في مسارات أخرى أثناء البحث، وهو أساس عملية التراجع."
  },
  {
    "question": "كيف نعرف أننا وجدنا دورة هاملتونية في المثال العملي بالمحاضرة؟",
    "options": [
      "عندما تزور جميع العقد",
      "عندما يكون هناك حافة تربط آخر عقدة بأول عقدة",
      "عندما تتحقق الشروط في التابع FindHamiltonCycle",
      "عندما لا يكون هناك dead-ends"
    ],
    "correct": 2,
    "explanation": "في المثال العملي، عندما يستدعى التابع من أجل عقدة وتتحقق الشروط في التابع FindHamiltonCycle، يتم الإعلان عن وجود دورة هاملتونية."
  },
  {
    "question": "ما هو دور العقدة 's' في بداية الخوارزمية؟",
    "options": [
      "هي العقدة الوحيدة التي يمكن البدء منها",
      "هي العقدة المركزية",
      "هي العقدة الأولى التي نختارها للبدء",
      "هي العقدة الأخيرة دائمًا"
    ],
    "correct": 2,
    "explanation": "العقدة 's' هي نقطة البداية التي نختارها لبدء البحث عن دورة هاملتونية."
  },
  {
    "question": "لماذا تُعتبر خوارزمية التراجع غير عملية للمخططات الكبيرة؟",
    "options": [
      "لأنها تحتاج إلى معالج قوي",
      "لأن تعقيدها الزمني هائل (O(n!))",
      "لأنها تحتاج إلى ذاكرة كبيرة",
      "لأنها معقدة في البرمجة"
    ],
    "correct": 1,
    "explanation": "بسبب تعقيدها الزمني الهائل (من الرتبة العامليّة O(n!))، تصبح خوارزمية التراجع غير عملية للمخططات التي تحتوي على عدد كبير من العقد."
  },
  {
    "question": "ما هو البديل عن خوارزمية التراجع للمخططات الكبيرة؟",
    "options": [
      "استخدام خوارزميات تقريبية (Heuristic)",
      "استخدام نفس الخوارزمية ولكن على حاسوب أسرع",
      "تقسيم المخطط إلى أجزاء صغيرة",
      "تجاهل بعض العقد"
    ],
    "correct": 0,
    "explanation": "بالنسبة للمخططات الكبيرة، تُستخدم الخوارزميات التقريبية (Heuristic) التي تجد حلولًا مقبولة في وقت معقول بدلاً من الحل الأمثل."
  }
],
          lec6:[
  {
    "question": "إذا كان مخطط بسيط يحوي 15 حافة، و3 رؤوس درجتها 4، وباقي الرؤوس درجتها 3، فكم عدد الرؤوس في هذا المخطط؟",
    "options": [
      "6",
      "7",
      "8",
      "9"
    ],
    "correct": 3,
    "explanation": "باستخدام معادلة مجموع الدرجات = 2 × عدد الحواف: 3×4 + 3×(n-3) = 2×15 → 12 + 3n - 9 = 30 → 3n = 27 → n = 9"
  },
  {
    "question": "مخطط له 5 رؤوس درجتها 3، هل هذا المخطط ممكن؟",
    "options": [
      "نعم، لأن مجموع الدرجات 15",
      "لا، لأن عدد الحواف يجب أن يكون صحيحًا",
      "نعم، لأن جميع الدرجات متساوية",
      "لا، لأن عدد الرؤوس الفردية فردي"
    ],
    "correct": 1,
    "explanation": "∑d(v) = 5×3 = 15 = 2m → m = 7.5، وهذا غير ممكن لأن عدد الحواف يجب أن يكون عددًا صحيحًا."
  },
  {
    "question": "مركز هاتف فيه 25 هاتفًا، كل هاتف موصول بـ 7 أسلاك. هل يمكن تمثيل هذا بمخطط؟",
    "options": [
      "نعم، لأن جميع الدرجات متساوية",
      "لا، لأن عدد الرؤوس الفردية يجب أن يكون زوجيًا",
      "نعم، لأن 25 × 7 = 175",
      "لا، لأن عدد الأسلاك كبير جدًا"
    ],
    "correct": 1,
    "explanation": "مجموع الدرجات = 25 × 7 = 175 (فردي)، بينما يجب أن يكون مجموع الدرجات زوجيًا دائمًا (∑d(v) = 2m)."
  },
  {
    "question": "ما هي معادلة المجموع الأساسية في نظرية المخططات؟",
    "options": [
      "∑d(v) = n",
      "∑d(v) = 2m",
      "∑d(v) = m",
      "∑d(v) = n(n-1)/2"
    ],
    "correct": 1,
    "explanation": "مجموع درجات جميع الرؤوس في أي مخطط يساوي ضعف عدد الحواف: ∑d(v) = 2m."
  },
  {
    "question": "إذا كانت درجات العقد في مخطط: 1,2,2,3,3,4,4,4,5,5,7,7، فهل هذا المخطط ممكن؟",
    "options": [
      "نعم، لأن مجموع الدرجات زوجي",
      "لا، لأن هناك درجات فردية",
      "نعم، لأن هناك 12 عقدة",
      "لا، لأن عدد العقد ذات الدرجة الفردية فردي"
    ],
    "correct": 3,
    "explanation": "عدد العقد ذات الدرجة الفردية: 1,3,3,5,5,7,7 = 7 عقد (فردي)، وهذا غير ممكن لأن عدد العقد ذات الدرجة الفردية يجب أن يكون زوجيًا."
  },
  {
    "question": "ما هو المخطط المتمم (Complement Graph)؟",
    "options": [
      "مخطط بنفس العقد ولكن مع عكس اتجاه الحواف",
      "مخطط بنفس العقد ولكن مع إضافة الحواف المفقودة وإزالة الموجودة",
      "مخطط بألوان مختلفة للحواف",
      "مخطط بنصف عدد الحواف"
    ],
    "correct": 1,
    "explanation": "المخطط المتمم لمخطط G هو مخطط يحتوي على نفس مجموعة الرؤوس، ويحتوي على حافة بين رأسين إذا وفقط إذا لم تكن هناك حافة بينهما في G."
  },
  {
    "question": "إذا كان مخطط له 4 حواف، فكم عدد حواف متممه إذا كان عدد الرؤوس n=5؟",
    "options": [
      "6",
      "10",
      "4",
      "2"
    ],
    "correct": 0,
    "explanation": "عدد حواف المخطط التام K₅ = 5×4/2 = 10. حواف المتمم = 10 - 4 = 6."
  },
  {
    "question": "كيف نحسب عدد حواف المخطط المتمم؟",
    "options": [
      "n(n-1)/2 - حواف المخطط الأصلي",
      "n(n+1)/2 - حواف المخطط الأصلي",
      "حواف المخطط الأصلي / 2",
      "n² - حواف المخطط الأصلي"
    ],
    "correct": 0,
    "explanation": "حواف المتمم = حواف المخطط التام - حواف المخطط الأصلي = n(n-1)/2 - m."
  },
  {
    "question": "ما هو المخطط التام (Complete Graph)؟",
    "options": [
      "مخطط كل عقدته متصلة بجميع العقد الأخرى",
      "مخطط بدون حلقات",
      "مخطط منتظم",
      "مخطط ثنائي التفرع"
    ],
    "correct": 0,
    "explanation": "المخطط التام هو مخطط غير موجه حيث يوجد حافة بين كل زوج من الرؤوس المختلفة."
  },
  {
    "question": "ما هي صيغة عدد حواف المخطط التام Kₙ؟",
    "options": [
      "n",
      "n-1",
      "n(n-1)/2",
      "n²/2"
    ],
    "correct": 2,
    "explanation": "عدد حواف المخطط التام Kₙ = C(n,2) = n(n-1)/2."
  },
  {
    "question": "متى يكون المخطط منتظمًا (Regular Graph)؟",
    "options": [
      "عندما تكون جميع العقد لها نفس الدرجة",
      "عندما تكون جميع الحواف متساوية الطول",
      "عندما يكون المخطط تامًا",
      "عندما يكون المخطط مستويًا"
    ],
    "correct": 0,
    "explanation": "المخطط المنتظم هو مخطط حيث جميع الرؤوس لها نفس الدرجة."
  },
  {
    "question": "ما هي درجة كل رأس في المخطط التام Kₙ؟",
    "options": [
      "n",
      "n-1",
      "n/2",
      "1"
    ],
    "correct": 1,
    "explanation": "في المخطط التام Kₙ، كل رأس متصل بجميع الرؤوس n-1 الأخرى، لذا درجة كل رأس = n-1."
  },
  {
    "question": "متى يكون المخطط التام Kₙ منتظمًا؟",
    "options": [
      "دائماً",
      "عندما يكون n زوجيًا",
      "عندما يكون n فرديًا",
      "عندما يكون n > 2"
    ],
    "correct": 0,
    "explanation": "المخطط التام Kₙ هو دائماً منتظم لأن جميع رؤوسه لها نفس الدرجة (n-1)."
  },
  {
    "question": "ما هو المخطط الثنائي التفرع (Bipartite Graph)؟",
    "options": [
      "مخطط يمكن تقسيم رؤوسه إلى مجموعتين",
      "مخطط له لونان فقط",
      "مخطط كل عقدته لها درجة 2",
      "مخطط منتظم"
    ],
    "correct": 0,
    "explanation": "المخطط الثنائي التفرع هو مخطط يمكن تقسيم مجموعة رؤوسه إلى مجموعتين غير متقاطعتين بحيث تكون كل حافة بين رأس من مجموعة ورأس من المجموعة الأخرى."
  },
  {
    "question": "ما هو أكبر عدد للحواف في مخطط ثنائي تفرع بـ 10 رؤوس؟",
    "options": [
      "20",
      "25",
      "30",
      "45"
    ],
    "correct": 1,
    "explanation": "يتحقق أكبر عدد من الحواف عندما يتساوى عدد رؤوس المجموعتين (5 و5)، ويكون المخطط تامًا ثنائي التفرع: 5 × 5 = 25 حافة."
  },
  {
    "question": "كم حافة في المخطط الثنائي التفرع التام K₃,₃؟",
    "options": [
      "3",
      "6",
      "9",
      "12"
    ],
    "correct": 2,
    "explanation": "K₃,₃ له 3 رؤوس في المجموعة الأولى و3 في الثانية، وكل رأس في المجموعة الأولى متصل بجميع رؤوس المجموعة الثانية: 3 × 3 = 9 حواف."
  },
  {
    "question": "متى يكون المخطط الثنائي التفرع التام Kₙ,ₘ منتظمًا؟",
    "options": [
      "عندما يكون n = m",
      "عندما يكون n و m زوجيين",
      "دائماً",
      "عندما يكون n ≠ m"
    ],
    "correct": 0,
    "explanation": "يكون Kₙ,ₘ منتظمًا عندما تكون n = m، لأن جميع رؤوس المجموعة الأولى لها درجة m، وجميع رؤوس المجموعة الثانية لها درجة n، وعند n = m تكون جميع الدرجات متساوية."
  },
  {
    "question": "كيف نتحقق مما إذا كان المخطط ثنائي تفرع؟",
    "options": [
      "باستخدام خوارزمية BFS وتلوين الرؤوس",
      "بحساب عدد الحواف",
      "بمقارنة درجات الرؤوس",
      "بفحص إذا كان المخطط منتظمًا"
    ],
    "correct": 0,
    "explanation": "يمكن استخدام خوارزمية BFS مع تلوين الرؤوس بلونين. إذا استطعنا تلوين الرؤوس بحيث لا يكون للرؤوس المتجاورة نفس اللون، فإن المخطط ثنائي تفرع."
  },
  {
    "question": "ما هو مخطط البيت (House Graph)؟",
    "options": [
      "مخطط يشبه شكل المنزل",
      "مخطط له 5 رؤوس و6 حواف",
      "مخطط خاص يستخدم في الأمثلة",
      "جميع ما سبق"
    ],
    "correct": 3,
    "explanation": "مخطط البيت هو مخطط خاص له شكل المنزل، يتكون من 5 رؤوس و6 حواف، ويستخدم غالبًا في الأمثلة التوضيحية."
  },
  {
    "question": "إذا كان مخطط رتبته 14 وحجمه 27، ودرجة كل رأس إما 3 أو 4 أو 5، وهناك 6 رؤوس درجتها 4، فكم رأس درجته 3؟",
    "options": [
      "3",
      "5",
      "6",
      "8"
    ],
    "correct": 1,
    "explanation": "نفرض x عدد الرؤوس درجة 3، y عدد الرؤوس درجة 5. من المعادلتين: 6+x+y=14 و 6×4+3x+5y=2×27 نحصل على x=5."
  },
  {
    "question": "ما هي رتبة المخطط (Order)؟",
    "options": [
      "عدد الحواف",
      "عدد الرؤوس",
      "أكبر درجة",
      "مجموع الدرجات"
    ],
    "correct": 1,
    "explanation": "رتبة المخطط (Order) هي عدد رؤوسه، ويرمز لها عادة بـ n."
  },
  {
    "question": "ما هو حجم المخطط (Size)؟",
    "options": [
      "عدد الرؤوس",
      "عدد الحواف",
      "مجموع درجات الرؤوس",
      "أصغر درجة"
    ],
    "correct": 1,
    "explanation": "حجم المخطط (Size) هو عدد حوافه، ويرمز له عادة بـ m."
  },
  {
    "question": "لماذا يجب أن يكون عدد الرؤوس ذات الدرجة الفردية زوجيًا؟",
    "options": [
      "لأن مجموع الدرجات يجب أن يكون فرديًا",
      "لأن ∑d(v) = 2m وهو زوجي دائمًا",
      "لأن المخطط يجب أن يكون متصلاً",
      "لأن الدرجة القصوى محدودة"
    ],
    "correct": 1,
    "explanation": "بما أن ∑d(v) = 2m وهو زوجي دائمًا، فإن مجموع الدرجات الفردية يجب أن يكون زوجيًا، وهذا يتطلب أن يكون عدد الرؤوس ذات الدرجة الفردية زوجيًا."
  },
  {
    "question": "ما هي الدرجة (Degree) في المخطط؟",
    "options": [
      "عدد الحواف المتصلة بالرأس",
      "عدد الرؤوس في المخطط",
      "طول أقصر مسار",
      "عدد الدورات في المخطط"
    ],
    "correct": 0,
    "explanation": "درجة الرأس في مخطط غير موجه هي عدد الحواف المتصلة به (مع احتساب الحلقات مرتين)."
  },
  {
    "question": "إذا كان لدينا مخطط بسيط بـ 8 رؤوس، فما هو الحد الأقصى لعدد الحواف؟",
    "options": [
      "28",
      "32",
      "64",
      "16"
    ],
    "correct": 0,
    "explanation": "الحد الأقصى للحواف في مخطط بسيط بـ n رأس هو عندما يكون المخطط تامًا: n(n-1)/2 = 8×7/2 = 28."
  },
  {
    "question": "ما هو المخطط البسيط (Simple Graph)؟",
    "options": [
      "مخطط بدون حلقات أو حواف متعددة",
      "مخطط منتظم",
      "مخطط متصل",
      "مخطط مستو"
    ],
    "correct": 0,
    "explanation": "المخطط البسيط هو مخطط غير موجه لا يحتوي على حلقات (حواف تربط الرأس بنفسه) ولا حواف متعددة (أكثر من حافة تربط نفس الرأسين)."
  },
  {
    "question": "إذا كان n=6، فما هي درجة كل رأس في K₆؟",
    "options": [
      "5",
      "6",
      "15",
      "3"
    ],
    "correct": 0,
    "explanation": "في K₆، كل رأس متصل بجميع الرؤوس الخمسة الأخرى، لذا درجة كل رأس = 5."
  },
  {
    "question": "كم حافة في K₄؟",
    "options": [
      "4",
      "6",
      "8",
      "12"
    ],
    "correct": 1,
    "explanation": "K₄ له 4 رؤوس، عدد حوافه = 4×3/2 = 6."
  },
  {
    "question": "ما هو العدد الكلي للحواف في Kₙ,ₘ؟",
    "options": [
      "n+m",
      "n×m",
      "n(n-1)/2",
      "m(m-1)/2"
    ],
    "correct": 1,
    "explanation": "في المخطط الثنائي التفرع التام Kₙ,ₘ، كل رأس من المجموعة الأولى (حجمها n) متصل بجميع رؤوس المجموعة الثانية (حجمها m)، لذا عدد الحواف = n×m."
  },
  {
    "question": "إذا كان مخطط له 10 رؤوس جميعها درجة 3، فكم عدد حوافه؟",
    "options": [
      "10",
      "15",
      "20",
      "30"
    ],
    "correct": 1,
    "explanation": "∑d(v) = 10×3 = 30 = 2m → m = 15."
  },
  {
    "question": "ماذا نسمي المخطط الذي لا يحتوي على حواف؟",
    "options": [
      "المخطط الفارغ",
      "المخطط التام",
      "المخطط المنفصل",
      "المخطط البسيط"
    ],
    "correct": 0,
    "explanation": "المخطط الفارغ (Empty Graph) هو مخطط لا يحتوي على أي حواف."
  },
  {
    "question": "ما هو مخطط الطريق (Path Graph)؟",
    "options": [
      "مخطط على شكل مسار مستقيم",
      "مخطط به جسور",
      "مخطط متصل تمامًا",
      "مخطط منتظم"
    ],
    "correct": 0,
    "explanation": "مخطط الطريق Pₙ هو مخطط رؤوسه مرتبة في تسلسل، وكل رأس متصل بالرأس الذي يليه فقط."
  },
  {
    "question": "كم حافة في مخطط الطريق Pₙ؟",
    "options": [
      "n",
      "n-1",
      "n+1",
      "2n"
    ],
    "correct": 1,
    "explanation": "مخطط الطريق Pₙ له n-1 حافة، حيث يرتبط كل رأس بالرأس التالي له فقط."
  },
  {
    "question": "ما هو مخطط الدورة (Cycle Graph)؟",
    "options": [
      "مخطط على شكل حلقة",
      "مخطط به دوائر متعددة",
      "مخطط غير متصل",
      "مخطط منتظم درجة 2"
    ],
    "correct": 3,
    "explanation": "مخطط الدورة Cₙ هو مخطط منتظم درجة 2، حيث تكون الرؤوس مرتبة في حلقة مغلقة."
  },
  {
    "question": "كم حافة في مخطط الدورة Cₙ؟",
    "options": [
      "n",
      "n-1",
      "n+1",
      "2n"
    ],
    "correct": 0,
    "explanation": "مخطط الدورة Cₙ له n حافة، حيث يرتبط كل رأس بالرأس الذي يليه والرأس الذي قبله."
  },
  {
    "question": "إذا كان مخطط منتظم درجة 4 وبه 20 حافة، فكم عدد رؤوسه؟",
    "options": [
      "5",
      "10",
      "15",
      "20"
    ],
    "correct": 1,
    "explanation": "∑d(v) = n×4 = 2×20 = 40 → 4n = 40 → n = 10."
  },
  {
    "question": "ما هي خاصية المخطط المستوي (Planar Graph)؟",
    "options": [
      "يمكن رسمه بدون تقاطعات للحواف",
      "جميع رؤوسه على مستوى واحد",
      "مخطط منتظم",
      "مخطط تام"
    ],
    "correct": 0,
    "explanation": "المخطط المستوي هو مخطط يمكن رسمه في المستوى بدون تقاطع للحواف (باستثناء التقاطع عند الرؤوس)."
  },
  {
    "question": "ما هو عدد الحواف في المخطط الثنائي التفرع الأقصى مع 12 رأس؟",
    "options": [
      "36",
      "48",
      "24",
      "30"
    ],
    "correct": 0,
    "explanation": "لتحقيق أقصى عدد من الحواف، نقسم الرؤوس إلى مجموعتين متساويتين (6 و6): 6×6 = 36 حافة."
  },
  {
    "question": "إذا كان Kₙ هو مخطط تام، فماذا يمثل متممه؟",
    "options": [
      "مخطط فارغ",
      "مخطط تام آخر",
      "مخطط منتظم",
      "مخطط ثنائي تفرع"
    ],
    "correct": 0,
    "explanation": "متمم المخطط التام Kₙ هو مخطط فارغ (بدون حواف)، لأن كل زوج من الرؤوس متصل في Kₙ، لذا لا يوجد أي حواف في المتمم."
  },
  {
    "question": "ما هي درجة كل رأس في المخطط الفارغ بـ n رأس؟",
    "options": [
      "0",
      "1",
      "n-1",
      "n"
    ],
    "correct": 0,
    "explanation": "في المخطط الفارغ، لا توجد أي حواف، لذا درجة كل رأس = 0."
  },
  {
    "question": "كيف نتحقق من أن مخطط ما ليس ثنائي تفرع؟",
    "options": [
      "إذا احتوى على دورة فردية",
      "إذا كان عدد الرؤوس زوجيًا",
      "إذا كان منتظمًا",
      "إذا كان له متمم"
    ],
    "correct": 0,
    "explanation": "المخطط ليس ثنائي تفرع إذا احتوى على دورة ذات طول فردي (دورة بعدد فردي من الحواف)."
  },
  {
    "question": "ما هو مخطط النجمة (Star Graph)؟",
    "options": [
      "مخطط برأس مركزي متصل بجميع الرؤوس الأخرى",
      "مخطط على شكل نجمة",
      "نوع من المخططات الثنائية التفرع",
      "جميع ما سبق"
    ],
    "correct": 3,
    "explanation": "مخطط النجمة Sₙ له رأس مركزي متصل بجميع الرؤوس n-1 الأخرى، وهو مخطط ثنائي تفرع."
  }
]
            }
        }
        ,
        رسوميات :{
          name:"رسوميات حاسوبية ",
          lectures:{

          }

        }
        ,
        اشارة  :{
          name:"معالجة اشارة ",
          lectures:{
            
          }

        },
        معالج :{
          name:"معالج مصغر  ",
          lectures:{
            
          }

        },
        معلومات  :{
          name:"نظرية المعلومات  ",
          lectures:{
            lec1:[
  {
    "question": "ما هو تعريف 'منبع المعلومات' في نظرية المعلومات؟",
    "options": [
      "جهاز يُطلق رموزًا مثل (s1, s2, s3, ...)",
      "جهاز يستقبل الإشارات فقط",
      "نظام تشفير البيانات",
      "خوارزمية ضغط البيانات"
    ],
    "correct": 0,
    "explanation": "في نظرية المعلومات، يُعرَّف منبع المعلومات بأنه أي جهاز يُطلق رموزًا مثل (s1, s2, s3, ...)، سواء كانت هذه الرموز أرقامًا أو حروفًا أو إشارات."
  },
  {
    "question": "ما هي شروط احتمالات الرموز في منبع المعلومات؟",
    "options": [
      "p(s) > 1 دائمًا",
      "مجموع الاحتمالات > 1",
      "0 ≤ p(s) ≤ 1 ومجموع الاحتمالات = 1",
      "لا يوجد شروط"
    ],
    "correct": 2,
    "explanation": "يجب أن تكون احتمالات الرموز بين 0 و 1، ومجموع احتمالات جميع الرموز في فضاء العينة يساوي 1."
  },
  {
    "question": "ما هو الاحتمال الشرطي p(x|y)؟",
    "options": [
      "احتمال وقوع x و y معًا",
      "احتمال وقوع x بشرط وقوع y",
      "احتمال وقوع x فقط",
      "احتمال وقوع y فقط"
    ],
    "correct": 1,
    "explanation": "الاحتمال الشرطي p(x|y) هو احتمال وقوع الحدث x علماً بأن الحدث y قد وقع."
  },
  {
    "question": "متى يكون الحدثان x و y مستقلين؟",
    "options": [
      "عندما يكون p(x|y) = p(x)",
      "عندما يكون p(x∩y) = p(x) * p(y)",
      "كلاهما صحيح",
      "لا شيء مما سبق"
    ],
    "correct": 2,
    "explanation": "الحدثان مستقلان إذا كان احتمال وقوعهما معًا يساوي حاصل ضرب احتماليهما المنفردين، أو إذا كان احتمال وقوع أحدهما لا يتأثر بوقوع الآخر."
  },
  {
    "question": "ما هو اللوغاريتم المستخدم في هذه المادة؟",
    "options": [
      "اللوغاريتم الثنائي (أساس 2)",
      "اللوغاريتم الطبيعي (أساس e)",
      "جميع ما سبق",
      "اللوغاريتم العشري (أساس 10)"
    ],
    "correct": 0,
    "explanation": "في نظرية المعلومات، يُستخدم اللوغاريتم الثنائي (أساس 2) لقياس كمية المعلومات بالبت."
  },
  {
    "question": "ما هي خاصية اللوغاريتم: log(x * y)؟",
    "options": [
      "log x + log y",
      "log x - log y",
      "x * log y",
      "y * log x"
    ],
    "correct": 0,
    "explanation": "إحدى خواص اللوغاريتم هي: log(x * y) = log x + log y."
  },
  {
    "question": "ما هو 'منبع ذو ذاكرة'؟",
    "options": [
      "منبع لا يتذكر أي رمز سابق",
      "منبع يتذكر الرمز السابق عند إطلاق الرمز التالي",
      "منبع يُطلق رموزًا عشوائية دائمًا",
      "منبع يعمل فقط مع الأرقام"
    ],
    "correct": 1,
    "explanation": "منبع ذو ذاكرة هو منبع له قدرة على تذكر الرمز (أو الرموز) السابقة، مما يؤثر على احتمالات الرموز التالية."
  },
  {
    "question": "ما هو 'منبع بدون ذاكرة'؟",
    "options": [
      "منبع يعتمد على الذاكرة الخارجية",
      "منبع يُطلق رموزًا ثابتة فقط",
      "منبع تكون أحداثه مستقلة ولا يعتمد الرمز على السابق",
      "منبع يتذكر رمزًا واحدًا فقط"
    ],
    "correct": 2,
    "explanation": "منبع بدون ذاكرة (ذاكرة صفرية) هو منبع تكون أحداثه مستقلة، أي أن احتمال إطلاق رمز لا يعتمد على الرموز السابقة."
  },
  {
    "question": "في اللغة الإنجليزية، إذا كان الحرف السابق هو 't'، فكيف يكون احتمال ظهور الحرف 'h'؟",
    "options": [
      "منخفض",
      "مستحيل",
      "مرتفع",
      "ثابت دائمًا"
    ],
    "correct": 2,
    "explanation": "في اللغة الإنجليزية، يظهر الحرف 'h' بكثرة بعد الحرف 't' في كلمات مثل 'the' و 'this'، لذا يكون احتمال ظهوره مرتفعًا."
  },
  {
    "question": "كيف ترتبط كمية المعلومات I باحتمال الحدث؟",
    "options": [
      "تزداد كلما انخفض احتمال الحدث",
      "تزداد كلما ارتفع احتمال الحدث",
      "لا علاقة بينهما",
      "تكون ثابتة دائمًا"
    ],
    "correct": 0,
    "explanation": "كمية المعلومات تزداد عندما يكون احتمال الحدث منخفضًا (غير متوقع)، وتقل عندما يكون الاحتمال مرتفعًا (متوقعًا)."
  },
  {
    "question": "ما هي الصيغة التقريبية الأولية لكمية المعلومات I؟",
    "options": [
      "I ≈ log p(s)",
      "I ≈ p(s)",
      "I ≈ 1 / p(s)",
      "I ≈ p(s)²"
    ],
    "correct": 2,
    "explanation": "كمية المعلومات تقريبًا تتناسب عكسيًا مع احتمال الحدث: I ≈ 1 / p(s)."
  },
  {
    "question": "كيف نحسب الإنتروبيا H(s) لمنبع بدون ذاكرة؟",
    "options": [
      "H(s) = Σ p(s_i) * log(p(s_i))",
      "H(s) = Σ p(s_i) * log(1 / p(s_i))",
      "H(s) = Σ 1 / p(s_i)",
      "H(s) = Σ p(s_i)²"
    ],
    "correct": 1,
    "explanation": "الإنتروبيا تُحسب على أنها مجموع حاصل ضرب احتمال كل رمز في كمية المعلومات التي يحملها (لوغاريتم مقلوب الاحتمال)."
  },
  {
    "question": "متى تكون الإنتروبيا عظمى (القيمة القصوى)؟",
    "options": [
      "عندما يكون أحد الاحتمالات = 1",
      "عندما تكون الاحتمالات عشوائية",
      "عندما تكون الاحتمالات متساوية",
      "عندما يكون عدد الرموز فرديًا"
    ],
    "correct": 2,
    "explanation": "تكون الإنتروبيا عظمى عندما تكون احتمالات جميع الرموز متساوية، لأن عدم اليقين يكون في أعلى درجاته."
  },
  {
    "question": "إذا كان منبع المعلومات يحتوي على 3 رموز (q=3) وكانت الاحتمالات متساوية، فما قيمة الإنتروبيا العظمى؟",
    "options": [
      "log 2",
      "log 1",
      "log 4",
      "log 3"
    ],
    "correct": 3,
    "explanation": "الإنتروبيا العظمى لمنبع بدون ذاكرة تُحسب كـ log q، حيث q هو عدد الرموز. هنا q=3، لذا H_max = log 3."
  },

 

  {
    "question": "في المسألة (2)، إذا كان p(0) = p(1) = 1/2، فما قيمة الإنتروبيا؟",
    "options": [
      "0.5 بت",
      "0 بت",
      "2 بت",
      "1 بت"
    ],
    "correct": 3,
    "explanation": "عندما تكون الاحتمالات متساوية، تكون الإنتروبيا مساوية للإنتروبيا العظمى، وهي log 2 = 1 بت."
  },
  {
    "question": "في المسألة (3)، إذا كان p(s1)=0 و p(s2)=1، فما قيمة الإنتروبيا؟",
    "options": [
      "1 بت",
      "0.5 بت",
      "0 بت",
      "2 بت"
    ],
    "correct": 2,
    "explanation": "عندما يكون احتمال رمز واحد = 1 وباقي الرموز = 0، تكون الإنتروبيا = 0، لأن النتيجة مؤكدة ولا يوجد عدم يقين."
  },
  {
    "question": "ما هي العلاقة بين الأحداث المستقلة في منبع بدون ذاكرة؟",
    "options": [
      "يجمع الاحتمالات",
      "يضرب الاحتمالات",
      "ينقص الاحتمالات",
      "يقسم الاحتمالات"
    ],
    "correct": 1,
    "explanation": "في الأحداث المستقلة، تكون العلاقة بين الاحتمالات هي الجداء (الضرب)، وليس الجمع."
  },
  {
    "question": "كيف نحسب اللوغاريتم الثنائي للعدد x باستخدام اللوغاريتم العشري؟",
    "options": [
      "log₂ x = log₁₀ x / log₁₀ 2",
      "log₂ x = log₁₀ x * log₁₀ 2",
      "log₂ x = log₁₀ 2 / log₁₀ x",
      "log₂ x = log₁₀ x + log₁₀ 2"
    ],
    "correct": 0,
    "explanation": "لتحويل اللوغاريتم العشري إلى ثنائي: log₂ x = log₁₀ x / log₁₀ 2"
  },
  {
    "question": "ما معنى الذاكرة الصفرية في منبع المعلومات؟",
    "options": [
      "المنبع يتذكر رمزًا واحدًا فقط",
      "المنبع يتذكر جميع الرموز السابقة",
      "أحداث المنبع مستقلة ولا ترتبط بالسابق",
      "المنبع لا يطلق رموزًا أبدًا"
    ],
    "correct": 2,
    "explanation": "الذاكرة الصفرية تعني أن الأحداث مستقلة وأن إطلاق رمز لا يعتمد على الرموز السابقة."
  },
  {
    "question": "ماذا يحدث لكمية المعلومات عندما يكون الحدث مؤكدًا (احتماله = 1)؟",
    "options": [
      "تكون قصوى",
      "تكون متوسطة",
      "تكون = 0",
      "تكون سالبة"
    ],
    "correct": 2,
    "explanation": "عندما يكون الحدث مؤكدًا (احتماله = 1)، تكون كمية المعلومات = 0، لأن الحدث متوقع ولا يحمل معلومات جديدة."
  },
  {
    "question": "ما هي وحدات قياس الإنتروبيا عندما نستخدم اللوغاريتم الثنائي؟",
    "options": [
      "بت (bit)",
      "نات (nat)",
      "هات (hart)",
      "جميع ما سبق"
    ],
    "correct": 0,
    "explanation": "عند استخدام اللوغاريتم الثنائي (أساس 2)، تقاس الإنتروبيا بالبت (bit)."
  },
  {
    "question": "ما هي قيمة log(1) بأي أساس؟",
    "options": [
      "1",
      "0",
      "-1",
      "يعتمد على الأساس"
    ],
    "correct": 1,
    "explanation": "لوغاريتم العدد 1 بأي أساس يساوي 0، لأن أي عدد مرفوع للقوة 0 يساوي 1."
  },
  {
    "question": "ما هي الخاصية الرياضية: log(x/y)؟",
    "options": [
      "log x + log y",
      "log x - log y",
      "y * log x",
      "x * log y"
    ],
    "correct": 1,
    "explanation": "إحدى خواص اللوغاريتم هي: log(x/y) = log x - log y."
  },
  {
    "question": "إذا كان منبع المعلومات يطلق رموزًا (0,1) وكان p(0)=0.7 و p(1)=0.3، أين تكون الإنتروبيا؟",
    "options": [
      "أقل من 1 بت",
      "تساوي 1 بت",
      "أكبر من 1 بت",
      "تساوي 0 بت"
    ],
    "correct": 0,
    "explanation": "عندما تكون الاحتمالات غير متساوية، تكون الإنتروبيا أقل من الإنتروبيا العظمى (log 2 = 1 بت)."
  },
  {
    "question": "ما معنى 'منبع من المرتبة 1'؟",
    "options": [
      "يتذكر البت الذي قبله",
      "يتذكر بتين سابقين",
      "لا يتذكر أي شيء",
      "يتذكر جميع الرموز السابقة"
    ],
    "correct": 0,
    "explanation": "منبع من المرتبة 1 هو منبع يتذكر الرمز (أو البت) الواحد السابق فقط."
  },
  {
    "question": "ما معنى 'منبع من المرتبة 2'؟",
    "options": [
      "يتذكر البت الذي قبله",
      "يتذكر بتين سابقين",
      "لا يتذكر أي شيء",
      "يتذكر ثلاثة رموز سابقة"
    ],
    "correct": 1,
    "explanation": "منبع من المرتبة 2 هو منبع يتذكر الرمزين (أو البتين) السابقين."
  },
  {
    "question": "ما الفرق الرئيسي بين منبع بذاكرة ومنبع بدون ذاكرة؟",
    "options": [
      "المنبع بذاكرة يعتمد على الرموز السابقة",
      "المنبع بدون ذاكرة يعتمد على الرموز السابقة",
      "لا فرق بينهما",
      "المنبع بذاكرة أسرع"
    ],
    "correct": 0,
    "explanation": "الفرق الرئيسي هو أن المنبع بذاكرة يعتمد احتمالات الرموز على الرموز السابقة، بينما المنبع بدون ذاكرة تكون أحداثه مستقلة."
  },
  {
    "question": "كيف يمكن أن نعتبر الاحتمال 'متوقع'؟",
    "options": [
      "عندما يكون مرتفعًا",
      "عندما يكون منخفضًا",
      "عندما يكون = 0",
      "عندما يكون = 0.5"
    ],
    "correct": 0,
    "explanation": "الاحتمال يُعتبر متوقعًا عندما يكون مرتفعًا، وغير متوقع عندما يكون منخفضًا."
  },
 
  
  {
    "question": "لماذا تُستخدم اللوغاريتمات في حساب الإنتروبيا؟",
    "options": [
      "لتحويل الضرب إلى جمع",
      "لجعل الحسابات أصعب",
      "لأنها أجمل رياضياً",
      "لأنها أقدم تقنية"
    ],
    "correct": 0,
    "explanation": "تُستخدم اللوغاريتمات لأنها تحول عملية الضرب (لاحتمالات الأحداث المستقلة) إلى جمع، مما يسهل الحسابات الرياضية."
  },
 
  {
    "question": "ما الذي يمثله الرمز H(s)؟",
    "options": [
      "الإنتروبيا",
      "الاحتمال",
      "كمية المعلومات",
      "الذاكرة"
    ],
    "correct": 0,
    "explanation": "H(s) هو رمز الإنتروبيا لمنبع المعلومات s."
  },
  {
    "question": "ما الذي يمثله الرمز I؟",
    "options": [
      "الإنتروبيا",
      "كمية المعلومات",
      "الاحتمال",
      "الذاكرة"
    ],
    "correct": 1,
    "explanation": "I هو رمز كمية المعلومات التي يحملها حدث معين."
  },
  {
    "question": "إذا زاد عدد رموز المنبع (q)، ماذا يحدث للإنتروبيا العظمى؟",
    "options": [
      "تزداد",
      "تقل",
      "تثبت",
      "تصبح سالبة"
    ],
    "correct": 0,
    "explanation": "الإنتروبيا العظمى تزداد بزيادة عدد الرموز q، لأن عدم اليقين يزداد مع زيادة الخيارات الممكنة."
  }

  ,
  {
    "question": "منبع معلومات بذاكرة صفرية أبجديته {A, B, C}، احتمالات الإطلاق هي: p(A) = 1/3، p(B) = 1/6. احسب الانتروبيا لهذا المنبع.",
    "options": [
      "1.46 بت",
      "1.58 بت",
      "1 بت",
      "0.5 بت"
    ],
    "correct": 0,
    "explanation": "p(C) = 1 - 1/3 - 1/6 = 1/2. الانتروبيا = (1/3)log₂(3) + (1/6)log₂(6) + (1/2)log₂(2) = 1.46 بت تقريباً."
  },
  {
    "question": "منبع معلومات بذاكرة صفرية أبجديته {0, 1}، مع احتمالات إطلاق: p(0) = 1/2، p(1) = 1/2. احسب الانتروبيا.",
    "options": [
      "0.5 بت",
      "0 بت",
      "2 بت",
      "1 بت"
    ],
    "correct": 3,
    "explanation": "الانتروبيا = (1/2)log₂(2) + (1/2)log₂(2) = 1 بت. هذه هي الانتروبيا العظمى للمنبع الثنائي."
  },
  {
    "question": "منبع معلومات بذاكرة صفرية أبجديته {A, B, C, D}، احتمالات الإطلاق: p(A) = 1/2، p(B) = 1/4، p(C) = 1/8. احسب احتمال D ثم الانتروبيا.",
    "options": [
      "p(D) = 1/8، H = 1.75 بت",
      "p(D) = 1/4، H = 1.5 بت",
      "p(D) = 1/8، H = 1.5 بت",
      "p(D) = 1/4، H = 1.75 بت"
    ],
    "correct": 0,
    "explanation": "p(D) = 1 - (1/2 + 1/4 + 1/8) = 1/8. الانتروبيا = (1/2)log₂2 + (1/4)log₂4 + (1/8)log₂8 + (1/8)log₂8 = 1.75 بت."
  },
  {
    "question": "منبع معلومات بذاكرة صفرية يطلق ثلاثة رموز {x, y, z}، إذا كانت الانتروبيا العظمى له = 1.585 بت، فما قيم الاحتمالات عند الانتروبيا العظمى؟",
    "options": [
      "كل احتمال = 1/3",
      "كل احتمال = 1/4",
      "كل احتمال = 1/2",
      "كل احتمال = 1/5"
    ],
    "correct": 0,
    "explanation": "الانتروبيا العظمى = log₂(3) ≈ 1.585 بت، وذلك عندما تكون جميع الاحتمالات متساوية وتساوي 1/3."
  },
  {
    "question": "منبع معلومات ثنائي {0, 1}، إذا كان p(0) = 0.8، p(1) = 0.2، احسب الانتروبيا.",
    "options": [
      "0.72 بت",
      "1 بت",
      "0.5 بت",
      "0.32 بت"
    ],
    "correct": 0,
    "explanation": "H = 0.8·log₂(1/0.8) + 0.2·log₂(1/0.2) = 0.8·0.3219 + 0.2·2.3219 = 0.2575 + 0.4644 = 0.7219 بت."
  },
  {
    "question": "منبع معلومات بذاكرة صفرية أبجديته {S1, S2, S3}، إذا كان p(S1) = 0.5، p(S2) = 0.3، احسب p(S3) والانتروبيا.",
    "options": [
      "p(S3) = 0.2، H = 1.49 بت",
      "p(S3) = 0.2، H = 1 بت",
      "p(S3) = 0.3، H = 1.58 بت",
      "p(S3) = 0.5، H = 1.46 بت"
    ],
    "correct": 0,
    "explanation": "p(S3) = 1 - 0.5 - 0.3 = 0.2. H = 0.5·log₂2 + 0.3·log₂(1/0.3) + 0.2·log₂(1/0.2) ≈ 1.49 بت."
  },
  {
    "question": "ما هي الانتروبيا العظمى لمنبع معلومات يحتوي على 8 رموز متساوية الاحتمال؟",
    "options": [
      "3 بت",
      "2 بت",
      "1 بت",
      "4 بت"
    ],
    "correct": 0,
    "explanation": "الانتروبيا العظمى = log₂(8) = 3 بت، حيث 8 = 2³."
  },
  {
    "question": "منبع معلومات بذاكرة صفرية، إذا كانت الانتروبيا = 0 بت، فماذا يعني ذلك؟",
    "options": [
      "جميع الاحتمالات متساوية",
      "أحد الاحتمالات = 1 والباقي = 0",
      "المنبع لا يطلق رموزاً",
      "الانتروبيا لا يمكن أن تكون صفراً"
    ],
    "correct": 1,
    "explanation": "الانتروبيا = 0 تعني عدم وجود عدم يقين، أي أن أحد الرموز مؤكد الظهور (احتماله = 1) والباقي مستحيل (احتماله = 0)."
  },
  {
    "question": "منبع معلومات يطلق رمزين {A, B}، إذا كانت الانتروبيا = 1 بت، فما هي قيم الاحتمالات؟",
    "options": [
      "p(A) = 0.8، p(B) = 0.2",
      "p(A) = 0.5، p(B) = 0.5",
      "p(A) = 1، p(B) = 0",
      "p(A) = 0.3، p(B) = 0.7"
    ],
    "correct": 1,
    "explanation": "الانتروبيا = 1 بت هي الانتروبيا العظمى للمنبع الثنائي، وتتحقق عندما يكون الاحتمالان متساويين = 0.5 لكل منهما."
  },
  {
    "question": "احسب كمية المعلومات لرمز احتمال ظهوره 1/16.",
    "options": [
      "4 بت",
      "2 بت",
      "8 بت",
      "16 بت"
    ],
    "correct": 0,
    "explanation": "كمية المعلومات I = log₂(1/p) = log₂(16) = 4 بت، لأن 16 = 2⁴."
  },
  {
    "question": "منبع معلومات رباعي {a, b, c, d} باحتمالات متساوية، ما كمية المعلومات التي يحملها الرمز a؟",
    "options": [
      "1 بت",
      "2 بت",
      "3 بت",
      "4 بت"
    ],
    "correct": 1,
    "explanation": "p(a) = 1/4، I = log₂(4) = 2 بت."
  },
  {
    "question": "إذا كان احتمال حدث ما = 1/32، فما هي كمية المعلومات بالبت؟",
    "options": [
      "5 بت",
      "4 بت",
      "6 بت",
      "3 بت"
    ],
    "correct": 0,
    "explanation": "I = log₂(32) = 5 بت، لأن 32 = 2⁵."
  },
  {
    "question": "منبع معلومات يحتوي على 16 رمزاً متساوي الاحتمال، ما هي الانتروبيا العظمى؟",
    "options": [
      "3 بت",
      "2 بت",
      "4 بت",
      "5 بت"
    ],
    "correct": 2,
    "explanation": "H_max = log₂(16) = 4 بت، لأن 16 = 2⁴."
  },
  {
    "question": "ما هي قيمة log₂(1)؟",
    "options": [
      "1",
      "0",
      "-1",
      "غير معرف"
    ],
    "correct": 1,
    "explanation": "لوغاريتم 1 بأي أساس = 0، لأن أي عدد مرفوع للأس 0 = 1."
  },
  {
    "question": "ما هي قيمة log₂(0.5)؟",
    "options": [
      "1",
      "-1",
      "0.5",
      "-0.5"
    ],
    "correct": 1,
    "explanation": "log₂(0.5) = log₂(1/2) = -1، لأن 2⁻¹ = 0.5."
  },
  {
    "question": "إذا كانت كمية المعلومات لرمز ما = 3 بت، فما احتمال ظهور هذا الرمز؟",
    "options": [
      "1/8",
      "1/4",
      "1/2",
      "1/16"
    ],
    "correct": 0,
    "explanation": "I = 3 بت = log₂(1/p) ⇒ 1/p = 2³ = 8 ⇒ p = 1/8."
  },
  {
    "question": "منبع معلومات ثلاثي الرموز، إذا كانت الانتروبيا = 1.5 بت، هل يمكن أن تكون هذه الانتروبيا عظمى؟",
    "options": [
      "نعم، لأن log₂3 ≈ 1.585",
      "لا، لأن الانتروبيا العظمى = 1.585",
      "نعم، لأن 1.5 قريبة من 1.585",
      "لا، لأن الانتروبيا العظمى للمنبع الثلاثي = 2"
    ],
    "correct": 1,
    "explanation": "الانتروبيا العظمى للمنبع الثلاثي = log₂3 ≈ 1.585 بت. قيمة 1.5 أقل من القيمة العظمى، لذا ليست عظمى."
  },
  {
    "question": "ما هي العلاقة بين كمية المعلومات I والاحتمال p؟",
    "options": [
      "تناسب عكسي",
      "تناسب طردي",
      "لا علاقة",
      "علاقة تربيعية"
    ],
    "correct": 0,
    "explanation": "كمية المعلومات تتناسب عكسياً مع الاحتمال: كلما قل الاحتمال زادت كمية المعلومات والعكس صحيح."
  },
  {
    "question": "ما هي الصيغة الصحيحة للانتروبيا H لمنبع بدون ذاكرة؟",
    "options": [
      "H = Σ pᵢ",
      "H = Σ pᵢ·log₂(pᵢ)",
      "H = Σ pᵢ·log₂(1/pᵢ)",
      "H = Σ (1/pᵢ)"
    ],
    "correct": 2,
    "explanation": "الصيغة الصحيحة للانتروبيا هي: H = Σ pᵢ·log₂(1/pᵢ) = -Σ pᵢ·log₂(pᵢ)."
  },
  {
    "question": "إذا تضاعف عدد رموز المنبع (من 4 إلى 8) مع بقاء الاحتمالات متساوية، كيف تتغير الانتروبيا العظمى؟",
    "options": [
      "تزداد بمقدار 1 بت",
      "تقل بمقدار 1 بت",
      "تتضاعف",
      "تبقى كما هي"
    ],
    "correct": 0,
    "explanation": "H_max₁ = log₂4 = 2 بت، H_max₂ = log₂8 = 3 بت. الفرق = 1 بت زيادة."
  }

],
lec2:[
  {
    "question": "ما هو الهدف من إنشاء 'امتداد المنبع' في نظرية المعلومات؟",
    "options": [
      "تقليل الانتروبيا",
      "زيادة الانتروبيا",
      "تغيير نوع الرموز",
      "تبسيط الحسابات"
    ],
    "correct": 1,
    "explanation": "الهدف من إنشاء امتداد المنبع هو زيادة انتروبيته (H(δ)) لتكون أكبر من انتروبية المنبع الأصلي (H(s))."
  },
  {
    "question": "كيف يُرمز لمنبع الامتداد من المرتبة n؟",
    "options": [
      "S",
      "δ",
      "H",
      "q"
    ],
    "correct": 1,
    "explanation": "يُرمز لمنبع الامتداد بالرمز δ، بينما يُرمز للمنبع الأصلي بالرمز S."
  },
  {
    "question": "إذا كان المنبع الأصلي يحتوي على q رمز، فما عدد رموز منبع الامتداد من المرتبة n؟",
    "options": [
      "q",
      "n",
      "q + n",
      "q^n"
    ],
    "correct": 3,
    "explanation": "عدد رموز منبع الامتداد من المرتبة n يساوي q^n، حيث q عدد رموز المنبع الأصلي."
  },
  {
    "question": "ما هي العلاقة بين انتروبية منبع الامتداد H(δ) وانتروبية المنبع الأصلي H(s)؟",
    "options": [
      "H(δ) = H(s)",
      "H(δ) = n · H(s)",
      "H(δ) = H(s)/n",
      "H(δ) = H(s)^n"
    ],
    "correct": 1,
    "explanation": "انتروبية منبع الامتداد من المرتبة n تُحسب كـ H(δ) = n · H(s)، حيث H(s) انتروبية المنبع الأصلي."
  },
  {
    "question": "كلما زادت مرتبة الامتداد n، ماذا يحدث لانتروبية منبع الامتداد؟",
    "options": [
      "تقل",
      "تزداد",
      "تثبت",
      "تتغير عشوائياً"
    ],
    "correct": 1,
    "explanation": "كلما زادت مرتبة الامتداد n، تزداد انتروبية منبع الامتداد H(δ) بشكل متناسب مع n."
  },
  {
    "question": "ما هي الصيغة الصحيحة لحساب انتروبية منبع الامتداد δ؟",
    "options": [
      "H(δ) = Σ P(δ_i) · log₂ P(δ_i)",
      "H(δ) = Σ P(δ_i) · log₂ (1/P(δ_i))",
      "H(δ) = Σ (1/P(δ_i)) · log₂ P(δ_i)",
      "H(δ) = Σ P(δ_i) · log₁₀ (1/P(δ_i))"
    ],
    "correct": 1,
    "explanation": "الصيغة الصحيحة هي: H(δ) = Σ P(δ_i) · log₂ (1/P(δ_i))، حيث P(δ_i) هو احتمال الرمز i في منبع الامتداد."
  },
  {
    "question": "منبع معلومات أبجديته {0,1}، احتمالات الإطلاق: P(0)=1/4, P(1)=3/4. ما هي انتروبية المنبع الأصلي H(s)؟",
    "options": [
      "0.5 بت",
      "0.81 بت",
      "1 بت",
      "1.5 بت"
    ],
    "correct": 1,
    "explanation": "H(s) = (1/4)log₂(4) + (3/4)log₂(4/3) = 0.5 + 0.311 = 0.811 بت ≈ 0.81 بت."
  },
  {
    "question": "نفس المنبع السابق {0,1} مع P(0)=1/4, P(1)=3/4. ما هو احتمال P(00) في امتداد المرتبة 2؟",
    "options": [
      "1/4",
      "1/8",
      "1/16",
      "1/32"
    ],
    "correct": 2,
    "explanation": "P(00) = P(0) × P(0) = (1/4) × (1/4) = 1/16."
  },
  {
    "question": "ما هو احتمال P(11) لنفس المنبع في امتداد المرتبة 2؟",
    "options": [
      "3/16",
      "9/16",
      "1/16",
      "3/4"
    ],
    "correct": 1,
    "explanation": "P(11) = P(1) × P(1) = (3/4) × (3/4) = 9/16."
  },
  {
    "question": "ما هو عدد رموز امتداد المرتبة 2 لنفس المنبع الثنائي؟",
    "options": [
      "2",
      "4",
      "8",
      "16"
    ],
    "correct": 1,
    "explanation": "عدد الرموز = q^n = 2² = 4 رموز."
  },
  {
    "question": "ما هي انتروبية امتداد المرتبة 2 لنفس المنبع باستخدام العلاقة H(δ) = n·H(s)؟",
    "options": [
      "0.81 بت",
      "1.62 بت",
      "2.43 بت",
      "3.24 بت"
    ],
    "correct": 1,
    "explanation": "H(δ) = 2 × 0.81 = 1.62 بت."
  },
  {
    "question": "منبع ثنائي {0,1}، إذا كان P(0000)=1/81 في امتداد المرتبة 4، فما هو P(0)؟",
    "options": [
      "1/2",
      "1/3",
      "1/4",
      "1/9"
    ],
    "correct": 1,
    "explanation": "P(0000) = [P(0)]⁴ = 1/81 ⇒ P(0) = ⁴√(1/81) = 1/3."
  },
  {
    "question": "ما هو P(1) لنفس المنبع السابق؟",
    "options": [
      "1/3",
      "2/3",
      "3/4",
      "4/5"
    ],
    "correct": 1,
    "explanation": "P(1) = 1 - P(0) = 1 - 1/3 = 2/3."
  },
  {
    "question": "ما هي انتروبية المنبع الأصلي السابق باستخدام P(0)=1/3, P(1)=2/3؟",
    "options": [
      "0.5 بت",
      "0.81 بت",
      "0.92 بت",
      "1 بت"
    ],
    "correct": 2,
    "explanation": "H(s) = (1/3)log₂3 + (2/3)log₂(3/2) ≈ 0.528 + 0.390 = 0.918 بت ≈ 0.92 بت."
  },
  {
    "question": "ما هي انتروبية امتداد المرتبة 4 لنفس المنبع؟",
    "options": [
      "0.92 بت",
      "1.84 بت",
      "3.68 بت",
      "5.52 بت"
    ],
    "correct": 2,
    "explanation": "H(δ) = n × H(s) = 4 × 0.92 = 3.68 بت."
  },
  {
    "question": "منبع ثلاثي الرموز {s1, s2, s3} مع P(s1)=1/2, P(s2)=1/6, P(s3)=1/3. ما عدد رموز امتداد المرتبة 2؟",
    "options": [
      "3",
      "6",
      "9",
      "12"
    ],
    "correct": 2,
    "explanation": "عدد الرموز = q^n = 3² = 9 رموز."
  },
  {
    "question": "ما هو احتمال P(s1,s1) في امتداد المرتبة 2 لنفس المنبع الثلاثي؟",
    "options": [
      "1/2",
      "1/4",
      "1/6",
      "1/3"
    ],
    "correct": 1,
    "explanation": "P(s1,s1) = P(s1) × P(s1) = (1/2) × (1/2) = 1/4."
  },
  {
    "question": "ما هي انتروبية المنبع الأصلي الثلاثي؟",
    "options": [
      "1 بت",
      "1.46 بت",
      "1.58 بت",
      "2 بت"
    ],
    "correct": 1,
    "explanation": "H(s) = (1/2)log₂2 + (1/6)log₂6 + (1/3)log₂3 = 0.5 + 0.431 + 0.528 = 1.459 بت ≈ 1.46 بت."
  },
  {
    "question": "ما هي انتروبية امتداد المرتبة 2 للمنبع الثلاثي؟",
    "options": [
      "1.46 بت",
      "2.92 بت",
      "3.68 بت",
      "4.38 بت"
    ],
    "correct": 1,
    "explanation": "H(δ) = n × H(s) = 2 × 1.46 = 2.92 بت."
  },
  {
    "question": "ما هي قيمة H(s) عندما تكون P(0)=1/4 و P(1)=3/4؟ (بالتقريب)",
    "options": [
      "0.5 بت",
      "0.81 بت",
      "1 بت",
      "1.5 بت"
    ],
    "correct": 1,
    "explanation": "H(s) = (1/4)log₂4 + (3/4)log₂(4/3) = 0.5 + 0.311 = 0.811 بت ≈ 0.81 بت."
  },
  {
    "question": "كيف نحسب احتمال أي رمز في منبع الامتداد للمنبع بدون ذاكرة؟",
    "options": [
      "بجمع احتمالات الرموز الفردية",
      "بضرب احتمالات الرموز الفردية",
      "بمتوسط احتمالات الرموز",
      "باللوغاريتم لمجموع الاحتمالات"
    ],
    "correct": 1,
    "explanation": "في المنبع بدون ذاكرة، يكون احتمال أي رمز في الامتداد مساوياً لحاصل ضرب احتمالات الرموز الفردية المكونة له."
  },
  {
    "question": "إذا كان H(s)=0.5 بت و n=3، فما هي H(δ)؟",
    "options": [
      "0.5 بت",
      "1 بت",
      "1.5 بت",
      "2 بت"
    ],
    "correct": 2,
    "explanation": "H(δ) = n × H(s) = 3 × 0.5 = 1.5 بت."
  },
  {
    "question": "ما معنى أن المنبع الأصلي له 'ذاكرة صفرية'؟",
    "options": [
      "يتذكر رمزاً واحداً سابقاً",
      "أحداثه مستقلة",
      "يتذكر جميع الرموز السابقة",
      "ليس له رموز"
    ],
    "correct": 1,
    "explanation": "المنبع بذاكرة صفرية يعني أن أحداثه مستقلة ولا يعتمد إطلاق رمز على الرموز السابقة."
  },
  {
    "question": "ما الفرق بين H(s) و H(δ)؟",
    "options": [
      "H(δ) هي انتروبية المنبع الأصلي",
      "H(δ) هي انتروبية منبع الامتداد",
      "لا فرق بينهما",
      "H(s) أكبر من H(δ) دائماً"
    ],
    "correct": 1,
    "explanation": "H(s) هي انتروبية المنبع الأصلي، بينما H(δ) هي انتروبية منبع الامتداد."
  },
  {
    "question": "إذا كان امتداد المرتبة 3 لمنبع ثنائي، فما عدد رموزه؟",
    "options": [
      "3",
      "6",
      "8",
      "9"
    ],
    "correct": 2,
    "explanation": "عدد الرموز = q^n = 2³ = 8 رموز."
  },
  {
    "question": "ما هي قيمة n في العلاقة H(δ) = n·H(s)؟",
    "options": [
      "عدد رموز المنبع الأصلي",
      "مرتبة الامتداد",
      "انتروبية المنبع الأصلي",
      "احتمال الرمز"
    ],
    "correct": 1,
    "explanation": "n في العلاقة H(δ) = n·H(s) تمثل مرتبة الامتداد."
  },
  {
    "question": "كيف تتغير انتروبية الامتداد عندما تزيد n من 2 إلى 3؟",
    "options": [
      "تتضاعف",
      "تزيد بنسبة 50%",
      "تزيد بنسبة 33%",
      "تقل"
    ],
    "correct": 1,
    "explanation": "عند زيادة n من 2 إلى 3 (زيادة 50%)، تزيد H(δ) بنسبة 50% لأنها تتناسب طردياً مع n."
  },
  {
    "question": "ما هي وحدة قياس H(δ)؟",
    "options": [
      "بت",
      "بايت",
      "هرتز",
      "ثانية"
    ],
    "correct": 0,
    "explanation": "وحدة قياس H(δ) هي البت (bit) مثل H(s)، لأنها تعتمد على اللوغاريتم الثنائي."
  },
  {
    "question": "إذا كان P(0)=0.2 و P(1)=0.8، ما هي H(s) التقريبية؟",
    "options": [
      "0.5 بت",
      "0.72 بت",
      "1 بت",
      "1.5 بت"
    ],
    "correct": 1,
    "explanation": "H(s) = 0.2log₂5 + 0.8log₂(1.25) ≈ 0.2×2.322 + 0.8×0.322 = 0.464 + 0.258 = 0.722 بت ≈ 0.72 بت."
  },
  {
    "question": "ما هو امتداد المنبع من المرتبة n=1؟",
    "options": [
      "المنبع الأصلي نفسه",
      "منبع مختلف تماماً",
      "منبع برموز مضاعفة",
      "لا يوجد امتداد للمرتبة 1"
    ],
    "correct": 0,
    "explanation": "عندما تكون n=1، يكون امتداد المنبع هو المنبع الأصلي نفسه، حيث H(δ) = 1·H(s) = H(s)."
  },
  {
    "question": "ما هي قيمة log₂(4/3) التقريبية؟",
    "options": [
      "0.415",
      "0.585",
      "0.322",
      "0.737"
    ],
    "correct": 0,
    "explanation": "log₂(4/3) = log₂4 - log₂3 = 2 - 1.585 = 0.415 تقريباً."
  },
  {
    "question": "لماذا يستخدم امتداد المنبع في نظرية المعلومات؟",
    "options": [
      "لتقليل معدل نقل البيانات",
      "لزيادة كفاءة الترميز",
      "لزيادة الانتروبيا",
      "لتقليل عدد الرموز"
    ],
    "correct": 2,
    "explanation": "يستخدم امتداد المنبع لزيادة الانتروبيا، مما يسمع بتحسين كفاءة الترميز ونقل المعلومات."
  },
  {
    "question": "ما هو الرمز الذي يمثل مرتبة الامتداد؟",
    "options": [
      "q",
      "n",
      "δ",
      "H"
    ],
    "correct": 1,
    "explanation": "مرتبة الامتداد يرمز لها بـ n."
  }
]
,lec3:[
  {
    "question": "ما هو تعريف 'منبع ماركوف'؟",
    "options": [
      "منبع بدون ذاكرة",
      "منبع ذو ذاكرة محدودة حيث يعتمد احتمال الرمز الحالي على حالات سابقة محددة",
      "منبع عشوائي بحت",
      "منبع ثابت الاحتمالات"
    ],
    "correct": 1,
    "explanation": "منبع ماركوف هو منبع ذو ذاكرة محدودة (من مرتبة n) حيث يعتمد احتمال إطلاق الرمز الحالي على آخر n رمز تم إطلاقهم."
  },
  {
    "question": "ما هي 'الحالة المستقرة' في منبع ماركوف؟",
    "options": [
      "الحالة التي لا تتغير أبداً",
      "احتمالات ثابتة لإطلاق الرموز بعد فترة طويلة من الزمن",
      "الحالة الأولية للمنبع",
      "حالة يتوقف فيها المنبع عن العمل"
    ],
    "correct": 1,
    "explanation": "الحالة المستقرة هي الحالة التي تستقر فيها احتمالات إطلاق الرموز وتصبح ثابتة بعد فترة طويلة من تشغيل المنبع، بغض النظر عن الحالة الأولية."
  },
  {
    "question": "كم عدد الحالات في منبع ماركوف من المرتبة الثانية بأبجدية {0,1}؟",
    "options": [
      "2",
      "4",
      "8",
      "16"
    ],
    "correct": 1,
    "explanation": "عدد الحالات = q^n = 2^2 = 4، حيث q=2 (عدد الرموز) و n=2 (مرتبة المنبع)."
  },
  {
    "question": "ما هو الشرط الذي يجب أن يحققه منبع ماركوف ليكون 'مستقراً'؟",
    "options": [
      "أن يكون لديه حالة واحدة فقط",
      "أن تكون جميع الاحتمالات الشرطية متساوية",
      "أن تمر الأسهم على جميع الحالات مرة واحدة على الأقل في مخطط الحالة",
      "أن يكون عدد الحالات فردياً"
    ],
    "correct": 2,
    "explanation": "ليكون المنبع مستقراً، يجب أن يكون من الممكن الوصول إلى جميع الحالات من أي حالة أخرى، أي أن تمر الأسهم على جميع الحالات مرة واحدة على الأقل."
  },
  {
    "question": "ما هو القانون الرياضي المستخدم لحساب احتمالات الحالة المستقرة في منبع ماركوف؟",
    "options": [
      "(Q - I) · π = 0",
      "H(s) = Σ p(s_i)log(1/p(s_i))",
      "P(A∩B) = P(A)·P(B)",
      "H(δ) = n·H(s)"
    ],
    "correct": 0,
    "explanation": "يتم حساب احتمالات الحالة المستقرة π باستخدام المعادلة: (Q - I)·π = 0، حيث Q منقول مصفوفة الانتقال P، وI مصفوفة الوحدة."
  },
  {
    "question": "في منبع ماركوف من المرتبة الثانية بأبجدية {0,1}، إذا كانت P(0/00)=0.6 وP(1/11)=0.6 وP(0/10)=P(0/01)=0.5، ما هي احتمالات الحالة المستقرة π₁, π₂, π₃, π₄ للحالات 00,01,11,10 على التوالي؟",
    "options": [
      "π₁=π₃=5/18, π₂=π₄=2/9",
      "π₁=π₂=π₃=π₄=1/4",
      "π₁=π₄=1/2, π₂=π₃=0",
      "π₁=1/3, π₂=1/3, π₃=1/6, π₄=1/6"
    ],
    "correct": 0,
    "explanation": "بعد حل نظام المعادلات (Q-I)·π=0 مع π₁+π₂+π₃+π₄=1، نحصل على: π₁=π₃=5/18 ≈ 0.278، π₂=π₄=2/9 ≈ 0.222."
  },
  {
    "question": "ما هي مصفوفة الانتقال P لمنبع ماركوف من المرتبة الأولى بأبجدية {A,B,C} حيث: P(A/A)=P(A/B)=P(A/C)=3/5، P(B/A)=P(C/B)=P(B/C)=2/5؟",
    "options": [
      "P = [[3/5,2/5,0],[3/5,0,2/5],[3/5,2/5,0]]",
      "P = [[3/5,3/5,3/5],[2/5,0,2/5],[0,2/5,0]]",
      "P = [[1/3,1/3,1/3],[1/3,1/3,1/3],[1/3,1/3,1/3]]",
      "P = [[1,0,0],[0,1,0],[0,0,1]]"
    ],
    "correct": 0,
    "explanation": "مصفوفة الانتقال P حيث الصف i والعمود j يمثل P(الحالة j/الحالة i). بناءً على البيانات: الصف1: [P(A/A)=3/5, P(B/A)=2/5, P(C/A)=0]، الصف2: [P(A/B)=3/5, P(B/B)=0, P(C/B)=2/5]، الصف3: [P(A/C)=3/5, P(B/C)=2/5, P(C/C)=0]."
  },
  {
    "question": "لنفس المنبع السابق {A,B,C}، ما هي احتمالات الحالة المستقرة؟",
    "options": [
      "P(A)=21/35, P(B)=10/35, P(C)=4/35",
      "P(A)=P(B)=P(C)=1/3",
      "P(A)=3/5, P(B)=2/5, P(C)=0",
      "P(A)=1/2, P(B)=1/4, P(C)=1/4"
    ],
    "correct": 0,
    "explanation": "بحل نظام المعادلات (Q-I)·π=0 مع π₁+π₂+π₃=1، نحصل على: P(A)=π₁=21/35=3/5، P(B)=π₂=10/35=2/7، P(C)=π₃=4/35."
  },
  {
    "question": "في منبع ماركوف من المرتبة الثانية بأبجدية {0,1} مع P(0/00)=P(1/11)=1 وP(0/01)=P(0/10)=0.5، هل المنبع مستقر؟",
    "options": [
      "نعم، لأنه يحتوي على 4 حالات",
      "لا، لأنه يدخل في حلقة غير منتهية ولا يصل لجميع الحالات",
      "نعم، لأن جميع الاحتمالات معرفة",
      "لا، لأن بعض الاحتمالات = 0"
    ],
    "correct": 1,
    "explanation": "المنبع غير مستقر لأنه إذا بدأنا من الحالة 00 أو 11، سنبقى فيهما ولن نصل إلى الحالات الأخرى (01,10) بسبب P(0/00)=1 وP(1/11)=1."
  },
  {
    "question": "في منبع ماركوف من المرتبة الثانية بأبجدية {0,1} مع P(0/00)=P(1/11)=0.7 وP(0/10)=P(0/01)=0.5، ما هي احتمالات الحالة المستقرة؟",
    "options": [
      "P(00)=P(11)=5/16, P(01)=P(10)=3/16",
      "P(00)=P(01)=P(10)=P(11)=1/4",
      "P(00)=0.7, P(11)=0.7, P(01)=P(10)=0.5",
      "P(00)=P(11)=1/2, P(01)=P(10)=0"
    ],
    "correct": 0,
    "explanation": "بحل نظام المعادلات نحصل على: π₁=P(00)=5/16=0.3125، π₂=P(01)=3/16=0.1875، π₃=P(11)=5/16=0.3125، π₄=P(10)=3/16=0.1875."
  },
  {
    "question": "ما هو الفرق بين منبع ماركوف ومنبع بدون ذاكرة؟",
    "options": [
      "لا فرق بينهما",
      "منبع ماركوف له ذاكرة محدودة، بينما منبع بدون ذاكرة تكون أحداثه مستقلة",
      "منبع ماركوف أسرع في الإرسال",
      "منبع ماركوف يستخدم رموزاً أكثر"
    ],
    "correct": 1,
    "explanation": "الفرق الأساسي هو أن منبع ماركوف له ذاكرة محدودة (من مرتبة n) حيث يعتمد الرمز الحالي على الرموز السابقة، بينما في المنبع بدون ذاكرة تكون الأحداث مستقلة ولا يعتمد الرمز على السابق."
  },
  {
    "question": "ما هو الترميز المنطقي للحالات في منبع ماركوف من المرتبة الثانية بأبجدية ثنائية؟",
    "options": [
      "00 → 01 → 10 → 11",
      "00 → 01 → 11 → 10",
      "0 → 1 → 00 → 01",
      "أي ترتيب عشوائي"
    ],
    "correct": 1,
    "explanation": "الترتيب المنطقي هو 00 → 01 → 11 → 10 حيث يكون الفرق بين كل حالة والتي تليها تغيير في خانة واحدة فقط (كود غراي)."
  },
  {
    "question": "كيف نحسب احتمال الحدث المشترك في منبع ماركوف؟",
    "options": [
      "P(الحالة,الرمز) = P(الحالة) × P(الرمز/الحالة)",
      "P(الحالة,الرمز) = P(الحالة) + P(الرمز)",
      "P(الحالة,الرمز) = P(الرمز) فقط",
      "P(الحالة,الرمز) = P(الرمز) × P(الحالة/الرمز)"
    ],
    "correct": 0,
    "explanation": "احتمال الحدث المشترك (الحالة والرمز) = احتمال الحالة × الاحتمال الشرطي لإطلاق الرمز بشرط الحالة."
  },
  {
    "question": "ما هي المعادلة الإضافية التي نستخدمها مع نظام (Q-I)·π=0 لحساب π؟",
    "options": [
      "Σ π_i = 0",
      "Σ π_i = 1",
      "π_1 = 1",
      "π_1 + π_2 = 1"
    ],
    "correct": 1,
    "explanation": "نضيف المعادلة π₁+π₂+...+π_n = 1 لأن مجموع احتمالات جميع الحالات يجب أن يساوي 1."
  },
  {
    "question": "إذا كانت P(0/00)=0.8 وP(1/00)=0.2 في منبع ماركوف، ماذا يعني ذلك؟",
    "options": [
      "احتمال الانتقال من 00 إلى 0 هو 0.8",
      "احتمال أن يكون الرمز التالي 0 إذا كانت الحالة الحالية 00 هو 0.8",
      "احتمال الحالة 00 هو 0.8",
      "احتمال الرمز 0 هو 0.8"
    ],
    "correct": 1,
    "explanation": "P(0/00)=0.8 يعني: إذا كانت الحالة الحالية هي 00، فإن احتمال أن يكون الرمز التالي 0 هو 0.8."
  },
  {
    "question": "كم عدد المعادلات المستقلة في نظام (Q-I)·π=0 لمنبع بـ 4 حالات؟",
    "options": [
      "4 معادلات",
      "3 معادلات",
      "2 معادلات",
      "1 معادلة"
    ],
    "correct": 1,
    "explanation": "نظام (Q-I)·π=0 يعطي 4 معادلات، لكن واحدة منها تعتمد على الأخرى، لذلك لدينا 3 معادلات مستقلة، ونضيف المعادلة الرابعة Σπ_i=1."
  },
  {
    "question": "ما هو شرط 'عدم استقرار' منبع ماركوف؟",
    "options": [
      "وجود احتمالات شرطية = 0",
      "دخول المنبع في حلقة مغلقة لا تشمل جميع الحالات",
      "وجود أكثر من 4 حالات",
      "جميع الاحتمالات متساوية"
    ],
    "correct": 1,
    "explanation": "يكون المنبع غير مستقر إذا دخل في حلقة مغلقة (مثل 00→00 فقط أو 11→11 فقط) ولا يمكن الوصول إلى جميع الحالات منه."
  },
  {
    "question": "كيف يتم تمثيل منبع ماركوف بيانياً؟",
    "options": [
      "بمخطط الانتروبيا",
      "بمخطط الحالة (State Diagram)",
      "بمنحنى Gaussian",
      "بجدول الاحتمالات فقط"
    ],
    "correct": 1,
    "explanation": "يمثل منبع ماركوف بمخطط الحالة (State Diagram) حيث تمثل الدوائر الحالات، والأسهم تمثل الانتقالات مع كتابة الاحتمالات الشرطية عليها."
  },
  {
    "question": "ما هو تأثير زيادة مرتبة منبع ماركوف على عدد الحالات؟",
    "options": [
      "يزيد عدد الحالات بشكل أسي",
      "يقل عدد الحالات",
      "لا يؤثر",
      "يزيد عدد الحالات خطياً"
    ],
    "correct": 0,
    "explanation": "عدد الحالات = q^n، حيث q عدد الرموز، n مرتبة المنبع. لذلك تزداد الحالات بشكل أسي مع زيادة n."
  },
  {
    "question": "في منبع ماركوف، ما هي 'مصفوفة الانتقال' P؟",
    "options": [
      "مصفوفة الاحتمالات الشرطية للانتقال بين الحالات",
      "مصفوفة احتمالات الحالة المستقرة",
      "مصفوفة الانتروبيا",
      "مصفوفة الوحدة"
    ],
    "correct": 0,
    "explanation": "مصفوفة الانتقال P هي مصفوفة q^n × q^n حيث العنصر P[i][j] = P(الانتقال من الحالة i إلى الحالة j)."
  },
  {
    "question": "كيف نحصل على Q من P؟",
    "options": [
      "Q = P^T (منقول P)",
      "Q = P^{-1} (معكوس P)",
      "Q = P + I",
      "Q = P - I"
    ],
    "correct": 0,
    "explanation": "Q هي منقول (Transpose) مصفوفة الانتقال P، أي نبدل الأسطر بالأعمدة."
  },
  {
    "question": "ما هو معنى أن π₁=0.25 في احتمالات الحالة المستقرة؟",
    "options": [
      "احتمال الحالة 1 هو 25% بعد فترة طويلة",
      "احتمال الرمز الأول هو 25%",
      "الانتروبيا = 0.25 بت",
      "عدد الحالات = 4"
    ],
    "correct": 0,
    "explanation": "π₁=0.25 يعني أن احتمال وجود المنبع في الحالة 1 (على المدى الطويل) هو 0.25 أو 25%."
  },
  {
    "question": "لماذا ندرس 'المنابع المستقرة' في نظرية المعلومات؟",
    "options": [
      "لأنها أبسط فقط",
      "لأن احتمالاتها ثابتة ويمكن حساب الانتروبيا بثبات",
      "لأنها نادرة الحدوث",
      "لأنها لا تحتوي على ذاكرة"
    ],
    "correct": 1,
    "explanation": "ندرس المنابع المستقرة لأن احتمالات إطلاق الرموز تستقر على قيم ثابتة، مما يسمح بحساب انتروبيا المنبع بشكل ثابت وموثوق."
  }
],
lec4:[
  {
    "question": "ما هي الصيغة الصحيحة لحساب انتروبية منبع ماركوف H(S)؟",
    "options": [
      "H(S) = Σ P(الحالة) · log(1/P(الحالة))",
      "H(S) = Σ P(الحالة,الرمز) · log(1/P(الرمز/الحالة))",
      "H(S) = Σ P(الرمز) · log(1/P(الرمز))",
      "H(S) = n · H(s) للمنبع الأصلي"
    ],
    "correct": 1,
    "explanation": "انتروبية منبع ماركوف تُحسب كمجموع احتمالات الأحداث المشتركة P(الحالة,الرمز) مضروباً في log(1/P(الرمز/الحالة))."
  },
  {
    "question": "كيف نحسب احتمال الحدث المشترك P(x∩y) في منبع ماركوف؟",
    "options": [
      "P(x∩y) = P(x) + P(y)",
      "P(x∩y) = P(x/y) · P(y)",
      "P(x∩y) = P(y/x) · P(x)",
      "P(x∩y) = P(x) · P(y)"
    ],
    "correct": 1,
    "explanation": "احتمال الحدث المشترك P(x∩y) = P(x/y) · P(y)، حيث x هو الرمز المطلق و y هي الحالة."
  },
  {
    "question": "منبع ماركوف من المرتبة الثانية بأبجدية {0,1}، مع P(0/00)=P(1/11)=0.7 و P(0/10)=P(0/01)=0.5. إذا كانت احتمالات الحالة المستقرة: P(00)=5/16, P(01)=3/16, P(11)=5/16, P(10)=3/16، فما هو احتمال P(0∩00)؟",
    "options": [
      "0.21875",
      "0.3125",
      "0.09375",
      "0.5"
    ],
    "correct": 0,
    "explanation": "P(0∩00) = P(0/00) · P(00) = 0.7 × (5/16) = 0.7 × 0.3125 = 0.21875."
  },
  {
    "question": "ما هو الطول المتوسط L للكود؟",
    "options": [
      "L = Σ P(S_i) · l_i",
      "L = Σ l_i",
      "L = (Σ l_i) / q",
      "L = Σ P(S_i)"
    ],
    "correct": 0,
    "explanation": "الطول المتوسط للكود L = Σ P(S_i) · l_i، حيث P(S_i) احتمال الرمز و l_i طول كود ذلك الرمز."
  },
  {
    "question": "منبع بمتجه احتمالات P(S₁)=0.2, P(S₂)=0.6, P(S₃)=0.1, P(S₄)=0.1. إذا كانت أطوال الكود: l₁=2, l₂=2, l₃=2, l₄=2، فما هو الطول المتوسط؟",
    "options": [
      "1.6 بت",
      "2 بت",
      "1.3 بت",
      "1.8 بت"
    ],
    "correct": 1,
    "explanation": "L = 0.2×2 + 0.6×2 + 0.1×2 + 0.1×2 = 0.4 + 1.2 + 0.2 + 0.2 = 2 بت."
  },
  {
    "question": "لنفس المنبع، إذا كانت أطوال كود بديل: l₁=2, l₂=1, l₃=3, l₄=3، فما هو الطول المتوسط؟",
    "options": [
      "1.6 بت",
      "2 بت",
      "1.3 بت",
      "1.8 بت"
    ],
    "correct": 0,
    "explanation": "L = 0.2×2 + 0.6×1 + 0.1×3 + 0.1×3 = 0.4 + 0.6 + 0.3 + 0.3 = 1.6 بت."
  },
  {
    "question": "ما هو الشرط الذي يجعل الكود 'آنياً' (Instantaneous)؟",
    "options": [
      "أن تكون جميع الأطوال متساوية",
      "أن لا يكون أي كود بداية لكود آخر",
      "أن يكون الطول المتوسط أقل من الانتروبيا",
      "أن تكون المتراجحة كرافت محققة"
    ],
    "correct": 1,
    "explanation": "الكود آني إذا لم يكن أي كود بداية (prefix) لكود آخر في نفس مجموعة الرموز."
  },
  {
    "question": "ما هي متراجحة كرافت (Kraft Inequality)؟",
    "options": [
      "Σ r^{-l_i} ≤ 1",
      "Σ l_i ≤ q",
      "Σ P(S_i) · l_i ≥ H(S)",
      "Σ r^{l_i} ≥ 1"
    ],
    "correct": 0,
    "explanation": "متراجحة كراط: Σ r^{-l_i} ≤ 1، حيث r هو حجم أبجدية الكود (2 للثنائي)، و l_i طول الكود i."
  },
  {
    "question": "إذا كان لدينا كود ثنائي (r=2) بأطوال: l₁=2, l₂=2, l₃=2, l₄=2، فهل تحقق متراجحة كرافت؟",
    "options": [
      "نعم، لأن المجموع = 1",
      "لا، لأن المجموع > 1",
      "نعم، لأن المجموع < 1",
      "لا، لأن الأطوال متساوية"
    ],
    "correct": 0,
    "explanation": "Σ 2^{-2} = 4 × 0.25 = 1، إذن المتراجحة محققة (المجموع = 1)."
  },
  {
    "question": "كود ثنائي بأطوال: l₁=1, l₂=2, l₃=2, l₄=2. هل تحقق متراجحة كرافت؟",
    "options": [
      "نعم، المجموع = 5/4",
      "لا، المجموع = 5/4 > 1",
      "نعم، المجموع = 3/4",
      "لا، المجموع = 7/8"
    ],
    "correct": 1,
    "explanation": "Σ 2^{-l_i} = 2^{-1} + 3×2^{-2} = 0.5 + 3×0.25 = 0.5 + 0.75 = 1.25 > 1، إذن غير محققة."
  },
  {
    "question": "إذا كانت متراجحة كرافت غير محققة، ماذا يعني ذلك؟",
    "options": [
      "الكود آني",
      "الكود غير آني",
      "الكود مثالي",
      "الطول المتوسط أقل من الانتروبيا"
    ],
    "correct": 1,
    "explanation": "إذا كانت متراجحة كرافت غير محققة (المجموع > 1)، فإن الكود غير آني حتماً."
  },
  {
    "question": "إذا كانت متراجحة كرافت محققة، هل يعني ذلك أن الكود آني؟",
    "options": [
      "نعم دائماً",
      "لا دائماً",
      "نعم، إذا كانت الأطوال متساوية",
      "لا، إلا إذا كان r=2"
    ],
    "correct": 1,
    "explanation": "إذا كانت المتراجحة محققة، فهذا لا يضمن أن الكود آني. هناك أكواد محققة للمتراجحة ولكنها غير آنية."
  },
  {
    "question": "ماذا نعني بـ 'الكود المقبول'؟",
    "options": [
      "الكود ذو الطول المتوسط الأصغر",
      "الكود الآني",
      "الكود المحقق لمتراجحة كرافت",
      "الكود ذو الأطوال المتساوية"
    ],
    "correct": 1,
    "explanation": "الكود المقبول هو الكود الآني، أي الذي لا يكون أي رمز فيه بداية لرمز آخر."
  },
  {
    "question": "كيف نختار 'الكود الأفضل' من بين عدة أكواد مقبولة؟",
    "options": [
      "الذي له أصغر طول متوســط",
      "الذي له أكبر طول متوســط",
      "الذي له أطوال متساوية",
      "الذي يحقق متراجحة كرافت بأكبر مجموع"
    ],
    "correct": 0,
    "explanation": "الكود الأفضل من بين الأكواد المقبولة (الآنية) هو ذو الطول المتوسط الأصغر L."
  },
  {
    "question": "ما الفرق بين الترميز الثنائي والترميز الثلاثي؟",
    "options": [
      "الثنائي uses r=2، الثلاثي uses r=3",
      "لا فرق",
      "الثنائي أسرع",
      "الثلاثي أكثر تعقيداً"
    ],
    "correct": 0,
    "explanation": "الترميز الثنائي يستخدم أبجدية بحجم r=2 (0,1)، بينما الترميز الثلاثي يستخدم r=3 (0,1,2)."
  },
  {
    "question": "إذا كان لدينا كود: A=0, B=01, C=011، هل هذا الكود آني؟",
    "options": [
      "نعم",
      "لا، لأن 0 بداية لـ 01",
      "لا، لأن 01 بداية لـ 011",
      "نعم، لأن الأطوال مختلفة"
    ],
    "correct": 2,
    "explanation": "الكود غير آني لأن الرمز B=01 هو بداية للرمز C=011، مما يسبب غموضاً عند فك الترميز."
  },
  {
    "question": "كود: A=0, B=10, C=110, D=111. هل هذا الكود آني؟",
    "options": [
      "نعم",
      "لا",
      "يعتمد على الاحتمالات",
      "لا يمكن معرفة"
    ],
    "correct": 0,
    "explanation": "الكود آني لأنه لا يوجد أي رمز هو بداية لرمز آخر. جميع الرموز مميزة ولا يشكل أحدها بادئة لآخر."
  },
  {
    "question": "ما هو طول كلمة الترميز إذا كانت أبجدية المصدر تحتوي على 8 رموز وأردنا ترميز متساوي الطول؟",
    "options": [
      "2 بت",
      "3 بت",
      "4 بت",
      "8 بت"
    ],
    "correct": 1,
    "explanation": "لتمثيل 8 رموز بشكل ثنائي متساوي الطول، نحتاج 3 بت لأن 2³=8."
  },
  {
    "question": "ما هي العلاقة بين الطول المتوسط L وانتروبيا المصدر H(S)؟",
    "options": [
      "L ≥ H(S)",
      "L ≤ H(S)",
      "L = H(S)",
      "لا علاقة"
    ],
    "correct": 0,
    "explanation": "نظرية شانون للترميز تنص أن L ≥ H(S) لأي كود آني. الطول المتوسط لا يمكن أن يكون أقل من الانتروبيا."
  },
  {
    "question": "إذا كانت H(S)=2.5 بت و L=2.7 بت، هل هذا مقبول؟",
    "options": [
      "نعم، لأن L ≥ H(S)",
      "لا، لأن L > H(S)",
      "لا، لأن الفرق كبير",
      "نعم، إذا كان الكود آني"
    ],
    "correct": 3,
    "explanation": "نعم مقبول إذا كان الكود آني، لأن الطول المتوسط L يجب أن يكون ≥ H(S)، وهنا 2.7 ≥ 2.5."
  }
],lec5:[
  {
    "question": "منبع يحتوي على 10 رموز {0,1,...,9}. قمنا بترميز رمزين: 0 → '1' و 1 → '10'. إذا كانت جميع الأكواد المتبقية متساوية الطول ونريد كوداً آنياً، فما هو الطول l الذي يجب أن يكون للرموز المتبقية؟",
    "options": [
      "l = 3",
      "l = 4",
      "l = 5",
      "l = 6"
    ],
    "correct": 2,
    "explanation": "لتحقيق متراجحة كراط للكود الثنائي: 2^(-1) + 2^(-2) + 8×2^(-l) ≤ 1 ⇒ 0.5 + 0.25 + 8×2^(-l) ≤ 1 ⇒ 8×2^(-l) ≤ 0.25 ⇒ 2^(-l) ≤ 1/32 ⇒ 2^l ≥ 32 ⇒ l ≥ 5. لذلك l = 5 هو الأصغر الممكن."
  },
  {
    "question": "منبع بـ 10 رموز (q=10) نريد ترميزه بشيفرة ثلاثية (r=3). إذا كانت أطوال الكود المقترحة هي: 1,2,2,2,2,2,3,3,3,3. هل يمكن كتابة كود آني بهذه الأطوال؟",
    "options": [
      "نعم، لأن المتراجحة محققة",
      "لا، لأن المتراجحة غير محققة",
      "نعم، لأن الأطوال متساوية",
      "لا، لأن r=3"
    ],
    "correct": 1,
    "explanation": "نحقق متراجحة كراط: Σ 3^(-l_i) = 3^(-1) + 5×3^(-2) + 4×3^(-3) = 1/3 + 5×(1/9) + 4×(1/27) = 1/3 + 5/9 + 4/27 = 9/27 + 15/27 + 4/27 = 28/27 > 1. المتراجحة غير محققة، لذا لا يمكن كتابة كود آني."
  },
  {
    "question": "منبع بـ 9 رموز نريد ترميزه بشيفرة ثلاثية (r=3) بأطوال: 1,2,2,2,2,2,3,3,3. هل يمكن كتابة كود آني بهذه الأطوال؟",
    "options": [
      "نعم، لأن المتراجحة محققة",
      "لا، لأن المتراجحة غير محققة",
      "نعم، لأن عدد الرموز فردي",
      "لا، لأن هناك طولين مختلفين"
    ],
    "correct": 0,
    "explanation": "Σ 3^(-l_i) = 3^(-1) + 5×3^(-2) + 3×3^(-3) = 1/3 + 5×(1/9) + 3×(1/27) = 1/3 + 5/9 + 3/27 = 9/27 + 15/27 + 3/27 = 27/27 = 1. المتراجحة محققة (تساوي 1)، لذا يمكن كتابة كود آني."
  },
  {
    "question": "ما هي صيغة حساب M (عدد حدود هوفمان) للشيفرة ذات الأساس r؟",
    "options": [
      "M = r + α",
      "M = r + α(r - 1)",
      "M = q + α",
      "M = r × α"
    ],
    "correct": 1,
    "explanation": "عدد حدود هوفمان M يُحسب بالصيغة: M = r + α(r - 1)، حيث r أساس الشيفرة، و α عدد طبيعي موجب."
  },
  {
    "question": "لدينا منبع بـ 8 رموز، نريد ترميزه بشيفرة ثلاثية (r=3). ما هي قيمة α التي تحقق الشرط M ≥ q؟",
    "options": [
      "α = 1",
      "α = 2",
      "α = 3",
      "α = 4"
    ],
    "correct": 2,
    "explanation": "M = 3 + α(3-1) = 3 + 2α. نحتاج M ≥ 8: 3 + 2α ≥ 8 ⇒ 2α ≥ 5 ⇒ α ≥ 2.5. أصغر α طبيعي يحقق هو α = 3، إذن M = 3 + 2×3 = 9."
  },
  {
    "question": "عند تطبيق خوارزمية هوفمان لشيفرة ثلاثية (r=3) على منبع بـ 8 رموز مع α=3 و M=9، كم رمزاً صفرياً يجب إضافته؟",
    "options": [
      "0",
      "1",
      "2",
      "3"
    ],
    "correct": 1,
    "explanation": "عدد الرموز الصفرية المضافة = M - q = 9 - 8 = 1. نضيف رمزاً واحداً باحتمال 0."
  },
  {
    "question": "في خوارزمية هوفمان، كيف نختار الرموز المجمعة في كل خطوة؟",
    "options": [
      "أصغر رموزين احتمالاً",
      "أكبر رموزين احتمالاً",
      "أصغر r رموز احتمالاً",
      "أي رموز عشوائياً"
    ],
    "correct": 2,
    "explanation": "في كل خطوة من هوفمان، نختار أصغر r رموز من حيث الاحتمال (أو الأكثر احتمالاً إذا كنا نرتب تنازلياً) ونجمعها."
  },
  {
    "question": "منبع بمتجه الاحتمالات: {0.25, 0.2, 0.15, 0.13, 0.12, 0.08, 0.06, 0.01}. عند تطبيق هوفمان الثلاثي (r=3)، ما هي القيم الثلاث الأصغر في الخطوة الأولى؟",
    "options": [
      "0.25, 0.2, 0.15",
      "0.06, 0.08, 0.01",
      "0.13, 0.12, 0.08",
      "0.01, 0.06, 0.08"
    ],
    "correct": 3,
    "explanation": "بعد ترتيب الاحتمالات تنازلياً: 0.25, 0.2, 0.15, 0.13, 0.12, 0.08, 0.06, 0.01. الأصغر ثلاثاً هي: 0.01, 0.06, 0.08 (نرتبهم تصاعدياً للأصغر)."
  },
  {
    "question": "ما هو الهدف الرئيسي من استخدام خوارزمية هوفمان؟",
    "options": [
      "إنتاج كود آني",
      "إنتاج كود ذو طول متوسط أقل ما يمكن",
      "إنتاج كود ذو أطوال متساوية",
      "إنتاج كود يحقق متراجحة كراط"
    ],
    "correct": 1,
    "explanation": "هدف هوفمان هو إنتاج كود آني (قابل للفك فورياً) ذو طول متوسط L أقل ما يمكن، أي أقرب ما يكون إلى الانتروبيا H(S)."
  },
  {
    "question": "إذا كانت الشيفرة ثنائية (r=2) ولمنبع بـ 5 رموز، ما هي قيمة M؟",
    "options": [
      "M = 2",
      "M = 5",
      "M = 6",
      "M = 7"
    ],
    "correct": 1,
    "explanation": "لشيفرة ثنائية (r=2)، نحسب: M = 2 + α(2-1) = 2 + α. نحتاج M ≥ 5 ⇒ 2 + α ≥ 5 ⇒ α ≥ 3. أصغر α = 3، إذن M = 2 + 3 = 5. لاحظ أن M = q، لذلك لا نضيف رموزاً صفرية."
  },
  {
    "question": "ما هو الكود الناتج عن هوفمان للرمز ذي الاحتمال 0.25 في المثال الثلاثي؟",
    "options": [
      "0",
      "1",
      "2",
      "00"
    ],
    "correct": 0,
    "explanation": "في الجدول المرفق في المحاضرة، الكود الناتج للرمز S1 باحتمال 0.25 هو '0' (شيفرة أحادية)."
  },
  {
    "question": "ما هو الكود الناتج عن هوفمان للرمز ذي الاحتمال 0.2 في المثال الثلاثي؟",
    "options": [
      "1",
      "10",
      "11",
      "12"
    ],
    "correct": 0,
    "explanation": "في الجدول، الكود للرمز S6 باحتمال 0.2 هو '1' (شيفرة أحادية)."
  },
  {
    "question": "ما هو الكود الناتج عن هوفمان للرمز ذي الاحتمال 0.15 في المثال الثلاثي؟",
    "options": [
      "2",
      "20",
      "21",
      "22"
    ],
    "correct": 0,
    "explanation": "في الجدول، الكود للرمز S8 باحتمال 0.15 هو '2' (شيفرة أحادية)."
  },
  {
    "question": "ما هو الكود الناتج عن هوفمان للرمز ذي الاحتمال 0.01 في المثال الثلاثي؟",
    "options": [
      "121",
      "120",
      "021",
      "022"
    ],
    "correct": 0,
    "explanation": "في الجدول، الكود للرمز S2 باحتمال 0.01 هو '121' (شيفرة ثلاثية)."
  },
  {
    "question": "في خوارزمية هوفمان، لماذا نضيف رموزاً باحتمال صفر؟",
    "options": [
      "لزيادة الانتروبيا",
      "لجعل عدد الرموز يساوي M",
      "لتقليل الطول المتوسط",
      "لجعل الكود آنياً"
    ],
    "correct": 1,
    "explanation": "نضيف رموزاً احتمالاتها صفر (رموز وهمية) لنجعل العدد الإجمالي للرموز يساوي M، مما يسمح بتطبيق خوارزمية هوفمان بشكل صحيح عندما لا يكون q مناسباً لـ r."
  },
  {
    "question": "ما هو 'الكود المكثف' (Compact Code)؟",
    "options": [
      "كود ذو أطوال متساوية",
      "كود آني ذو طول متوسط أقل ما يمكن",
      "كود غير آني",
      "كود يحقق متراجحة كراط"
    ],
    "correct": 1,
    "explanation": "الكود المكثف هو الكود الآني ذو الطول المتوسط الأدنى الممكن. هوفمان ينتج مثل هذا الكود."
  },
  {
    "question": "إذا كانت متراجحة كراط محققة تماماً (المجموع = 1)، ماذا يعني؟",
    "options": [
      "الكود مثالي",
      "الكود غير آني",
      "الكود ذو أطوال متساوية",
      "الكود الأفضل دائماً"
    ],
    "correct": 0,
    "explanation": "عندما يكون Σ r^{-l_i} = 1، يسمى الكود 'مثالي' (perfect) أو 'مكتمل' (complete)، لكن هذا لا يعني بالضرورة أنه الأمثل من حيث الطول المتوسط."
  },
  {
    "question": "كيف نتحقق من أن الكود الناتج عن هوفمان هو بالفعل آني؟",
    "options": [
      "بفحص أن لا يكون أي كود بداية لكود آخر",
      "بحساب الطول المتوسط",
      "بتحقيق متراجحة كراط",
      "بمقارنة L مع H(S)"
    ],
    "correct": 0,
    "explanation": "للتحقق من أن الكود آني، نفحص خاصية 'البادئة': لا يجب أن يكون أي كود في المجموعة بداية (بادئة) لكود آخر."
  },
  {
    "question": "ما الفرق بين هوفمان الثنائي وهوفمان العام لـ r>2؟",
    "options": [
      "لا فرق",
      "في الثنائي نختار أصغر احتمالين، في العام نختار أصغر r احتمالات",
      "في الثنائي لا نضيف رموزاً صفرية",
      "في العام الطول المتوسط أكبر"
    ],
    "correct": 1,
    "explanation": "الفرق الأساسي: في الثنائي (r=2) نختار أصغر احتمالين ونجمعهما. في هوفمان العام (r>2) نختار أصغر r احتمالات ونجمعها."
  }
],
          }

        }
    };

      let currentQuestion = 0;
        let userAnswers = [];
        let score = 0;
        let timer;
        let timeLeft = 20 * 60;
        let questions = [];
        let lastSubjectKey = null;
        let lastLectureKey = null;
        let isFullExam = false;

// تأكد من تعريف هذه المتغيرات
const footerHome = document.getElementById('footer-home');
const footerSubjects = document.getElementById('footer-subjects');
const footerLectures = document.getElementById('footer-lectures');
const footerResults = document.getElementById('footer-results');
const footerHelp = document.getElementById('footer-help');

        // ===================== عناصر DOM =====================
        const startScreen = document.getElementById('start-screen');
        const subjectScreen = document.getElementById('subject-screen');
        const lectureScreen = document.getElementById('lecture-screen');
        const examScreen = document.getElementById('exam-screen');
        const resultScreen = document.getElementById('result-screen');
        const startBtn = document.getElementById('start-btn');
        const timerDisplay = document.getElementById('timer');
        const currentQDisplay = document.getElementById('current-q');
        const scoreDisplay = document.getElementById('score');
        const questionText = document.getElementById('question-text');
        const optionsContainer = document.getElementById('options-container');
        const prevBtn = document.getElementById('prev-btn');
        const nextBtn = document.getElementById('next-btn');
        const submitBtn = document.getElementById('submit-btn');
        const correctSound = document.getElementById('correct-sound');
        const wrongSound = document.getElementById('wrong-sound');
        const correctCountDisplay = document.getElementById('correct-count');
        const wrongCountDisplay = document.getElementById('wrong-count');
        const skippedCountDisplay = document.getElementById('skipped-count');
        const finalScoreDisplay = document.getElementById('final-score');
        const answersReview = document.getElementById('answers-review');
        const restartBtn = document.getElementById('restart-btn');
        const homeBtn = document.getElementById('home-btn');
        const subjectList = document.getElementById('subject-list');
        const lectureList = document.getElementById('lecture-list');
        const lectureTitle = document.getElementById('lecture-title');
        const backSubjectsBtn = document.getElementById('back-subjects');
        const fullExamBtn = document.getElementById('full-exam-btn');
        const toast = document.getElementById('toast');

        const explanationModal = document.getElementById('explanation-modal');
        const modalQuestion = document.getElementById('modal-question');
        const modalCorrect = document.getElementById('modal-correct-answer');
        const modalExplanation = document.getElementById('modal-explanation-text');
        const modalNextBtn = document.getElementById('modal-next-btn');
        const examSubjectDisplay = document.getElementById('exam-subject');
        const examLectureDisplay = document.getElementById('exam-lecture');

        // ===================== وظائف مساعدة =====================
        function showToast(message, type = 'info', duration = 3000) {
            toast.textContent = message;
            toast.className = `toast ${type}`;
            toast.classList.add('show');
            
            setTimeout(() => {
                toast.classList.remove('show');
            }, duration);
        }

        function shuffleArray(array) {
            let arr = array.slice();
            for (let i = arr.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [arr[i], arr[j]] = [arr[j], arr[i]];
            }
            return arr;
        }

        // ===================== وظائف اختيار المادة والمحاضرة =====================
       function showSubjects() {
    subjectList.innerHTML = '';
    Object.keys(subjects).forEach(subKey => {
        const sub = subjects[subKey];
        const btn = document.createElement('button');
        btn.textContent = sub.name;
        btn.className = 'btn-subject';
        btn.addEventListener('click', () => showLectures(subKey));
        subjectList.appendChild(btn);
    });
    startScreen.classList.remove('active');
    subjectScreen.classList.add('active');
}

        function showLectures(subKey) {
            const sub = subjects[subKey];
            lastSubjectKey = subKey;
            lectureTitle.textContent = `اختبارات ${sub.name}`;
            lectureList.innerHTML = '';

            // زر الفحص الشامل لجميع المحاضرات
            fullExamBtn.onclick = () => startFullExam(subKey);

            // عرض المحاضرات الفردية مع عدد الأسئلة
            Object.keys(sub.lectures).forEach(lecKey => {
                const lectureQuestions = sub.lectures[lecKey];
                const btn = document.createElement('button');
                btn.innerHTML = `
                    <i class="fas fa-file-alt"></i> 
                    المحاضرة ${lecKey.replace('lec','')}
                    <div class="lecture-count">${lectureQuestions.length} سؤال</div>
                `;
                btn.className = 'btn-lecture';
                btn.addEventListener('click', () => {
                    if (lectureQuestions.length === 0) {
                        showToast("هذه المحاضرة لا تحتوي على أسئلة بعد!", "warning");
                        return;
                    }
                    startLecture(subKey, lecKey);
                });
                lectureList.appendChild(btn);
            });

            subjectScreen.classList.remove('active');
            lectureScreen.classList.add('active');
        }

        // ===================== وظائف بدء الاختبار =====================
        function startFullExam(subKey) {
            const sub = subjects[subKey];
            const allLectures = sub.lectures;
            let allQuestions = [];
            
            // جمع جميع الأسئلة من كل المحاضرات
            Object.values(allLectures).forEach(lec => {
                allQuestions = allQuestions.concat(lec);
            });

            // التحقق من وجود أسئلة
            if (allQuestions.length === 0) {
                showToast("المادة لا تحتوي على أي أسئلة!", "warning");
                return;
            }

            if (allQuestions.length < 20) {
                showToast(`تحذير: المادة تحتوي على ${allQuestions.length} سؤال فقط، سيتم تكرار بعض الأسئلة في الاختبار`, "warning", 5000);
                
                // تكرار الأسئلة إذا كانت أقل من 20
                let repeatedQuestions = [];
                while (repeatedQuestions.length < 20) {
                    repeatedQuestions = repeatedQuestions.concat(allQuestions);
                }
                questions = shuffleArray(repeatedQuestions).slice(0, 20);
            } else {
                questions = shuffleArray(allQuestions).slice(0, 20);
            }

            // إعداد البيانات للفحص الشامل
            lastSubjectKey = subKey;
            lastLectureKey = null;
            isFullExam = true;
            examSubjectDisplay.textContent = `المادة: ${sub.name}`;
            examLectureDisplay.textContent = `فحص شامل لجميع المحاضرات`;

            // إعداد المتغيرات
            userAnswers = new Array(questions.length).fill(-1);
            currentQuestion = 0;
            score = 0;
            timeLeft = 20 * 60;
            scoreDisplay.textContent = '0';
            timerDisplay.textContent = '20:00';
            timerDisplay.classList.remove('timer-warning', 'timer-danger');

            // الانتقال لشاشة الاختبار
            lectureScreen.classList.remove('active');
            examScreen.classList.add('active');
            startTimer();
            displayQuestion(0);
        }

        function startLecture(subKey, lecKey) {
            const sub = subjects[subKey];
            const lectureQuestions = sub.lectures[lecKey];

            // التحقق من عدد الأسئلة
            if (lectureQuestions.length === 0) {
                showToast("هذه المحاضرة لا تحتوي على أسئلة!", "warning");
                return;
            }

            // إعداد الأسئلة
            if (lectureQuestions.length < 20) {
                showToast(`تحذير: المحاضرة تحتوي على ${lectureQuestions.length} سؤال فقط، سيتم تكرار بعض الأسئلة`, "warning", 5000);
                
                let repeatedQuestions = [];
                while (repeatedQuestions.length < 20) {
                    repeatedQuestions = repeatedQuestions.concat(lectureQuestions);
                }
                questions = shuffleArray(repeatedQuestions).slice(0, 20);
            } else {
                questions = shuffleArray(lectureQuestions).slice(0, 20);
            }

            // إعداد البيانات للمحاضرة الفردية
            lastSubjectKey = subKey;
            lastLectureKey = lecKey;
            isFullExam = false;
            examSubjectDisplay.textContent = `المادة: ${sub.name}`;
            examLectureDisplay.textContent = `المحاضرة: ${lecKey.replace('lec','')}`;

            // إعداد المتغيرات
            userAnswers = new Array(questions.length).fill(-1);
            currentQuestion = 0;
            score = 0;
            timeLeft = 20 * 60;
            scoreDisplay.textContent = '0';
            timerDisplay.textContent = '20:00';
            timerDisplay.classList.remove('timer-warning', 'timer-danger');

            // الانتقال لشاشة الاختبار
            lectureScreen.classList.remove('active');
            examScreen.classList.add('active');
            startTimer();
            displayQuestion(0);
        }

        // ===================== وظائف الاختبار =====================
        function startTimer() {
            clearInterval(timer);
            timer = setInterval(() => {
                timeLeft--;
                const minutes = Math.floor(timeLeft / 60);
                const seconds = timeLeft % 60;
                timerDisplay.textContent = `${minutes.toString().padStart(2,'0')}:${seconds.toString().padStart(2,'0')}`;
                
                if (timeLeft <= 60) {
                    timerDisplay.classList.add('timer-danger');
                    if (timeLeft === 60) showToast("تنبيه: بقي دقيقة واحدة فقط!", "warning");
                } else if (timeLeft <= 300) {
                    timerDisplay.classList.add('timer-warning');
                    if (timeLeft === 300) showToast("تنبيه: بقي 5 دقائق فقط!", "warning");
                }
                
                if (timeLeft <= 0) { 
                    clearInterval(timer); 
                    showToast("انتهى الوقت! سيتم إنهاء الاختبار تلقائياً", "warning");
                    setTimeout(finishExam, 1000);
                }
            }, 1000);
        }

        function displayQuestion(index){
            currentQuestion = index;
            const q = questions[index];
            currentQDisplay.textContent = index + 1;
            questionText.textContent = q.question;
            optionsContainer.innerHTML = '';
            
            q.options.forEach((opt,i)=>{
                const btn = document.createElement('button');
                btn.textContent = opt;
                btn.className = 'option-btn';
                if(userAnswers[index]===i) btn.classList.add('selected');
                btn.addEventListener('click', ()=> selectOption(i));
                optionsContainer.appendChild(btn);
            });
            
            prevBtn.disabled = index===0;
            nextBtn.disabled = index===questions.length-1;
            
            // تحديث حالة السؤال
            const optionBtns = document.querySelectorAll('.option-btn');
            optionBtns.forEach(btn => btn.disabled = userAnswers[index] !== -1);
        }

        function selectOption(optionIndex) {
            if (userAnswers[currentQuestion] !== -1) return;
            userAnswers[currentQuestion] = optionIndex;

            const options = document.querySelectorAll('.option-btn');
            const isCorrect = optionIndex === questions[currentQuestion].correct;

            options.forEach((btn, i) => {
                btn.classList.remove('selected');
                if (i === optionIndex) btn.classList.add('selected');
                if (i === questions[currentQuestion].correct) {
                    btn.classList.add('correct-answer');
                } else if (i === optionIndex && !isCorrect) {
                    btn.classList.add('wrong-answer');
                }
                btn.disabled = true;
            });

            if (isCorrect) {
                playSound('correct');
                score++;
                scoreDisplay.textContent = score;
                setTimeout(() => {
                    if (currentQuestion < questions.length - 1) {
                        displayQuestion(currentQuestion + 1);
                    } else {
                        finishExam();
                    }
                }, 500);
            } else {
                playSound('wrong');
                const q = questions[currentQuestion];
                modalQuestion.textContent = q.question;
                modalCorrect.textContent = q.options[q.correct];
                modalExplanation.textContent = q.explanation;
                explanationModal.style.display = "flex";
            }
        }

        function finishExam(){
            clearInterval(timer);
            let correct=0, wrong=0, skipped=0;
            
            questions.forEach((q,i)=>{
                if(userAnswers[i]===-1) skipped++;
                else if(userAnswers[i]===q.correct) correct++;
                else wrong++;
            });
            
            const finalScore = Math.round((correct/questions.length)*100);
            correctCountDisplay.textContent = correct;
            wrongCountDisplay.textContent = wrong;
            skippedCountDisplay.textContent = skipped;
            finalScoreDisplay.textContent = finalScore+'%';
            answersReview.innerHTML = '';
            
            questions.forEach((q,i)=>{
                const div = document.createElement('div');
                div.className='answer-item';
                let status='skipped', statusText='غير مجاب', userAnswerText='لم تجب';
                
                if(userAnswers[i]!==-1){
                    userAnswerText=q.options[userAnswers[i]];
                    if(userAnswers[i]===q.correct){ 
                        status='correct'; 
                        statusText='صحيح'; 
                    } else { 
                        status='wrong'; 
                        statusText='خطأ'; 
                    }
                }
                
                div.classList.add(status);
                div.innerHTML = `
                    <strong>سؤال ${i+1}:</strong> ${q.question}<br>
                    إجابتك: <span style="color: ${status === 'correct' ? 'var(--success)' : status === 'wrong' ? 'var(--danger)' : 'var(--warning)'}">${userAnswerText}</span><br>
                    الإجابة الصحيحة: <span style="color: var(--accent)">${q.options[q.correct]}</span><br>
                    الحالة: <span style="color: ${status === 'correct' ? 'var(--success)' : status === 'wrong' ? 'var(--danger)' : 'var(--warning)'}">${statusText}</span><br>
                    شرح: ${q.explanation}
                `;
                answersReview.appendChild(div);
            });

            examScreen.classList.remove('active');
            resultScreen.classList.add('active');

            if(finalScore>=70) {
                playSound('correct');
                showToast(`ممتاز! لقد حصلت على ${finalScore}%`, "info");
            } else {
                playSound('wrong');
                showToast(`حاول مرة أخرى! حصلت على ${finalScore}%`, "warning");
            }
        }

        function playSound(type){
            if(type==='correct'){ 
                correctSound.currentTime=0; 
                correctSound.play().catch(e => console.log("خطأ في تشغيل الصوت:", e)); 
            } else if(type==='wrong'){ 
                wrongSound.currentTime=0; 
                wrongSound.play().catch(e => console.log("خطأ في تشغيل الصوت:", e)); 
            }
        }

        // ===================== أحداث المستخدم =====================
        startBtn.addEventListener('click', showSubjects);
        
        backSubjectsBtn.addEventListener('click', () => {
            lectureScreen.classList.remove('active');
            subjectScreen.classList.add('active');
        });
        
        prevBtn.addEventListener('click', ()=> {
            if(currentQuestion>0) displayQuestion(currentQuestion-1);
        });
        
        nextBtn.addEventListener('click', ()=> {
            if(currentQuestion<questions.length-1) displayQuestion(currentQuestion+1);
        });
        
        submitBtn.addEventListener('click', ()=> {
            if(confirm("هل أنت متأكد من إنهاء الاختبار؟")) finishExam();
        });
        
        restartBtn.addEventListener('click', () => {
            if (!lastSubjectKey) {
                resultScreen.classList.remove('active');
                startScreen.classList.add('active');
                return;
            }

            let allQuestions = [];
            if (isFullExam) {
                const allLectures = subjects[lastSubjectKey].lectures;
                Object.values(allLectures).forEach(lec => {
                    allQuestions = allQuestions.concat(lec);
                });
            } else {
                allQuestions = subjects[lastSubjectKey].lectures[lastLectureKey];
            }

            // تطبيق نفس منطق تكرار الأسئلة
            if (allQuestions.length < 20) {
                let repeatedQuestions = [];
                while (repeatedQuestions.length < 20) {
                    repeatedQuestions = repeatedQuestions.concat(allQuestions);
                }
                questions = shuffleArray(repeatedQuestions).slice(0, 20);
            } else {
                questions = shuffleArray(allQuestions).slice(0, 20);
            }

            userAnswers = new Array(questions.length).fill(-1);
            currentQuestion = 0;
            score = 0;
            timeLeft = 20 * 60;
            scoreDisplay.textContent = '0';
            timerDisplay.textContent = '20:00';
            timerDisplay.classList.remove('timer-warning', 'timer-danger');

            resultScreen.classList.remove('active');
            examScreen.classList.add('active');
            startTimer();
            displayQuestion(0);
        });
        
        homeBtn.addEventListener('click', ()=>{
            resultScreen.classList.remove('active'); 
            startScreen.classList.add('active');
        });
        
        modalNextBtn.addEventListener('click', () => {
            explanationModal.style.display = "none";
            if (currentQuestion < questions.length - 1) {
                displayQuestion(currentQuestion + 1);
            } else {
                finishExam();
            }
        });

        // =================== منع كليك يمين ===================
        document.addEventListener("contextmenu", function(e) {
            e.preventDefault();
            showToast("🚫 ممنوع استخدام زر الفأرة الأيمن", "warning");
            return false;
        });
        
        document.addEventListener("mousedown", function(e) {
            if (e.button === 2) {
                e.preventDefault();
                e.stopPropagation();
                return false;
            }
        });

        // =================== منع اختصارات DevTools ===================
        document.addEventListener("keydown", function(e) {
            const forbidden =
                e.key === "F12" ||
                (e.ctrlKey && e.shiftKey && ["I","C","J"].includes(e.key.toUpperCase())) || 
                (e.ctrlKey && ["U","S","A"].includes(e.key.toUpperCase())); 
            if (forbidden) {
                e.preventDefault();
                showToast("🚫 هذا الاختصار ممنوع على الموقع", "warning");
                return false;
            }
        });

// ===================== روابط الفوتر =====================
// ===================== روابط الفوتر =====================
document.getElementById('footer-home').addEventListener('click', function(e) {
    e.preventDefault();
    resultScreen.classList.remove('active');
    subjectScreen.classList.remove('active');
    lectureScreen.classList.remove('active');
    examScreen.classList.remove('active');
    startScreen.classList.add('active');
});

document.getElementById('footer-subjects').addEventListener('click', function(e) {
    e.preventDefault();
    showSubjects(); // استدعاء دالة عرض المواد مباشرة
});

document.getElementById('footer-lectures').addEventListener('click', function(e) {
    e.preventDefault();
    
    // الانتقال لشاشة المحاضرات
    resultScreen.classList.remove('active');
    examScreen.classList.remove('active');
    startScreen.classList.remove('active');
    subjectScreen.classList.remove('active');
    
    // تنظيف شاشة المحاضرات
    lectureTitle.textContent = "جميع المحاضرات";
    lectureList.innerHTML = '';
    
    // إخفاء قسم الفحص الشامل
    const fullExamSection = document.querySelector('.full-exam-section');
    if (fullExamSection) {
        fullExamSection.style.display = 'none';
    }
    
    // إخفاء عنوان المحاضرات الفردية
    const lecturesSection = document.querySelector('.lectures-section h3');
    if (lecturesSection) {
        lecturesSection.textContent = "جميع المحاضرات المتاحة";
    }
    
    // جمع وعرض جميع المحاضرات
    let allLectures = [];
    
    Object.keys(subjects).forEach(subKey => {
        const sub = subjects[subKey];
        
        Object.keys(sub.lectures).forEach(lecKey => {
            const lectureQuestions = sub.lectures[lecKey];
            
            // إضافة كل محاضرة إلى القائمة
            allLectures.push({
                subject: sub.name,
                subjectKey: subKey,
                lectureKey: lecKey,
                lectureNumber: lecKey.replace('lec', ''),
                questionCount: lectureQuestions.length
            });
        });
    });
    
    // ترتيب المحاضرات حسب اسم المادة ثم رقم المحاضرة
    allLectures.sort((a, b) => {
        if (a.subject !== b.subject) {
            return a.subject.localeCompare(b.subject, 'ar');
        }
        return parseInt(a.lectureNumber) - parseInt(b.lectureNumber);
    });
    
    // عرض المحاضرات
    allLectures.forEach(lecture => {
        const lectureCard = document.createElement('div');
        lectureCard.className = 'lecture-card';
        lectureCard.innerHTML = `
            <div class="lecture-card-header">
                <div class="lecture-subject">${lecture.subject}</div>
                <div class="lecture-number">المحاضرة ${lecture.lectureNumber}</div>
            </div>
            <div class="lecture-card-body">
                <div class="lecture-info">
                    <div class="info-item">
                        <i class="fas fa-question-circle"></i>
                        <span>${lecture.questionCount} سؤال</span>
                    </div>
                    <div class="info-item">
                        <i class="fas fa-clock"></i>
                        <span>${Math.ceil(lecture.questionCount * 0.5)} دقيقة</span>
                    </div>
                </div>
            </div>
            <div class="lecture-card-footer">
                <button class="btn-start-lecture" data-subject="${lecture.subjectKey}" data-lecture="${lecture.lectureKey}">
                    <i class="fas fa-play"></i> بدء الاختبار
                </button>
            </div>
        `;
        
        lectureList.appendChild(lectureCard);
    });
    
    // إضافة حدث النقر على أزرار بدء الاختبار
    document.querySelectorAll('.btn-start-lecture').forEach(btn => {
        btn.addEventListener('click', function() {
            const subjectKey = this.getAttribute('data-subject');
            const lectureKey = this.getAttribute('data-lecture');
            
            const lectureQuestions = subjects[subjectKey].lectures[lectureKey];
            if (lectureQuestions.length === 0) {
                showToast("هذه المحاضرة لا تحتوي على أسئلة بعد!", "warning");
                return;
            }
            
            startLecture(subjectKey, lectureKey);
        });
    });
    
    lectureScreen.classList.add('active');
});

document.getElementById('footer-results').addEventListener('click', function(e) {
    e.preventDefault();
    if (questions.length > 0) {
        subjectScreen.classList.remove('active');
        lectureScreen.classList.remove('active');
        examScreen.classList.remove('active');
        startScreen.classList.remove('active');
        resultScreen.classList.add('active');
    } else {
        showToast("لم تقم بأي اختبار بعد!", "warning");
    }
});

document.getElementById('footer-help').addEventListener('click', function(e) {
    e.preventDefault();
    showToast(`
        <strong>دليل استخدام النظام:</strong><br>
        1. اختر المادة من قائمة المواد<br>
        2. اختر بين الفحص الشامل أو محاضرة محددة<br>
        3. أجِب على الأسئلة قبل انتهاء الوقت<br>
        4. استعرض نتائجك في النهاية<br>
        5. يمكنك إعادة الاختبار أو العودة للرئيسية
    `, "info", 7000);
});


// ===================== وظائف إضافية =====================
function startAllSubjectsExam() {
    let allQuestions = [];
    
    // جمع جميع الأسئلة من كل المواد
    Object.values(subjects).forEach(sub => {
        Object.values(sub.lectures).forEach(lec => {
            allQuestions = allQuestions.concat(lec);
        });
    });

    // التحقق من وجود أسئلة
    if (allQuestions.length === 0) {
        showToast("لا توجد أسئلة في النظام!", "warning");
        return;
    }

    if (allQuestions.length < 20) {
        showToast(`تحذير: النظام يحتوي على ${allQuestions.length} سؤال فقط، سيتم تكرار بعض الأسئلة`, "warning", 5000);
        
        let repeatedQuestions = [];
        while (repeatedQuestions.length < 20) {
            repeatedQuestions = repeatedQuestions.concat(allQuestions);
        }
        questions = shuffleArray(repeatedQuestions).slice(0, 20);
    } else {
        questions = shuffleArray(allQuestions).slice(0, 20);
    }

    // إعداد البيانات
    lastSubjectKey = null;
    lastLectureKey = null;
    isFullExam = true;
    examSubjectDisplay.textContent = `الفحص الشامل`;
    examLectureDisplay.textContent = `جميع المواد والمحاضرات`;

    // إعداد المتغيرات
    userAnswers = new Array(questions.length).fill(-1);
    currentQuestion = 0;
    score = 0;
    timeLeft = 20 * 60;
    scoreDisplay.textContent = '0';
    timerDisplay.textContent = '20:00';
    timerDisplay.classList.remove('timer-warning', 'timer-danger');

    // الانتقال لشاشة الاختبار
    lectureScreen.classList.remove('active');
    examScreen.classList.add('active');
    startTimer();
    displayQuestion(0);
}
