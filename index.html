<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>فحص اتمتة - اختبار سريع</title>
     <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
 /* ===== VARIABLES & RESET ===== */
:root {
    --primary: #2d5af1;
    --primary-dark: #1a49e0;
    --secondary: #ff6b6b;
    --accent: #00d4aa;
    --dark: #1a1a2e;
    --darker: #0f0f1a;
    --light: #f8f9fa;
    --gray: #6c757d;
    --success: #28a745;
    --danger: #dc3545;
    --warning: #ffc107;
    --shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
    --shadow-sm: 0 5px 15px rgba(0, 0, 0, 0.2);
    --radius: 20px;
    --radius-sm: 12px;
    --transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.1);
}

* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    font-family: 'Segoe UI', 'Cairo', sans-serif;
}

body {
    background: linear-gradient(135deg, var(--darker) 0%, var(--dark) 100%);
    color: var(--light);
    min-height: 100vh;
    padding: 20px;
    direction: rtl;
}

/* ===== GENERAL SCREEN STYLES ===== */
.screen {
    display: none;
    max-width: 1200px;
    margin: 0 auto;
    padding: 30px;
    animation: fadeIn 0.8s ease-out;
}

.screen.active {
    display: block;
}

@keyframes fadeIn {
    from { opacity: 0; transform: translateY(20px); }
    to { opacity: 1; transform: translateY(0); }
}

@keyframes pulse {
    0% { transform: scale(1); }
    50% { transform: scale(1.05); }
    100% { transform: scale(1); }
}

/* ===== TYPOGRAPHY ===== */
h1 {
    text-align: center;
    font-size: 3.2rem;
    margin-bottom: 2.5rem;
    background: linear-gradient(90deg, var(--accent), var(--primary));
    -webkit-background-clip: text;
    background-clip: text;
    color: transparent;
    text-shadow: 0 5px 15px rgba(45, 90, 241, 0.2);
    padding-bottom: 15px;
    position: relative;
}

h1::after {
    content: '';
    position: absolute;
    bottom: 0;
    right: 50%;
    transform: translateX(50%);
    width: 150px;
    height: 4px;
    background: linear-gradient(90deg, transparent, var(--accent), transparent);
    border-radius: 2px;
}

h2 {
    font-size: 1.8rem;
    line-height: 1.6;
    margin-bottom: 2rem;
    color: var(--light);
    text-align: center;
}

/* ===== BUTTONS ===== */
.btn {
    padding: 18px 35px;
    border: none;
    border-radius: var(--radius-sm);
    font-size: 1.2rem;
    font-weight: 700;
    cursor: pointer;
    transition: var(--transition);
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 12px;
    min-width: 200px;
    margin: 10px auto;
    letter-spacing: 0.5px;
    position: relative;
    overflow: hidden;
    z-index: 1;
}

.btn::before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
    transition: left 0.7s;
    z-index: -1;
}

.btn:hover::before {
    left: 100%;
}

.btn:active {
    transform: translateY(3px);
}

.btn-start {
    background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
    color: white;
    font-size: 1.4rem;
    padding: 22px 50px;
    box-shadow: var(--shadow);
    border: 2px solid rgba(255, 255, 255, 0.1);
}

.btn-start:hover {
    background: linear-gradient(135deg, var(--primary-dark) 0%, #0d3ccf 100%);
    transform: translateY(-5px);
    box-shadow: 0 15px 35px rgba(45, 90, 241, 0.4);
}

.btn-nav {
    background: rgba(255, 255, 255, 0.1);
    color: var(--light);
    backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.15);
}

.btn-nav:hover {
    background: rgba(255, 255, 255, 0.2);
    transform: translateY(-3px);
}

.btn-submit {
    background: linear-gradient(135deg, var(--accent) 0%, #00b894 100%);
    color: var(--darker);
    font-weight: 800;
    box-shadow: var(--shadow-sm);
}

.btn-submit:hover {
    background: linear-gradient(135deg, #00b894 0%, #00a085 100%);
    transform: translateY(-3px);
}

.btn-restart {
    background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
    color: white;
}

.btn-home {
    background: rgba(255, 255, 255, 0.1);
    color: var(--light);
    border: 1px solid rgba(255, 255, 255, 0.2);
}

/* ===== START SCREEN ===== */
#start-screen {
    text-align: center;
    padding-top: 80px;
}

#start-screen h1 {
    font-size: 4rem;
    margin-bottom: 3rem;
    animation: pulse 2s infinite;
}

#start-screen .fa-brain {
    font-size: 4.5rem;
    margin-left: 20px;
    background: linear-gradient(135deg, var(--accent), var(--primary));
    -webkit-background-clip: text;
    background-clip: text;
    color: transparent;
}

/* ===== SUBJECT & LECTURE SCREENS ===== */
#subject-list, #lecture-list {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
    gap: 25px;
    max-width: 1000px;
    margin: 40px auto;
}

.btn-subject, .btn-lecture {
    background: rgba(255, 255, 255, 0.05);
    border: 2px solid rgba(255, 255, 255, 0.1);
    color: var(--light);
    padding: 25px 20px;
    font-size: 1.3rem;
    border-radius: var(--radius);
    cursor: pointer;
    transition: var(--transition);
    display: flex;
    align-items: center;
    justify-content: center;
    text-align: center;
    height: 100%;
    min-height: 140px;
    position: relative;
    overflow: hidden;
}

.btn-subject::after, .btn-lecture::after {
    content: '';
    position: absolute;
    bottom: 0;
    right: 0;
    width: 100%;
    height: 4px;
    background: linear-gradient(90deg, var(--primary), var(--accent));
    transform: scaleX(0);
    transition: transform 0.4s ease;
}

.btn-subject:hover, .btn-lecture:hover {
    background: rgba(255, 255, 255, 0.1);
    transform: translateY(-8px);
    border-color: rgba(255, 255, 255, 0.2);
    box-shadow: var(--shadow);
}

.btn-subject:hover::after, .btn-lecture:hover::after {
    transform: scaleX(1);
}

.btn-lecture:first-child {
    background: linear-gradient(135deg, rgba(45, 90, 241, 0.2), rgba(0, 212, 170, 0.2));
    border: 2px solid var(--primary);
    font-weight: bold;
    grid-column: 1 / -1;
}

.btn-lecture:first-child:hover {
    background: linear-gradient(135deg, rgba(45, 90, 241, 0.3), rgba(0, 212, 170, 0.3));
}

/* ===== EXAM SCREEN ===== */
.header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    background: rgba(255, 255, 255, 0.05);
    padding: 20px 30px;
    border-radius: var(--radius);
    margin-bottom: 40px;
    border: 1px solid rgba(255, 255, 255, 0.1);
    backdrop-filter: blur(10px);
    flex-wrap: wrap;
    gap: 20px;
}

.timer-box, .progress-box, .score-box {
    display: flex;
    align-items: center;
    gap: 12px;
    font-size: 1.3rem;
    padding: 15px 25px;
    border-radius: var(--radius-sm);
    background: rgba(0, 0, 0, 0.3);
    min-width: 200px;
    justify-content: center;
}

.timer-box { color: var(--accent); }
.progress-box { color: var(--primary); }
.score-box { color: var(--warning); }

.fa-clock, .fa-list-ol, .fa-star {
    font-size: 1.8rem;
}

#timer {
    font-family: 'Courier New', monospace;
    font-weight: bold;
    font-size: 1.8rem;
}

.timer-warning { color: var(--warning) !important; animation: pulse 1s infinite; }
.timer-danger { color: var(--danger) !important; animation: pulse 0.5s infinite; }

.question-container {
    background: rgba(255, 255, 255, 0.05);
    border-radius: var(--radius);
    padding: 40px;
    margin-bottom: 40px;
    border: 1px solid rgba(255, 255, 255, 0.1);
    backdrop-filter: blur(10px);
    min-height: 350px;
    display: flex;
    flex-direction: column;
    justify-content: center;
}

.options {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
    gap: 20px;
    margin-top: 30px;
}

.option-btn {
    padding: 22px 25px;
    background: rgba(255, 255, 255, 0.08);
    border: 2px solid rgba(255, 255, 255, 0.15);
    color: var(--light);
    border-radius: var(--radius-sm);
    cursor: pointer;
    transition: var(--transition);
    font-size: 1.2rem;
    text-align: right;
    position: relative;
    overflow: hidden;
}

.option-btn:hover {
    background: rgba(255, 255, 255, 0.15);
    transform: translateY(-5px);
    border-color: var(--primary);
}

.option-btn.selected {
    background: linear-gradient(135deg, rgba(45, 90, 241, 0.3), rgba(0, 212, 170, 0.3));
    border-color: var(--primary);
    color: white;
    box-shadow: 0 8px 25px rgba(45, 90, 241, 0.3);
}

.navigation {
    display: flex;
    justify-content: space-between;
    padding: 20px 0;
    gap: 20px;
    flex-wrap: wrap;
}

/* ===== RESULTS SCREEN ===== */
.result-stats {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
    gap: 25px;
    margin: 40px 0;
}

.result-stats p {
    background: rgba(255, 255, 255, 0.05);
    padding: 25px;
    border-radius: var(--radius);
    font-size: 1.3rem;
    text-align: center;
    border: 1px solid rgba(255, 255, 255, 0.1);
    display: flex;
    flex-direction: column;
    gap: 10px;
}

.result-stats span {
    font-size: 2.2rem;
    font-weight: bold;
    display: block;
}

.result-stats p:nth-child(1) span { color: var(--success); }
.result-stats p:nth-child(2) span { color: var(--danger); }
.result-stats p:nth-child(3) span { color: var(--warning); }
.result-stats p:nth-child(4) span { color: var(--accent); }

#answers-review {
    max-height: 500px;
    overflow-y: auto;
    margin: 40px 0;
    padding: 20px;
    background: rgba(0, 0, 0, 0.2);
    border-radius: var(--radius);
    border: 1px solid rgba(255, 255, 255, 0.1);
}

.answer-item {
    background: rgba(255, 255, 255, 0.05);
    padding: 25px;
    margin-bottom: 20px;
    border-radius: var(--radius-sm);
    border-right: 5px solid var(--gray);
    transition: var(--transition);
}

.answer-item:hover {
    transform: translateX(-10px);
}

.answer-item.correct {
    border-right-color: var(--success);
    background: rgba(40, 167, 69, 0.1);
}

.answer-item.wrong {
    border-right-color: var(--danger);
    background: rgba(220, 53, 69, 0.1);
}

.answer-item.skipped {
    border-right-color: var(--warning);
    background: rgba(255, 193, 7, 0.1);
}

.answer-item strong {
    color: var(--accent);
    font-size: 1.2rem;
    display: block;
    margin-bottom: 10px;
}

.answer-item br {
    margin-bottom: 8px;
    display: block;
    content: "";
}

/* ===== RESPONSIVE DESIGN ===== */
@media (max-width: 992px) {
    h1 { font-size: 2.8rem; }
    .btn { padding: 16px 30px; font-size: 1.1rem; min-width: 180px; }
    #subject-list, #lecture-list { grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); }
    .header { flex-direction: column; text-align: center; }
    .timer-box, .progress-box, .score-box { min-width: 100%; }
    .options { grid-template-columns: 1fr; }
}

@media (max-width: 768px) {
    body { padding: 10px; }
    .screen { padding: 20px 15px; }
    h1 { font-size: 2.4rem; margin-bottom: 2rem; }
    h2 { font-size: 1.5rem; }
    .question-container { padding: 25px; min-height: 300px; }
    .result-stats { grid-template-columns: 1fr; }
    .navigation { flex-direction: column; align-items: center; }
    .btn { width: 100%; max-width: 400px; }
    .btn-subject, .btn-lecture { min-height: 120px; font-size: 1.2rem; }
    #start-screen h1 { font-size: 3rem; }
}

@media (max-width: 480px) {
    h1 { font-size: 2rem; }
    .timer-box, .progress-box, .score-box { font-size: 1.1rem; padding: 12px; }
    #timer { font-size: 1.5rem; }
    .fa-clock, .fa-list-ol, .fa-star { font-size: 1.5rem; }
    .option-btn { padding: 18px 20px; font-size: 1.1rem; }
    .answer-item { padding: 18px; }
    .result-stats p { padding: 20px; font-size: 1.1rem; }
    .result-stats span { font-size: 1.8rem; }
}

/* ===== SCROLLBAR ===== */
::-webkit-scrollbar {
    width: 12px;
}

::-webkit-scrollbar-track {
    background: rgba(255, 255, 255, 0.05);
    border-radius: 10px;
}

::-webkit-scrollbar-thumb {
    background: linear-gradient(var(--primary), var(--accent));
    border-radius: 10px;
    border: 3px solid var(--dark);
}

::-webkit-scrollbar-thumb:hover {
    background: linear-gradient(var(--primary-dark), #00c29a);
}

/* ===== ANIMATIONS & EFFECTS ===== */
.fa-brain {
    animation: float 3s ease-in-out infinite;
}

@keyframes float {
    0%, 100% { transform: translateY(0); }
    50% { transform: translateY(-15px); }
}

/* تأثير النقاط في الخلفية */
body::before {
    content: '';
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-image: 
        radial-gradient(circle at 20% 30%, rgba(45, 90, 241, 0.15) 2px, transparent 2px),
        radial-gradient(circle at 80% 70%, rgba(0, 212, 170, 0.15) 2px, transparent 2px),
        radial-gradient(circle at 40% 80%, rgba(255, 107, 107, 0.1) 1px, transparent 1px);
    background-size: 80px 80px, 100px 100px, 150px 150px;
    z-index: -1;
    pointer-events: none;
}

/* تأثيرات الإجابات الصحيحة/الخاطئة */
.option-btn.correct-feedback {
    animation: correctFlash 0.5s ease;
}

.option-btn.wrong-feedback {
    animation: wrongFlash 0.5s ease;
}

@keyframes correctFlash {
    0%, 100% { background: linear-gradient(135deg, rgba(45, 90, 241, 0.3), rgba(0, 212, 170, 0.3)); }
    50% { background: linear-gradient(135deg, var(--success), #20c997); }
}

@keyframes wrongFlash {
    0%, 100% { background: linear-gradient(135deg, rgba(45, 90, 241, 0.3), rgba(0, 212, 170, 0.3)); }
    50% { background: linear-gradient(135deg, var(--danger), #e35d6a); }
}

/* تأثيرات للنتائج */
#final-score {
    display: inline-block;
    animation: scorePulse 2s infinite;
}

@keyframes scorePulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.1); }
}

.option-btn.correct-answer {
    background-color: #4caf50; /* أخضر */
    color: white;
}

.option-btn.wrong-answer {
    background-color: #f44336; /* أحمر */
    color: white;
}

.option-btn.selected {
    border: 2px solid #2196f3; /* تمييز الاختيار */
}

    </style>
</head>
<body>

    <!-- شاشة البداية -->
    <div id="start-screen" class="screen active">
        <h1><i class="fas fa-brain"></i> فحص اتمتة</h1>
        <button id="start-btn" class="btn btn-start"><i class="fas fa-play"></i> بدء الاختبار</button>
    </div>

    <!-- اختيار المادة -->
    <div id="subject-screen" class="screen">
        <h1>اختر المادة</h1>
        <div id="subject-list"></div>
    </div>

    <!-- اختيار المحاضرة -->
    <div id="lecture-screen" class="screen">
        <h1 id="lecture-title"></h1>
        <div id="lecture-list"></div>
        <button id="back-subjects" class="btn btn-nav">رجوع للمواد</button>
    </div>

    <!-- شاشة الاختبار -->
    <div id="exam-screen" class="screen">
        <div class="header">
            <div class="timer-box"><i class="fas fa-clock"></i> <span id="timer">20:00</span></div>
            <div class="progress-box"><i class="fas fa-list-ol"></i> سؤال <span id="current-q">1</span> من 20</div>
            <div class="score-box"><i class="fas fa-star"></i> النقاط: <span id="score">0</span></div>
        </div>

        <div class="question-container">
            <h2 id="question-text">السؤال يظهر هنا...</h2>
            <div id="options-container" class="options"></div>
        </div>

        <div class="navigation">
            <button id="prev-btn" class="btn btn-nav">السابق</button>
            <button id="next-btn" class="btn btn-nav">التالي</button>
            <button id="submit-btn" class="btn btn-submit">إنهاء الاختبار</button>
        </div>
    </div>

    <!-- شاشة النتائج -->
    <div id="result-screen" class="screen">
        <h1><i class="fas fa-chart-line"></i> نتائج الاختبار</h1>
        <div class="result-stats">
            <p>الإجابات الصحيحة: <span id="correct-count">0</span></p>
            <p>الإجابات الخاطئة: <span id="wrong-count">0</span></p>
            <p>الأسئلة غير المجابة: <span id="skipped-count">0</span></p>
            <p>المعدل النهائي: <span id="final-score">0%</span></p>
        </div>
        <div id="answers-review"></div>
        <button id="restart-btn" class="btn btn-restart">إعادة الاختبار</button>
        <button id="home-btn" class="btn btn-home">العودة للرئيسية</button>
    </div>

    <!-- الأصوات -->
    <audio id="correct-sound" src="correct.mp3"></audio>
    <audio id="wrong-sound" src="wrong.mp3"></audio>

<script>
    // ===================== البيانات =====================
    const subjects = {
        algo2: {
            name: "خوارزميات 2",
            lectures: {
                lec1: [
                 ],
                lec2: [


  {
    "question": "ما هو المبدأ الأساسي الذي تعتمد عليه خوارزمية Heap Sort؟",
    "options": [
      "المقارنة والتبديل بشكل عشوائي",
      "بناء كومة ثنائية واستخراج العناصر حسب حجمها",
      "تقسيم البيانات ودمجها",
      "استخدام قوائم مرتبطة"
    ],
    "correct": 1,
    "explanation": "تعتمد خوارزمية Heap Sort على بناء كومة ثنائية (Max Heap أو Min Heap) ثم استخراج أكبر أو أصغر عنصر بشكل متكرر."
  },
  {
    "question": "ما هو التعقيد الزمني لخوارزمية Heap Sort في المتوسط؟",
    "options": ["O(n)", "O(n log n)", "O(n²)", "O(log n)"],
    "correct": 1,
    "explanation": "تعقيدها الزمني هو O(n log n) في المتوسط وفي أسوأ الحالات."
  },
  {
    "question": "هل تعتبر خوارزمية Heap Sort من الخوارزميات التي تحتاج إلى مساحة إضافية كبيرة؟",
    "options": ["نعم", "لا", "تعتمد على حجم البيانات", "أحياناً"],
    "correct": 1,
    "explanation": "لا، فهي تعمل في المكان (in-place) ولا تحتاج إلى ذاكرة إضافية كبيرة."
  },
  {
    "question": "في Max Heap، أي عنصر يكون دائمًا في الجذر؟",
    "options": ["أصغر عنصر", "أكبر عنصر", "عنصر عشوائي", "العنصر الأول في المصفوفة"],
    "correct": 1,
    "explanation": "في Max Heap يكون أكبر عنصر دائمًا في الجذر."
  },
  {
    "question": "إذا كان لديك عنصر في الموقع i في المصفوفة، فما هو موقع أبوه في الشجرة الثنائية؟",
    "options": ["i/2", "2i", "2i+1", "i-1"],
    "correct": 0,
    "explanation": "موقع الأب هو i/2 (بقسمة صحيحة إذا بدأنا الفهرس من 1)."
  },
  {
    "question": "ما هو موقع الابن الأيسر للعقدة i في الشجرة الثنائية؟",
    "options": ["2i", "2i+1", "i/2", "i-1"],
    "correct": 0,
    "explanation": "الابن الأيسر يكون في الموقع 2i إذا بدأنا الفهرس من 1."
  },
  {
    "question": "ما هو موقع الابن الأيمن للعقدة i في الشجرة الثنائية؟",
    "options": ["2i", "2i+1", "i/2", "i-1"],
    "correct": 1,
    "explanation": "الابن الأيمن يكون في الموقع 2i+1 إذا بدأنا الفهرس من 1."
  },
  {
    "question": "في مرحلة بناء الكومة (Max Heap)، ماذا يجب أن يكون صحيحًا بالنسبة لأي عقدة أب؟",
    "options": [
      "أن تكون أصغر من أولادها",
      "أن تكون أكبر من أولادها",
      "أن تكون مساوية لأولادها",
      "لا توجد علاقة محددة"
    ],
    "correct": 1,
    "explanation": "في Max Heap، كل عقدة أب يجب أن تكون أكبر من أو تساوي أولادها."
  },
  {
    "question": "بعد بناء الكومة، أين يكون أكبر عنصر في المصفوفة؟",
    "options": ["في النهاية", "في البداية", "في المنتصف", "في أي مكان"],
    "correct": 1,
    "explanation": "أكبر عنصر يكون في الجذر، وهو الموقع الأول في المصفوفة إذا اعتبرنا الفهرس يبدأ من 1."
  },
  {
    "question": "في مرحلة الترتيب، ماذا نفعل بالعنصر الموجود في الجذر؟",
    "options": [
      "نتركه في مكانه",
      "نبدله مع آخر عنصر في الكومة",
      "نحذفه",
      "ننقله إلى أولاديه"
    ],
    "correct": 1,
    "explanation": "نبدل العنصر في الجذر (الأكبر) مع آخر عنصر في الكومة، ثم نعيد بناء الكومة على العناصر المتبقية."
  },
  {
    "question": "ما هي المرحلة الأولى في خوارزمية Heap Sort؟",
    "options": ["ترتيب المصفوفة", "بناء الكومة", "دمج العناصر", "تقسيم المصفوفة"],
    "correct": 1,
    "explanation": "المرحلة الأولى هي بناء الكومة (Max Heap أو Min Heap) من المصفوفة غير المرتبة."
  },
  {
    "question": "ما هي المرحلة الثانية في خوارزمية Heap Sort؟",
    "options": ["بناء الكومة", "ترتيب المصفوفة", "تحديد الجذر", "حذف العناصر"],
    "correct": 1,
    "explanation": "المرحلة الثانية هي ترتيب المصفوفة عن طريق استخراج العناصر من الكومة ووضعها في مكانها الصحيح."
  },
  {
    "question": "إذا كانت المصفوفة تحتوي على 10 عناصر، فما هو عدد العقد الورقية في الشجرة الثنائية؟",
    "options": ["5", "6", "10", "4"],
    "correct": 0,
    "explanation": "عدد العقد الورقية في شجرة ثنائية كاملة مع n عقد هو ⌈n/2⌉. بالنسبة لـ 10 عناصر، هو 5."
  },
  {
    "question": "ما هي حالة التوقف في حلقة while أثناء بناء الكومة؟",
    "options": [
      "عندما يصبح الأب أكبر من الابن",
      "عندما نصل إلى الجذر",
      "كلاهما صحيح",
      "عندما يصبح الابن أكبر من الأب"
    ],
    "correct": 2,
    "explanation": "نتوقف إما عندما يصبح الأب أكبر من الابن (الشرط محقق) أو عندما نصل إلى الجذر (s == 1)."
  },
  {
    "question": "في الكود البرمجي، ما هو دور المتحول 'elt'؟",
    "options": [
      "تخزين قيمة العقدة الحالية",
      "تخزين قيمة الجذر",
      "تخزين قيمة الأب",
      "تخزين فهرس الابن"
    ],
    "correct": 0,
    "explanation": "'elt' يخزن قيمة العقدة الحالية التي نريد إدراجها في المكان المناسب في الكومة."
  },
  {
    "question": "ماذا يمثل المتحول 's' في الكود البرمجي؟",
    "options": ["فهرس الأب", "فهرس الابن", "قيمة العقدة", "حجم المصفوفة"],
    "correct": 1,
    "explanation": "'s' يمثل فهرس الابن (الموقع الحالي الذي نتحرك فيه خلال الكومة)."
  },
  {
    "question": "ماذا يمثل المتحول 'f' في الكود البرمجي؟",
    "options": ["فهرس الأب", "فهرس الابن", "قيمة العقدة", "حجم المصفوفة"],
    "correct": 0,
    "explanation": "'f' يمثل فهرس الأب (الموقع الأب للعقدة الحالية)."
  },
  {
    "question": "في مرحلة الترتيب، لماذا نبدأ الحلقة من n إلى 2؟",
    "options": [
      "لأن العنصر الأول لا يحتاج ترتيب",
      "لأننا نضع العناصر الكبيرة في النهاية",
      "لأن الكومة تصغر مع كل خطوة",
      "جميع ما سبق"
    ],
    "correct": 3,
    "explanation": "نبدأ من n إلى 2 لأننا نضع العنصر الأكبر (الجذر) في النهاية، ثم نعيد بناء الكومة على العناصر المتبقية (n-1)، وهكذا."
  },
  {
    "question": "ما هو دور الشرط (s > 1) في حلقة while أثناء بناء الكومة؟",
    "options": [
      "ضمان ألا نتجاوز حدود المصفوفة",
      "منع الوصول إلى الجذر",
      "السماح بالاستمرار طالما لم نصل إلى الجذر",
      "لا شيء مما سبق"
    ],
    "correct": 2,
    "explanation": "(s > 1) يضمن أننا لم نصل إلى الجذر بعد، لأن الجذر ليس له أب."
  },
  {
    "question": "ماذا يحدث إذا كان الأب أصغر من الابن في Max Heap أثناء البناء؟",
    "options": [
      "يتم تبديل قيمتهما",
      "يتم حذف الابن",
      "تتوقف الخوارزمية",
      "يتم تجاهل الخطأ"
    ],
    "correct": 0,
    "explanation": "يتم تبديل قيمة الأب مع الابن لتحقيق خاصية الكومة (الأب أكبر من الأبناء)."
  },
  {
    "question": "هل يمكن استخدام Heap Sort لفرز البيانات المرتبطة بقوائم؟",
    "options": ["نعم", "لا", "فقط إذا كانت القوائم صغيرة", "فقط إذا كانت القوائم مرتبة جزئياً"],
    "correct": 1,
    "explanation": "Heap Sort مصمم للمصفوفات بسبب اعتماده على الفهرس للوصول إلى الأب والأبناء، مما يصعب تطبيقه مباشرة على القوائم المرتبطة."
  },
  {
    "question": "ما هي إحدى المميزات الرئيسية لـ Heap Sort؟",
    "options": [
      "تعقيد زمني ثابت O(1)",
      "لا تحتاج إلى ذاكرة إضافية (in-place)",
      "أسرع دائماً من Quick Sort",
      "تستخدم فقط للبيانات الصغيرة"
    ],
    "correct": 1,
    "explanation": "إحدى مميزات Heap Sort هي أنها تعمل في المكان (in-place)، أي لا تحتاج إلى مساحة إضافية كبيرة."
  },
  {
    "question": "في Min Heap، أين يكون أصغر عنصر؟",
    "options": ["في الجذر", "في النهاية", "في أي مكان", "في منتصف المصفوفة"],
    "correct": 0,
    "explanation": "في Min Heap، يكون أصغر عنصر دائمًا في الجذر."
  },
  {
    "question": "إذا أردنا ترتيب تصاعدي، أي نوع من الكومة نستخدم عادةً؟",
    "options": ["Min Heap", "Max Heap", "كليهما", "لا يهم"],
    "correct": 1,
    "explanation": "نستخدم Max Heap عادةً للترتيب التصاعدي، حيث نستخرج أكبر عنصر أولاً ونضعه في النهاية."
  },
  {
    "question": "كم مرة نعيد بناء الكومة في مرحلة الترتيب؟",
    "options": ["n مرة", "n-1 مرة", "log n مرة", "مرة واحدة"],
    "correct": 1,
    "explanation": "نعيد بناء الكومة n-1 مرة، لأن بعد وضع كل عنصر في مكانه الصحيح، نعيد بناء الكومة على العناصر المتبقية."
  },
  {
    "question": "ما هو الشرط الرئيسي للخروج من حلقة while في مرحلة الترتيب؟",
    "options": [
      "عندما يصبح lValue أكبر من value",
      "عندما نصل إلى عقدة ورقية",
      "عندما ندخل مرحلة الترتيب (من خلال شرطين if)",
      "جميع ما سبق"
    ],
    "correct": 2,
    "explanation": "الشرط الرئيسي للخروج هو عندما ندخل مرحلة الترتيب، أي عندما لا يتحقق شرطا if الخاصين بمقارنة الأخوة أو عندما نصل إلى عقدة مرتبة."
  },
  {
    "question": "في الكود، ما هو دور الشرط (s + 1 <= i - 1)؟",
    "options": [
      "للتحقق من وجود أخ أيمن",
      "للتحقق من وجود أخ أيسر",
      "للتحقق من حدود المصفوفة",
      "للتحقق من أن الفهرس صحيح"
    ],
    "correct": 0,
    "explanation": "هذا الشرط يتحقق من وجود أخ أيمن (الابن الأيمن) ضمن حدود الكومة الحالية (i-1) أثناء عملية إعادة البناء في مرحلة الترتيب."
  },
  {
    "question": "ما الذي يمثله 'i' في الحلقة التنازلية؟",
    "options": [
      "فهرس آخر عنصر في الكومة الحالية",
      "فهرس الجذر",
      "حجم المصفوفة الأصلي",
      "عدد الخطوات المتبقية"
    ],
    "correct": 0,
    "explanation": "'i' يمثل فهرس آخر عنصر في الكومة الحالية غير المرتبة، حيث نضع فيه العنصر الأكبر (الجذر) ثم نقلص الكومة."
  },
  {
    "question": "لماذا نستخدم (s = 0) في بعض الأحيان في الكود؟",
    "options": [
      "لتهيئة الفهرس",
      "لكسر حلقة while",
      "للدلالة على نهاية الكومة",
      "جميع ما سبق"
    ],
    "correct": 1,
    "explanation": "تعيين s = 0 يستخدم لكسر حلقة while عندما ندخل مرحلة الترتيب أو عندما ننتهي من المقارنات."
  },
  {
    "question": "ما هو نوع البيانات الذي تعمل عليه خوارزمية Heap Sort بشكل أساسي؟",
    "options": ["المصفوفات", "القوائم المرتبطة", "الأشجار", "الملفات"],
    "correct": 0,
    "explanation": "تعمل بشكل أساسي على المصفوفات بسبب الحاجة إلى وصول عشوائي وفهارس لحساب العلاقات بين الأب والأبناء."
  },
  {
    "question": "هل يمكن أن تحتوي الشجرة الثنائية الكاملة على عقدة فارغة في المنتصف؟",
    "options": ["نعم", "لا", "فقط إذا كانت الشجرة غير كاملة", "فقط في الجذر"],
    "correct": 1,
    "explanation": "لا، في الشجرة الثنائية الكاملة التي تمثل كومة، لا يمكن أن تكون هناك عقدة فارغة في المنتصف. العقد الفارغة المسموح بها فقط في المستوى الأخير على اليمين."
  },
  {
    "question": "ما هو الهدف من السطر `x[s] = elt;` في نهاية حلقة البناء؟",
    "options": [
      "لحذف قيمة العقدة",
      "لوضع قيمة العقدة في مكانها النهائي الصحيح في الكومة",
      "لتبديل الأب والابن",
      "لتهيئة المصفوفة"
    ],
    "correct": 1,
    "explanation": "بعد انتهاء حلقة while التي ترفع العنصر لأعلى، نضع قيمة `elt` في الموقع `s` (الموقع الذي وجدنا أنه المناسب لها في الكومة)."
  },
  {
    "question": "في مرحلة الترتيب، ماذا يمثل `lValue`؟",
    "options": [
      "قيمة الجذر الأصلي",
      "قيمة العنصر المخزن من آخر عقدة",
      "قيمة أكبر ابن",
      "قيمة الأب"
    ],
    "correct": 1,
    "explanation": "`lValue` يخزن قيمة العنصر الذي أخذناه من آخر عقدة في الكومة (العقدة i) قبل وضع الجذر فيها."
  },
  {
    "question": "ما هو دور `value` في مرحلة الترتيب؟",
    "options": [
      "تخزين قيمة الجذر",
      "تخزين قيمة أكبر ابن للعقدة الفارغة",
      "تخزين قيمة العنصر المراد إدراجه",
      "تخزين فهرس العقدة الحالية"
    ],
    "correct": 1,
    "explanation": "`value` يخزن قيمة أكبر ابن للعقدة الفارغة الحالية (f) أثناء عملية إعادة بناء الكومة للأسفل."
  },
  {
    "question": "لماذا نقارن `lValue` مع `value` في مرحلة الترتيب؟",
    "options": [
      "لاختيار أي قيمة نضع في الجذر",
      "لتحديد ما إذا كنا بحاجة لدفع `lValue` للأسفل أكثر",
      "لحساب التعقيد الزمني",
      "لا شيء مما سبق"
    ],
    "correct": 1,
    "explanation": "نقارن `lValue` (العنصر الذي نريد وضعه في المكان الصحيح) مع `value` (أكبر ابن للعقدة الفارغة) لنقرر إذا كان `lValue` أصغر، فيجب أن يهبط أكثر، وإلا فقد وجد مكانه."
  },
  {
    "question": "ما معنى أن الكومة 'كاملة'؟",
    "options": [
      "أن جميع المستويات مليئة بالعقد",
      "أن جميع العقد لها أب وابن",
      "أنها مرتبة تصاعدياً",
      "أنها تحتوي على أكبر عدد ممكن من العناصر"
    ],
    "correct": 0,
    "explanation": "شجرة ثنائية كاملة تعني أن جميع المستويات مليئة بالعقد تماماً، ما عدا المستوى الأخير الذي قد يكون مملوءاً من اليسار إلى اليمين."
  },
  {
    "question": "هل يمكن تطبيق Heap Sort على البيانات المكررة؟",
    "options": ["نعم", "لا", "فقط إذا كانت مكررة مرتين", "فقط إذا استخدمنا Min Heap"],
    "correct": 0,
    "explanation": "نعم، يمكنها التعامل مع البيانات المكررة، حيث أن خاصية الكومة تسمح بالمساواة بين الأب والأبناء."
  },
  {
    "question": "ما هو تعقيد بناء الكومة من مصفوفة غير مرتبة؟",
    "options": ["O(n)", "O(n log n)", "O(log n)", "O(n²)"],
    "correct": 0,
    "explanation": "بناء الكومة له تعقيد خطي O(n)، وليس O(n log n) كما قد يبدو."
  },
  {
    "question": "إذا بدأنا فهرسة المصفوفة من 0، فما هو موقع الابن الأيسر للعقدة i؟",
    "options": ["2i+1", "2i+2", "i/2", "(i-1)/2"],
    "correct": 0,
    "explanation": "عند البدء من 0، الابن الأيسر يكون في الموقع 2i+1."
  },
  {
    "question": "إذا بدأنا فهرسة المصفوفة من 0، فما هو موقع الأب للعقدة i؟",
    "options": ["(i-1)/2", "i/2", "2i+1", "2i"],
    "correct": 0,
    "explanation": "عند البدء من 0، موقع الأب هو (i-1)/2 (بقسمة صحيحة)."
  },
  {
    "question": "ما هي إحدى تطبيقات Heap Sort العملية؟",
    "options": [
      "ترتيب قوائم الانتظار",
      "إدارة ذاكرة الوصول العشوائي",
      "فرز البيانات في قواعد البيانات الكبيرة",
      "ضغط الملفات"
    ],
    "correct": 2,
    "explanation": "تستخدم في تطبيقات مثل فرز البيانات في قواعد البيانات ومعالجة البيانات الضخمة بسبب كفاءتها وتوازنها بين السرعة والذاكرة."
  },
  {
    "question": "ما هو الفرق الأساسي بين Selection Sort و Heap Sort؟",
    "options": [
      "لا يوجد فرق",
      "Heap Sort تستخدم كومة للعثور على العنصر التالي بسرعة",
      "Selection Sort أسرع",
      "Heap Sort تحتاج إلى ذاكرة إضافية"
    ],
    "correct": 1,
    "explanation": "كلتاهما تعتمدان على إيجاد العنصر الأكبر/الأصغر، ولكن Heap Sort تستخدم هيكل الكومة للعثور عليه في O(log n) بدلاً من O(n) في كل مرة، مما يجعلها أسرع بكثير."
  },
  {
    "question": "متى تكون خوارزمية Heap Sort مفضلة عن Quick Sort؟",
    "options": [
      "عندما يكون تعقيد الذاكرة مهماً",
      "عندما نريد أسوأ حالة مضمونة O(n log n)",
      "عند التعامل مع بيانات كبيرة جداً",
      "جميع ما سبق"
    ],
    "correct": 3,
    "explanation": "Heap Sort مفضلة عندما: 1) الذاكرة محدودة (in-place). 2) نريد ضمان أداء O(n log n) في أسوأ الحالات (عكس Quick Sort). 3) في بعض حالات البيانات الضخمة."
  },
  {
    "question": "في الكود، ما هو هدف السطور من 40 إلى 44؟",
    "options": [
      "بناء الكومة",
      "معالجة حالة خاصة عندما i == 2",
      "تحديد أكبر ابن",
      "إنهاء الخوارزمية"
    ],
    "correct": 1,
    "explanation": "هذه السطور تهيئ قيمة `s` بشكل مختلف في الحالة الخاصة عندما i == 2، ربما لمعالجة حالة حدودية في مرحلة الترتيب أو لكسر الحلقة."
  },
  {
    "question": "ما هو الخطأ المحتمل إذا نسينا تحديث `f` داخل حلقة while أثناء البناء؟",
    "options": [
      "ستدخل الحلقة في تكرار لا نهائي",
      "ستتوقف الخوارزمية",
      "سيتم فرز المصفوفة بشكل خاطئ",
      "لن يتأثر الأمر"
    ],
    "correct": 0,
    "explanation": "إذا لم يتم تحديث `f` (فهرس الأب) داخل الحلقة، فلن نتقدم نحو الجذر، وقد تستمر المقارنة مع نفس الأب بشكل لا نهائي إذا كان الشرط لا يزال محققاً."
  },
  {
    "question": "لماذا لا نبدأ حلقة البناء من i = 1؟",
    "options": [
      "لأن الجذر ليس له أب",
      "لأنه لا داعي لمعالجة العنصر الأول",
      "لأن الفهرس يبدأ من 1",
      "لأنه سيسبب خطأ في الفهرس"
    ],
    "correct": 1,
    "explanation": "العنصر الأول (i=1) هو الجذر، وليس له أب لمقارنته به، لذلك نبدأ من i=2."
  },
  {
    "question": "ما هي القيمة التي يجب أن يكون عليها `s` للدلالة على أننا نريد كسر حلقة المقارنة في مرحلة الترتيب؟",
    "options": ["0", "1", "-1", "i"],
    "correct": 0,
    "explanation": "في الكود المقدم، يتم تعيين `s = 0` للإشارة إلى أنه يجب كسر حلقة while، إما لأننا دخلنا مرحلة الترتيب أو لأننا انتهينا."
  },
  {
    "question": "في مرحلة الترتيب، لماذا نتحقق من الشرط `if (s < i)`؟",
    "options": [
      "للتأكد من أن الابن ضمن الكومة غير المرتبة",
      "للتأكد من أن الابن موجود",
      "لمنع تجاوز حدود المصفوفة",
      "جميع ما سبق"
    ],
    "correct": 3,
    "explanation": "هذا الشرط يتأكد من أن فهرس الابن `s` أقل من `i`، مما يعني أنه لا يزال ضمن نطاق الكومة الحالية التي لم يتم ترتيبها بعد."
  },
  {
    "question": "ما هي الخاصية التي يجب أن تتحقق بعد كل خطوة في مرحلة الترتيب؟",
    "options": [
      "أن تكون المصفوفة مرتبة تماماً",
      "أن تكون خاصية الكومة محققة للعناصر غير المرتبة",
      "أن يكون الجذر دائماً هو i",
      "أن يكون آخر عنصر هو الأصغر"
    ],
    "correct": 1,
    "explanation": "بعد وضع أكبر عنصر في نهاية الكومة وإعادة البناء، يجب أن تظل خاصية الكومة (الأب أكبر من الأبناء) محققة للجزء غير المرتب من المصفوفة."
  },
  {
    "question": "إذا كانت المصفوفة مرتبة بالفعل تصاعدياً، ما هو تعقيد Heap Sort؟",
    "options": ["O(n)", "O(n log n)", "O(log n)", "O(n²)"],
    "correct": 1,
    "explanation": "تعقيد Heap Sort يبقى O(n log n) حتى في أفضل حالة (مصفوفة مرتبة)، لأن بناء الكومة وإعادة البناء يتطلبان log n عمليات لكل عنصر."
  },
  {
    "question": "هل يمكن لـ Heap Sort أن تعمل على بيانات ليست أرقاماً؟",
    "options": ["نعم، على أي نوع قابل للمقارنة", "لا، أرقام فقط", "نعم، على النصوص فقط", "نعم، على المصفوفات فقط"],
    "correct": 0,
    "explanation": "نعم، يمكنها العمل على أي نوع بيانات يمكن تعريف علاقة ترتيب عليه (مقارنة أكبر من/أصغر من)، مثل النصوص أو التواريخ."
  },
  {
    "question": "ما هو الغرض من متحول مؤقت مثل `elt` أو `lValue`؟",
    "options": [
      "لحفظ قيمة قد يتم الكتابة فوقها",
      "لتقليل استخدام الذاكرة",
      "لتسريع المقارنات",
      "لجعل الكود معقداً"
    ],
    "correct": 0,
    "explanation": "يستخدم المتحول المؤقت لحفظ قيمة عنصر قبل نقل قيم أخرى إلى موقعه، لتجنب فقدانها أثناء عمليات التبديل والإزاحة."
  },
  {
    "question": "في الشجرة الثنائية، إذا كانت العقدة في الفهرس 7، فما هو رقم أبويها؟",
    "options": ["3", "4", "2", "1"],
    "correct": 0,
    "explanation": "الأب للعقدة 7 هو 7/2 = 3 (بقسمة صحيحة)."
  },
  {
    "question": "إذا كانت العقدة 3 هي أب، فما هي أرقام أولادها؟",
    "options": ["6 و 7", "1 و 2", "4 و 5", "8 و 9"],
    "correct": 0,
    "explanation": "الأبناء للعقدة 3 هما 2*3=6 و 2*3+1=7."
  },
  {
    "question": "ماذا يسمى المستوى الأخير من الشجرة الثنائية الكاملة؟",
    "options": ["مستوى الأوراق", "مستوى الجذر", "المستوى المتوسط", "مستوى الفروع"],
    "correct": 0,
    "explanation": "يسمى مستوى الأوراق، لأنه يحتوي على العقد التي ليس لها أبناء (أو بعضها قد يكون له ابن أيسر فقط)."
  },
  {
    "question": "كم مستوى تقريباً في شجرة ثنائية كاملة تحتوي على n عقدة؟",
    "options": ["log₂(n) + 1", "n/2", "n", "√n"],
    "correct": 0,
    "explanation": "عدد المستويات هو ⌊log₂(n)⌋ + 1 تقريباً."
  },
  {
    "question": "ما هو الاستخراج الأول من Max Heap بعد بنائه؟",
    "options": ["أكبر عنصر", "أصغر عنصر", "عنصر الجذر", "العنصر الأول والثاني"],
    "correct": 2,
    "explanation": "أول عنصر نستخرجه هو عنصر الجذر، والذي هو أكبر عنصر في Max Heap."
  },
  {
    "question": "بعد استخراج الجذر، ماذا نفعل بالكومة؟",
    "options": [
      "نحذفها",
      "نأخذ آخر عنصر ونضعه في الجذر، ثم نعيد بناء الكومة",
      "نبدأ من جديد",
      "نقوم بفرز العناصر المتبقية يدوياً"
    ],
    "correct": 1,
    "explanation": "نأخذ آخر عنصر في الكومة (ورقة) ونضعه في الجذر، ثم ننزله لأسفل (`heapify-down`) لاستعادة خاصية الكومة."
  },
  {
    "question": "ما هو الحد الأقصى لعدد المقارنات اللازمة لـ heapify-down (إعادة بناء الكومة للأسفل)؟",
    "options": ["O(1)", "O(log n)", "O(n)", "O(n log n)"],
    "correct": 1,
    "explanation": "في أسوأ الحالات، قد يحتاج العنصر المرسل إلى الجذر للنزول عبر كل المستويات إلى مستوى الورقة، مما يتطلب O(log n) مقارنات."
  },
  {
    "question": "هل يمكن تنفيذ خوارزمية Heap Sort بطريقة متكررة (Recursive)؟",
    "options": ["نعم", "لا", "فقط لبناء الكومة", "فقط لمرحلة الترتيب"],
    "correct": 0,
    "explanation": "نعم، يمكن كتابة الدالة `heapify` (التي تصلح الكومة) بشكل متكرر، حيث تستدعي نفسها على الابن المناسب."
  },
  {
    "question": "ما هو العيب الرئيسي لـ Heap Sort مقارنة بـ Quick Sort؟",
    "options": [
      "تعقيدها الزمني أسوأ",
      "عادة ما تكون أبطأ عملياً بسبب ثوابتها الأعلى",
      "لا تعمل في المكان",
      "لا يمكنها التعامل مع البيانات الكبيرة"
    ],
    "correct": 1,
    "explanation": "على الرغم من أن كلا الخوارزميتين لهما تعقيد O(n log n) في المتوسط، فإن Heap Sort لها ثوابت أعلى (عمليات أكثر في كل خطوة) مما يجعلها أبطأ عملياً من Quick Sort في معظم الحالات."
  },
  {
    "question": "ما هو دور الشرط `if (i > 3) && (x[3] > x[2])` في الكود (السطر 47)؟",
    "options": [
      "لمقارنة الابن الأيمن والأيسر للجذر",
      "لاختيار أكبر ابن للعقدة 1",
      "لاختيار أكبر ابن للعقدة 2",
      "معالجة حالة خاصة عندما يكون حجم الكومة صغيراً"
    ],
    "correct": 1,
    "explanation": "يبدو أن هذا الشرط يتحقق من أن الابن الأيمن (العقدة 3) أكبر من الابن الأيسر (العقدة 2) عند البدء في مرحلة الترتيب، لتحديد من هو الابن الأكبر للجذر (العقدة 1)."
  },
  {
    "question": "ما هو المخرج النهائي لخوارزمية Heap Sort على المصفوفة [7, 2, 9, 3, 4, 10, 12, 15, 13]؟",
    "options": [
      "[2, 3, 4, 7, 9, 10, 12, 13, 15]",
      "[15, 13, 12, 10, 9, 7, 4, 3, 2]",
      "[2, 3, 4, 7, 9, 10, 12, 15, 13]",
      "[15, 13, 12, 9, 10, 7, 4, 3, 2]"
    ],
    "correct": 0,
    "explanation": "بعد تطبيق Heap Sort للترتيب التصاعدي، ستكون المصفوفة النهائية مرتبة من الأصغر إلى الأكبر."
  }



                    
                 ],
                lec3: [
{ question: "في خوارزمية هوفمان، أين توضع الأحرف؟", 
   options: ["في العقد غير الورقية", "في الجذر فقط", "في الأوراق", "في الفروع"], 
   correct: 2,
   explanation: "الأحرف توضع في الأوراق فقط." },

 { question: "ما الهدف الأساسي من خوارزمية هوفمان؟", 
   options: ["ترتيب الأحرف", "ضغط البيانات بأقصر تمثيل ثنائي", "تشفير النص بكلمة سر", "بناء شجرة بحث"], 
   correct: 1,
   explanation: "الهدف هو ضغط البيانات بحيث يكون لكل حرف تمثيل ثنائي أقصر حسب تكراره." },

 { question: "في شجرة هوفمان، الحرف الأكثر تكراراً يكون:", 
   options: ["أبعد عن الجذر", "في المنتصف", "أقرب إلى الجذر", "ليس له علاقة"], 
   correct: 2,
   explanation: "الحروف الأكثر تكراراً توضع أقرب للجذر لتقصير طول الشيفرة." },

 { question: "عدد عقد شجرة هوفمان إذا كان عدد الأحرف n يساوي:", 
   options: ["n", "2n", "2n - 1", "n - 1"], 
   correct: 2,
   explanation: "شجرة هوفمان تحتوي على 2n-1 عقد إذا كان عدد الأحرف n." },

 { question: "لماذا لا يجوز أن تكون شيفرة حرف بداية لشيفرة حرف آخر؟", 
   options: ["لتقليل الذاكرة", "لمنع الغموض عند فك التشفير", "لتسريع البحث", "لأنه شرط شكلي"], 
   correct: 1,
   explanation: "لكي لا يكون هناك غموض عند فك الشيفرة." },


 // ============================
 // المرحلة 2: التكرار والاختيار
 // ============================

 { question: "في كل خطوة من بناء شجرة هوفمان نختار:", 
   options: ["أكبر تكرارين", "أصغر تكرارين غير مستخدمين", "أي عقدتين", "العقد الورقية فقط"], 
   correct: 1,
   explanation: "نختار أصغر عقدتين غير مستخدمتين لدمجهما." },

 { question: "إذا كانت التكرارات: a=5 , b=2 , c=1 , d=1 فما أول عقدتين يتم دمجهما؟", 
   options: ["a و b", "c و d", "a و c", "b و c"], 
   correct: 1,
   explanation: "أصغر تكرارين هما c و d، لذا ندمجهما أولاً." },

 { question: "تكرار العقدة الأب يساوي:", 
   options: ["أكبر تكرار بين الأبناء", "أصغر تكرار", "مجموع تكراري الابنين", "عدد العقد"], 
   correct: 2,
   explanation: "تكرار العقدة الأب يساوي مجموع تكراري الابنين." },

 { question: "العقد التي لها del = true هي:", 
   options: ["العقد المحذوفة", "العقد المستخدمة", "العقد المتاحة للاختيار", "العقد الجذر"], 
   correct: 2,
   explanation: "del = true تعني أن العقدة تم اختيارها أو مستخدمة." },

 { question: "بعد اختيار عقدة بواسطة findminfreq فإن del تصبح:", 
   options: ["true", "false", "null", "1"], 
   correct: 1,
   explanation: "بعد الاختيار تصبح del = false لتمييز أنها مستخدمة." },


 // ============================
 // المرحلة 3: التمثيل بالمصفوفة
 // ============================

 { question: "تمثيل شجرة هوفمان في البرنامج يتم باستخدام:", 
   options: ["مصفوفة عقد", "مصفوفة محارف", "Stack", "Queue"], 
   correct: 0,
   explanation: "يتم تمثيل الشجرة باستخدام مصفوفة العقد." },

 { question: "الحقل father في العقدة يشير إلى:", 
   options: ["عدد الأبناء", "تكرار الأب", "دليل العقدة الأب", "يمين أو يسار"], 
   correct: 2,
   explanation: "father يخزن فهرس العقدة الأب لكل عقدة." },

 { question: "الحقل isLeft يدل على:", 
   options: ["هل العقدة ورقة", "هل العقدة يسارية", "هل العقدة مستخدمة", "هل هي جذر"], 
   correct: 1,
   explanation: "isLeft يحدد إذا كانت العقدة الابنة يسارية أم لا." },

 { question: "الجذر في شجرة هوفمان يكون عند الفهرس:", 
   options: ["0", "n", "2n-2", "2n-1"], 
   correct: 2,
   explanation: "الجذر يكون عند الفهرس 2n-2 في تمثيل المصفوفة." },

 { question: "عدد العقد الورقية في شجرة هوفمان يساوي:", 
   options: ["n", "2n-1", "n-1", "2n"], 
   correct: 0,
   explanation: "عدد العقد الورقية يساوي عدد الأحرف n." },


 // ============================
 // المرحلة 4: الترميز (Code)
 // ============================

 { question: "عند الصعود من ابن يساري إلى الأب نضيف:", 
   options: ["1", "0", "لا شيء", "حسب التكرار"], 
   correct: 1,
   explanation: "نضيف 0 عند الصعود من ابن يساري." },

 { question: "عند الصعود من ابن يميني إلى الأب نضيف:", 
   options: ["0", "1", "حسب العمق", "لا شيء"], 
   correct: 1,
   explanation: "نضيف 1 عند الصعود من ابن يميني." },

 { question: "يتم توليد شيفرة الحرف بالتحرك من:", 
   options: ["الجذر إلى الورقة", "الورقة إلى الجذر", "اليمين إلى اليسار", "اليسار إلى اليمين"], 
   correct: 1,
   explanation: "نبدأ من الورقة إلى الجذر لتوليد الشيفرة." },

 { question: "تخزن الشيفرة في:", 
   options: ["node", "symbol", "CodeType", "alph"], 
   correct: 2,
   explanation: "الشيفرة تخزن في هيكل CodeType." },

 { question: "startPos في CodeType يدل على:", 
   options: ["عدد البتات", "بداية الشيفرة داخل المصفوفة", "نهاية الشيفرة", "طول الرسالة"], 
   correct: 1,
   explanation: "startPos يحدد بداية الشيفرة في مصفوفة البتات." },


 // ============================
 // المرحلة 5: خصائص الشيفرة
 // ============================

 { question: "شيفرة هوفمان هي:", 
   options: ["ثابتة الطول", "متغيرة الطول", "عشوائية", "ثلاثية"], 
   correct: 1,
   explanation: "شيفرة هوفمان متغيرة الطول حسب تكرار الحروف." },

 { question: "الأحرف الأقل تكراراً يكون لها:", 
   options: ["أقصر شيفرة", "أطول شيفرة", "نفس الطول", "بدون شيفرة"], 
   correct: 1,
   explanation: "الأحرف الأقل تكراراً لها أطول شيفرة." },

 { question: "إذا تغيرت التكرارات فإن:", 
   options: ["الشيفرة تبقى نفسها", "الشجرة تتغير", "الجذر فقط يتغير", "لا شيء يتغير"], 
   correct: 1,
   explanation: "تغيير التكرارات يغير الشجرة وبالتالي الشيفرة." },

 { question: "سبب أن شيفرة هوفمان تضغط البيانات هو:", 
   options: ["تستخدم 0 و 1 فقط", "تعطي الأقصر للأكثر تكراراً", "تلغي بعض الأحرف", "تعيد ترتيب النص"], 
   correct: 1,
   explanation: "الشيفرة تعطي رموز أقصر للحروف الأكثر تكراراً." },

 { question: "هل يمكن أن يكون حرفان لهما نفس الشيفرة؟", 
   options: ["نعم", "لا", "أحياناً", "حسب التكرار"], 
   correct: 1,
   explanation: "لا، كل حرف له شيفرة فريدة لتجنب الغموض." }
                ],
                lec4:[
 
                ]
            }
        },
        circuits: {
            name: "نظرية المخططات",
            lectures: {
                lec1: [
                 ]
            }
        }
    };

    let currentQuestion = 0;
    let userAnswers = [];
    let score = 0;
    let timer;
    let timeLeft = 20 * 60;
    let questions = [];

    // عناصر DOM
    const startScreen = document.getElementById('start-screen');
    const subjectScreen = document.getElementById('subject-screen');
    const lectureScreen = document.getElementById('lecture-screen');
    const examScreen = document.getElementById('exam-screen');
    const resultScreen = document.getElementById('result-screen');
    const startBtn = document.getElementById('start-btn');
    const timerDisplay = document.getElementById('timer');
    const currentQDisplay = document.getElementById('current-q');
    const scoreDisplay = document.getElementById('score');
    const questionText = document.getElementById('question-text');
    const optionsContainer = document.getElementById('options-container');
    const prevBtn = document.getElementById('prev-btn');
    const nextBtn = document.getElementById('next-btn');
    const submitBtn = document.getElementById('submit-btn');
    const correctSound = document.getElementById('correct-sound');
    const wrongSound = document.getElementById('wrong-sound');
    const correctCountDisplay = document.getElementById('correct-count');
    const wrongCountDisplay = document.getElementById('wrong-count');
    const skippedCountDisplay = document.getElementById('skipped-count');
    const finalScoreDisplay = document.getElementById('final-score');
    const answersReview = document.getElementById('answers-review');
    const restartBtn = document.getElementById('restart-btn');
    const homeBtn = document.getElementById('home-btn');
    const subjectList = document.getElementById('subject-list');
    const lectureList = document.getElementById('lecture-list');
    const lectureTitle = document.getElementById('lecture-title');
    const backSubjectsBtn = document.getElementById('back-subjects');

    // ===================== وظائف اختيار المادة والمحاضرة =====================
    function showSubjects() {
        subjectList.innerHTML = '';
        Object.keys(subjects).forEach(subKey => {
            const sub = subjects[subKey];
            const btn = document.createElement('button');
            btn.textContent = sub.name;
            btn.className = 'btn-subject';
            btn.addEventListener('click', () => showLectures(subKey));
            subjectList.appendChild(btn);
        });
        startScreen.classList.remove('active');
        subjectScreen.classList.add('active');
    }

   function showLectures(subKey) {
    const sub = subjects[subKey];
    lectureTitle.textContent = sub.name;
    lectureList.innerHTML = '';

    // زر الفحص الشامل لجميع المحاضرات
    const fullExamBtn = document.createElement('button');
    fullExamBtn.textContent = `فحص شامل لجميع المحاضرات`;
    fullExamBtn.className = 'btn-lecture';
    fullExamBtn.addEventListener('click', () => startFullExam(subKey));
    lectureList.appendChild(fullExamBtn);

    // عرض المحاضرات العادية
    Object.keys(sub.lectures).forEach(lecKey => {
        const btn = document.createElement('button');
        btn.textContent = `المحاضرة ${lecKey.replace('lec','')}`;
        btn.className = 'btn-lecture';
        btn.addEventListener('click', () => startLecture(subKey, lecKey));
        lectureList.appendChild(btn);
    });

    subjectScreen.classList.remove('active');
    lectureScreen.classList.add('active');
}

// وظيفة فحص شامل لجميع المحاضرات
function startFullExam(subKey) {
    const allLectures = subjects[subKey].lectures;
    let allQuestions = [];
    Object.values(allLectures).forEach(lec => {
        allQuestions = allQuestions.concat(lec);
    });

    questions = shuffleArray(allQuestions).slice(0, 20); // نأخذ 20 سؤال عشوائي
    userAnswers = new Array(questions.length).fill(-1);
    currentQuestion = 0;
    score = 0;
    timeLeft = 20 * 60;
    scoreDisplay.textContent = '0';
    timerDisplay.textContent = '20:00';
    timerDisplay.classList.remove('timer-warning', 'timer-danger');

    lectureScreen.classList.remove('active');
    examScreen.classList.add('active');
    startTimer();
    displayQuestion(0);
}


    backSubjectsBtn.addEventListener('click', () => {
        lectureScreen.classList.remove('active');
        subjectScreen.classList.add('active');
    });

    function startLecture(subKey, lecKey) {
        const allQuestions = subjects[subKey].lectures[lecKey];
        questions = shuffleArray(allQuestions).slice(0, 20);
        userAnswers = new Array(questions.length).fill(-1);
        currentQuestion = 0;
        score = 0;
        timeLeft = 20 * 60;
        scoreDisplay.textContent = '0';
        timerDisplay.textContent = '20:00';
        timerDisplay.classList.remove('timer-warning', 'timer-danger');

        lectureScreen.classList.remove('active');
        examScreen.classList.add('active');
        startTimer();
        displayQuestion(0);
    }

    function shuffleArray(array) {
        let arr = array.slice();
        for (let i = arr.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [arr[i], arr[j]] = [arr[j], arr[i]];
        }
        return arr;
    }

    // ===================== وظائف الاختبار =====================
    function startTimer() {
        clearInterval(timer);
        timer = setInterval(() => {
            timeLeft--;
            const minutes = Math.floor(timeLeft / 60);
            const seconds = timeLeft % 60;
            timerDisplay.textContent = `${minutes.toString().padStart(2,'0')}:${seconds.toString().padStart(2,'0')}`;
            if(timeLeft <= 60) timerDisplay.classList.add('timer-danger');
            else if(timeLeft <= 300) timerDisplay.classList.add('timer-warning');
            if(timeLeft <= 0){ clearInterval(timer); finishExam(); }
        },1000);
    }

    function displayQuestion(index){
        currentQuestion = index;
        const q = questions[index];
        currentQDisplay.textContent = index + 1;
        questionText.textContent = q.question;
        optionsContainer.innerHTML = '';
        q.options.forEach((opt,i)=>{
            const btn = document.createElement('button');
            btn.textContent = opt;
            btn.className = 'option-btn';
            if(userAnswers[index]===i) btn.classList.add('selected');
            btn.addEventListener('click', ()=> selectOption(i));
            optionsContainer.appendChild(btn);
        });
        prevBtn.disabled = index===0;
        nextBtn.disabled = index===questions.length-1;
    }

function selectOption(optionIndex) {
    // إذا الجواب موجود بالفعل ما في تعديل
    if (userAnswers[currentQuestion] !== -1) return;

    // حفظ الإجابة
    userAnswers[currentQuestion] = optionIndex;

    const options = document.querySelectorAll('.option-btn');

    const isCorrect = optionIndex === questions[currentQuestion].correct;

    options.forEach((btn, i) => {
        btn.classList.remove('selected');

        if (i === optionIndex) {
            btn.classList.add('selected');
        }

        // تلوين الإجابة الصحيحة والخاطئة
        if (i === questions[currentQuestion].correct) {
            btn.classList.add('correct-answer'); // أخضر
        } else if (i === optionIndex && !isCorrect) {
            btn.classList.add('wrong-answer'); // أحمر
        }

        // تعطيل الخيارات فقط، مش زر التالي
        btn.disabled = true;
    });

    // الأصوات
    if (isCorrect) {
        playSound('correct');
        score++;
        scoreDisplay.textContent = score;

        // انتقال تلقائي بعد نص ثانية
        setTimeout(() => {
            if (currentQuestion < questions.length - 1) {
                displayQuestion(currentQuestion + 1);
            } else {
                finishExam();
            }
        }, 500);
    } else {
        // إذا غلط، صوت خطأ، واللاعب يضغط "التالي" بنفسه
        playSound('wrong');
        nextBtn.disabled = false; // تأكد أن زر التالي مفعل
    }
}



    prevBtn.addEventListener('click', ()=> {
        if(currentQuestion>0) displayQuestion(currentQuestion-1);
    });

    nextBtn.addEventListener('click', ()=> {
        if(currentQuestion<questions.length-1) displayQuestion(currentQuestion+1);
    });

    submitBtn.addEventListener('click', ()=> {
        if(confirm("هل أنت متأكد من إنهاء الاختبار؟")) finishExam();
    });

    function finishExam(){
        clearInterval(timer);
        let correct=0,wrong=0,skipped=0;
        questions.forEach((q,i)=>{
            if(userAnswers[i]===-1) skipped++;
            else if(userAnswers[i]===q.correct) correct++;
            else wrong++;
        });
        const finalScore = Math.round((correct/questions.length)*100);
        correctCountDisplay.textContent = correct;
        wrongCountDisplay.textContent = wrong;
        skippedCountDisplay.textContent = skipped;
        finalScoreDisplay.textContent = finalScore+'%';
        answersReview.innerHTML = '';
        questions.forEach((q,i)=>{
            const div = document.createElement('div');
            div.className='answer-item';
            let status='skipped', statusText='غير مجاب', userAnswerText='لم تجب';
            if(userAnswers[i]!==-1){
                userAnswerText=q.options[userAnswers[i]];
                if(userAnswers[i]===q.correct){ status='correct'; statusText='صحيح'; }
                else { status='wrong'; statusText='خطأ'; }
            }
            div.classList.add(status);
            div.innerHTML = `<strong>سؤال ${i+1}:</strong> ${q.question}<br>
            إجابتك: ${userAnswerText}<br>
            الإجابة الصحيحة: ${q.options[q.correct]}<br>
            الحالة: ${statusText}<br>
            شرح: ${q.explanation}`;
            answersReview.appendChild(div);
        });

        examScreen.classList.remove('active');
        resultScreen.classList.add('active');

        if(finalScore>=70) playSound('correct'); else playSound('wrong');
    }

    restartBtn.addEventListener('click', ()=>{
        currentQuestion=0; userAnswers=[]; score=0; timeLeft=20*60;
        scoreDisplay.textContent='0'; timerDisplay.textContent='20:00';
        timerDisplay.classList.remove('timer-warning','timer-danger');
        resultScreen.classList.remove('active'); startScreen.classList.add('active');
    });

    homeBtn.addEventListener('click', ()=>{
        resultScreen.classList.remove('active'); startScreen.classList.add('active');
    });

    function playSound(type){
        if(type==='correct'){ correctSound.currentTime=0; correctSound.play(); }
        else if(type==='wrong'){ wrongSound.currentTime=0; wrongSound.play(); }
    }

    startBtn.addEventListener('click', showSubjects);
</script>
</body>
</html>

